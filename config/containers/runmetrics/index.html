<!-- Page generated 2020-07-16 21:49:37 +0900 -->
<!-- Logic for 'edit this button'


    

    

    

    

    

    

    

    

-->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <style type="text/css">
      @charset "UTF-8";
      [ng\:cloak],
      [ng-cloak],
      [data-ng-cloak],
      [x-ng-cloak],
      .ng-cloak,
      .x-ng-cloak,
      .ng-hide:not(.ng-hide-animate) {
          display: none !important;
      }

      ng\:form {
          display: block;
      }
  </style>
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-WL2QLG5');</script>

  
  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
  <meta name="msapplication-TileImage" content="/docs.docker.jp.onthefly/favicons/docs@2x.ico">
  <link rel="apple-touch-icon" type="image/x-icon" href="/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
  <meta property="og:image" content="/docs.docker.jp.onthefly/favicons/docs@2x.ico"/>
  <!-- metadata -->
  <meta property="og:type" content="website"/>
  <meta property="og:updated_time" itemprop="dateUpdated" content="2020-07-16T21:49:37+09:00"/>
  <meta property="og:image" itemprop="image primaryImageOfPage" content="/docs.docker.jp.onthefly/images/docs@2x.png"/>
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:domain" content="docs.docker.com"/>
  <meta name="twitter:site" content="@docker_docs"/>
  <meta name="twitter:url" content="https://twitter.com/docker_docs"/>
  <meta name="twitter:title" itemprop="title name" content="ランタイムメトリックス"/>
  <meta name="twitter:description" property="og:description" itemprop="description" content="docker stats docker stats コマンドを使うと、コンテナーの実行メトリックスからの出力を順次得ることができます。 このコマンドは、CPU、メモリ使用量、メモリ上限、ネットワーク I/O に対するメトリックスをサポートしています。 以下は docker stats コマンドの出力例です。 $ docker stats redis1 redis2 CONTAINER CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O..." />
  <meta name="twitter:image:src" content="/docs.docker.jp.onthefly/images/docs@2x.png"/>
  <meta name="twitter:image:alt" content="Docker ドキュメント"/>
  <meta property="article:published_time" itemprop="datePublished" content="2020-07-16T21:49:37+09:00"/>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="keywords" content="docker, metrics, CPU, memory, disk, IO, run, runtime, stats">
  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/font-awesome.min.css">
  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/bootstrap.min.css">
  <link id="pygments" rel="stylesheet" href="/docs.docker.jp.onthefly/css/pygments/perldoc.css">
  <link id="pagestyle" rel="stylesheet" href="/docs.docker.jp.onthefly/css/style.css">

  <!-- Go get "Open Sans" font from Google -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  <!-- SEO stuff -->
  <title>ランタイムメトリックス | Docker ドキュメント</title>
  <meta property="og:title" content="ランタイムメトリックス" />
  <meta property="og:locale" content="ja_JP" />
  <meta name="description" content="Measure the behavior of running containers" />
  <meta property="og:description" content="Measure the behavior of running containers" />
  <link rel="canonical" href="/config/containers/runmetrics/" />
  <meta property="og:url" content="https://docs.docker.com/config/containers/runmetrics/" />
  <meta property="og:site_name" content="Docker ドキュメント" />
  <script type="application/ld+json">{"@context":"http://schema.org","@type":"WebPage","headline":"ランタイムメトリックス","description":"Measure the behavior of running containers","url":"https://docs.docker.com/config/containers/runmetrics/"}</script>
  <!-- END SEO STUFF -->
  
</head>


    <body ng-app="Docker" ng-controller="DockerController" class="colums">
    <header>
        <nav class="nav-secondary navbar navbar-fixed-top">
    <!-- <div class="fan"></div> -->
    <div class="container-fluid">
        <div class="navbar-header">
            <a href="/docs.docker.jp.onthefly/">
                <img class="logo" src="/docs.docker.jp.onthefly/images/docker-docs-logo.svg" alt="Docker Docs" title="Docker Docs">
            </a>
        </div>
        <div class="navbar-collapse" aria-expanded="false" style="height: 1px;">
            <div class="logo-mobile">
    <a href="/docs.docker.jp.onthefly/">
        <img src="/docs.docker.jp.onthefly/images/docker-icon.svg" alt="Docker Docs" title="Docker Docs">
    </a>
</div>
<div class="search-form" id="search-div">
    <form class="search-form form-inline ng-pristine ng-valid" id="searchForm" action="/docs.docker.jp.onthefly/search/">
        <input class="search-field form-control ds-input" id="st-search-input" value="" name="q" placeholder="文書内検索" type="search" autocomplete="off" spellcheck="false" dir="auto" style="position: relative; vertical-align: top;">
        <div id="autocompleteContainer">
            <div id="autocompleteResults"></div>
        </div>
        <!-- <button type="submit" class="search-submit btn btn-default">検索</button> -->
    </form>
</div>
<div class="sidebar-toggle">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
    </button>
</div>
<div class="nav-container hidden-sm hidden-xs">
    <div id="tabs">
        <ul class="tabs jsTOCHorizontal">

        </ul>
    </div>
    <div class="ctrl-right">
        <a href="javascript:void(0)" id="menu-toggle"><i class="fa fa-indent" aria-hidden="true"></i></a>
    </div>
</div>

        </div>
    </div>
</nav>

    </header>
    <div class="wrapper right-open">
        <div class="container-fluid">
            <div class="row">
                <div class="col-body">
                    <main class="col-content content">
                        <section class="section">
                            
                            
                            <h1>ランタイムメトリックス</h1> 
                            <span class="reading-time" title="Estimated reading time">
  <span class="reading-time-label">読む時間の目安: </span>
  
  
    5 分
  
</span>

                            
                            
<h2 id="docker-stats">docker stats</h2>

<p><code class="highlighter-rouge">docker stats</code> コマンドを使うと、コンテナーの実行メトリックスからの出力を順次得ることができます。
このコマンドは、CPU、メモリ使用量、メモリ上限、ネットワーク I/O に対するメトリックスをサポートしています。</p>

<p>以下は <code class="highlighter-rouge">docker stats</code> コマンドの出力例です。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker stats redis1 redis2

CONTAINER           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O
redis1              0.07%               796 KB / 64 MB        1.21%               788 B / 648 B       3.568 MB / 512 KB
redis2              0.07%               2.746 MB / 64 MB      4.29%               1.266 KB / 648 B    12.4 MB / 0 B
</code></pre></div></div>

<p><a href="/docs.docker.jp.onthefly/engine/reference/commandline/stats/">docker stats</a> のリファレンスページでは、より詳細に <code class="highlighter-rouge">docker stats</code> コマンドについて説明しています。</p>

<h2 id="control-groups">コントロールグループ</h2>

<p>Linux のコンテナーは <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">コントロールグループ</a> に依存しています。
コントロールグループは、単に複数のプロセスを追跡するだけでなく、CPU、メモリ、ブロック I/O 使用量に関するメトリックスを提供します。
そういったメトリックスがアクセス可能であり、同様にネットワーク使用量のメトリックスも得ることができます。
これは「純粋な」LXC コンテナーに関連しており、Docker のコンテナーにも関連します。</p>

<p>コントロールグループは擬似ファイルシステムを通じて提供されます。
最近のディストリビューションでは、このファイルシステムは <code class="highlighter-rouge">/sys/fs/cgroup</code> にあります。
このディレクトリの下には devices、freezer、blkio などのサブディレクトリが複数あります。
これらのサブディレクトリが、独特の cgroup 階層を構成しています。</p>

<p>かつてのシステムでは、コントロールグループが <code class="highlighter-rouge">/cgroup</code> にマウントされていて、わかりやすい階層構造にはなっていませんでした。
その場合、サブディレクトリそのものを確認していくのではなく、サブディレクトリ内にある数多くのファイルを見渡して、そのディレクトリが既存のコンテナーに対応するものであろう、と確認していくしかありません。</p>

<p>コントロールグループがどこにマウントされているかを確認するには、以下を実行します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">grep </span>cgroup /proc/mounts
</code></pre></div></div>

<h3 id="enumerate-cgroups">cgroups の確認</h3>

<p><code class="highlighter-rouge">/proc/cgroups</code> を覗いてみるとわかりますが、システムが利用するコントロールグループのサブシステムには実にさまざまなものがあり、それが階層化されていて、数多くのグループが含まれているのがわかります。</p>

<p>また <code class="highlighter-rouge">/proc/&lt;pid&gt;/cgroup</code> を確認してみれば、1 つのプロセスがどのコントロールグループに属しているかがわかります。
そのときのコントロールグループは、階層構造のルートとなるマウントポイントからの相対パスで表わされます。
<code class="highlighter-rouge">/</code> が表示されていれば、そのプロセスにはグループが割り当てられていません。
一方 <code class="highlighter-rouge">/lxc/pumpkin</code> といった表示になっていれば、そのプロセスは <code class="highlighter-rouge">pumpkin</code> という名のコンテナーのメンバーであることがわかります。</p>

<h3 id="find-the-cgroup-for-a-given-container">特定コンテナーに対応する cgroup の検索</h3>

<p>各コンテナーでは、各階層内に 1 つの cgroup が生成されます。
かつてのシステムにおいて、ユーザーランドツール LXC の古い版を利用している場合、cgroup 名はそのままコンテナー名になっています。
より新しい LXC ツールでの cgroup 名は <code class="highlighter-rouge">lxc/&lt;コンテナー名&gt;</code> となります。</p>

<p>cgroup を利用する Docker コンテナーにおいて、コンテナー名は、コンテナーの完全 ID か、あるいは長めの ID となります。
<code class="highlighter-rouge">docker ps</code> によってコンテナーが ae836c95b4c3 のように示されていたら、長めの ID はたとえば <code class="highlighter-rouge">ae836c95b4c3c9e9179e0e91015512da89fdec91612f63cebae57df9a5444c79</code> のようなものになります。
これは <code class="highlighter-rouge">docker inspect</code> を用いるか、あるいは <code class="highlighter-rouge">docker ps --no-trunc</code> とすれば確認することができます。</p>

<p>Docker コンテナーに対するメモリメトリックスを取りまとめて確認するには、<code class="highlighter-rouge">/sys/fs/cgroup/memory/docker/&lt;longid&gt;/</code> を見ます。</p>

<h3 id="metrics-from-cgroups-memory-cpu-block-io">cgroups の各メトリックス、メモリ、CPU、ブロック I/O</h3>

<p>各サブシステム（メモリ、CPU、ブロック I/O）に対しては、擬似ファイルシステムが存在し、そこに統計情報が含まれます。</p>

<h4 id="memory-metrics-memorystat">メモリメトリックス: <code class="highlighter-rouge">memory.stat</code></h4>

<p>メモリメトリックスは cgroup の「memory」にあります。
メモリコントロールグループには多少のオーバーヘッドがあります。
ホスト上のメモリ利用量をきめ細かく算出しているためです。
したがって各種ディストリビューションの多くでは、デフォルトでこれを無効にしています。
これを有効にする方法は、一般的にはカーネルのコマンドラインパラメーター <code class="highlighter-rouge">cgroup_enable=memory swapaccount=1</code> といったものを追加するだけです。</p>

<p>メトリックスは擬似ファイルシステム <code class="highlighter-rouge">memory.stat</code> 内にあります。
これは以下のように表わされます。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cache 11492564992
rss 1930993664
mapped_file 306728960
pgpgin 406632648
pgpgout 403355412
swap 0
pgfault 728281223
pgmajfault 1724
inactive_anon 46608384
active_anon 1884520448
inactive_file 7003344896
active_file 4489052160
unevictable 32768
hierarchical_memory_limit 9223372036854775807
hierarchical_memsw_limit 9223372036854775807
total_cache 11492564992
total_rss 1930993664
total_mapped_file 306728960
total_pgpgin 406632648
total_pgpgout 403355412
total_swap 0
total_pgfault 728281223
total_pgmajfault 1724
total_inactive_anon 46608384
total_active_anon 1884520448
total_inactive_file 7003344896
total_active_file 4489052160
total_unevictable 32768
</code></pre></div></div>

<p>前半部分（<code class="highlighter-rouge">total_</code> が先頭につくものを除く）は cgroup 内のプロセスに対応する統計情報であり、サブ crgoup は除くものです。
後半部分（<code class="highlighter-rouge">total_</code> が先頭につくもの）は同様ですが、ただしサブ cgroup を含むものです。</p>

<p>メトリックスの中には「メーター」つまり増減を繰り返す値表記になっているものがあります。
たとえば <code class="highlighter-rouge">swap</code> は、cgroup のメンバーによって利用されるスワップ容量の合計です。
この他に「カウンター」となっているもの、つまり数値がカウントアップされていくものがあります。
これは特定のイベントがどれだけ発生したかを表わします。
たとえば <code class="highlighter-rouge">pgfault</code> は cgroup の生成以降に、どれだけページフォールトが発生したかを表わします。</p>

<style>table tr > td:first-child { white-space: nowrap;}</style>

<table>
  <thead>
    <tr>
      <th>メトリックス</th>
      <th>内容説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>cache</strong></td>
      <td>このコントロールグループのプロセスによるメモリ使用量です。ブロックデバイス上の各ブロックに細かく関連づけられるものです。ディスク上のファイルと読み書きを行うと、この値が増加します。ふだん利用する I/O（システムコールの <code class="highlighter-rouge">open</code>、<code class="highlighter-rouge">read</code>、<code class="highlighter-rouge">write</code>）利用時に発生し、（<code class="highlighter-rouge">mmap</code> を用いた）マップファイルの場合も同様です。<code class="highlighter-rouge">tmpfs</code> によるメモリ使用もここに含まれますが、理由は明らかではありません。</td>
    </tr>
    <tr>
      <td><strong>rss</strong></td>
      <td>ディスク上の操作に対応づかないメモリ使用量です。たとえばスタック、ヒープ、匿名メモリマップなどです。</td>
    </tr>
    <tr>
      <td><strong>mapped_file</strong></td>
      <td>このコントロールグループのプロセスによって割り当てられるメモリの使用量です。メモリを <strong>どれだけ</strong> 利用しているかの情報は得られません。ここからわかるのは <strong>どのように</strong> 利用されているかです。</td>
    </tr>
    <tr>
      <td><strong>pgfault</strong>, <strong>pgmajfault</strong></td>
      <td>cgroup のプロセスにおいて発生した「ページフォールト」、「メジャーフォールト」の回数を表わします。ページフォールトは、プロセスがアクセスした仮想メモリスペースの一部が、存在していないかアクセス拒否された場合に発生します。存在しないというのは、そのプロセスにバグがあり、不正なアドレスにアクセスしようとしたことを表わします（<code class="highlighter-rouge">SIGSEGV</code> シグナルが送信され、<code class="highlighter-rouge">Segmentation fault</code> といういつものメッセージを受けたとたんに、プロセスが停止されます）。アクセス拒否されるのは、スワップしたメモリ領域、あるいはマップファイルに対応するメモリ領域を読み込もうとしたときに発生します。この場合、カーネルがディスクからページを読み込み、CPU のメモリアクセスを成功させます。またコピーオンライトメモリ領域へプロセスが書き込みを行う場合にも発生することがあります。同様にカーネルがプロセスの切り替え（preemption）を行ってからメモリページを複製し、ページ内のプロセス自体のコピーに対して書き込み処理を復元します。「メジャーフォールト」はカーネルがディスクからデータを読み込む必要がある際に発生します。既存ページを複製する場合や空のページを割り当てる場合は、通常の（つまり「マイナー」の）フォールトになります。</td>
    </tr>
    <tr>
      <td><strong>swap</strong></td>
      <td>この cgroup 内のプロセスによって現時点利用されているスワップ総量です。</td>
    </tr>
    <tr>
      <td><strong>active_anon</strong>、<strong>inactive_anon</strong></td>
      <td>カーネルによって <strong>アクティブ</strong> か <strong>非アクティブ</strong> のいずれかに特定される <strong>匿名</strong> メモリの使用量です。「匿名」 メモリとは、ディスクページにひもづいて <strong>いない</strong> メモリのことです。別の表現でいえば、上で示した rss カウンターと同等のものです。正確な rss カウンターの定義式は、<strong>active_anon</strong> ＋ <strong>inactive_anon</strong> － <strong>tmpfs</strong> です。（このコントロールグループによってマウントされている <code class="highlighter-rouge">tmpfs</code> ファイルシステムが利用するメモリ使用量のことです。）では “アクティブ” と “非アクティブ” の違いは？  ページは初めは “アクティブ” です。一定間隔でカーネルがメモリを走査し、一部に “非アクティブ” というタグをつけます。再度アクセスが行われると、すぐに “アクティブ” というタグにつけかえられます。カーネルがほぼメモリ不足に陥って、ディスクへのスワップが必要になると、カーネルは “非アクティブ” ページをスワップします。</td>
    </tr>
    <tr>
      <td><strong>active_file</strong>, <strong>inactive_file</strong></td>
      <td>上で示した <strong>anon</strong> メモリと同様、<strong>アクティブ</strong>、<strong>非アクティブ</strong> の状態があるキャッシュメモリのこと。正確な式で表現すると、<strong>cache</strong> ＝ <strong>active_file</strong> ＋ <strong>inactive_file</strong> ＋ <strong>tmpfs</strong> です。カーネルが採用する規則として、アクティブ、非アクティブなメモリページを移動させる方法は、匿名メモリのときとは異なります。ただしその一般的な原理は同じです。カーネルがメモリを要求するとき、プール上からクリーンな（修正がかかっていない）ページを取り出すことの方が簡単に済みます。取り出すことがすぐにできるからです。（一方、匿名ページや、修正のかかった汚れたページでは、その前にディスクに書き出すことが必要になるからです。）</td>
    </tr>
    <tr>
      <td><strong>unevictable</strong></td>
      <td>取り出し要求ができないメモリ容量のことです。一般には <code class="highlighter-rouge">mlock</code> によって「ロックされた」メモリとされます。暗号フレームワークにおいて利用されることがあり、秘密鍵や機密情報がディスクにスワップされないようにするものです。</td>
    </tr>
    <tr>
      <td><strong>memory_limit</strong>, <strong>memsw_limit</strong></td>
      <td>これは実際のメトリックスではありません。この cgroup に適用される上限を確認するためのものです。<strong>memory_limit</strong> は、このコントロールグループのプロセスが利用可能な物理メモリの最大容量を示します。<strong>memsw_limit</strong> は RAM ＋ スワップの最大容量を示します。</td>
    </tr>
  </tbody>
</table>

<p>ページキャッシュ内のメモリの計算は非常に複雑です。
コントロールグループの異なるプロセスが 2 つあって、それが同一のファイル（最終的にディスク上の同一ブロックに存在）を読み込むとします。
その際のメモリの負担は、それぞれのコントロールグループに分割されます。
これは一見すると良いことのように思えます。
しかし一方の cgroup が停止したとします。
そうすると他方の cgroup におけるメモリ使用量が増大してしまうことになります。
両者のメモリページに対する使用コストは、もう共有されていないからです。</p>

<h3 id="cpu-metrics-cpuacctstat">CPU メトリックス: <code class="highlighter-rouge">cpuacct.stat</code></h3>

<p>これまでメモリメトリックスについて説明してきました。
これ以外のものは比較的簡単です。
CPU メトリックスは <code class="highlighter-rouge">cpuacct</code> コントローラー内にあります。</p>

<p>各コンテナーに対応して擬似ファイル <code class="highlighter-rouge">cpuacct.stat</code> があり、コンテナープロセスの CPU 使用時間が積算されています。
そしてこれが <code class="highlighter-rouge">user</code> 時間と <code class="highlighter-rouge">system</code> 時間に割り振られています。
両者の違いは以下のとおりです。</p>

<ul>
  <li><code class="highlighter-rouge">user</code> 時間は、プロセスが CPU を直接制御して、プロセスコードを実行している時間のことです。</li>
  <li><code class="highlighter-rouge">system</code> 時間は、カーネルがプロセスのためにシステムコールを実行している時間のことです。</li>
</ul>

<p>この時間は 1/100 秒の tick という周期で表わされます。
別名「user jiffies」ともいいます。
1 秒には <code class="highlighter-rouge">USER_HZ</code> 分の「<strong>jiffies</strong>」があり、x86 システムでは <code class="highlighter-rouge">USER_HZ</code> は 100 です。
これまでの経緯として、これは 1 秒に割り当てられるスケジューラー「ticks」の数です。
ただしそれ以上に頻繁にスケジューリングされることや、<a href="http://lwn.net/Articles/549580/">tickless kernels</a> があり、これらは ticks 数は関係がなくなります。</p>

<h4 id="block-io-metrics">ブロック I/O メトリックス</h4>

<p>ブロック I/O は <code class="highlighter-rouge">blkio</code> コントローラーにおいて計算されます。
さまざまなメトリックスが、さまざまなファイルにわたって保持されています。
より詳細は、カーネルドキュメント内にある <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt">blkio-controller</a> ファイルに記述されていますが、以下では最も関連のあるものを簡潔に示します。</p>

<table>
  <thead>
    <tr>
      <th>メトリックス</th>
      <th>内容説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>blkio.sectors</strong></td>
      <td>512 バイトのセクター数。cgroup のプロセスメンバーによって、デバイスごとに読み書きされます。読み書きは 1 つのカウンターに合計されます。</td>
    </tr>
    <tr>
      <td><strong>blkio.io_service_bytes</strong></td>
      <td>cgroup によって読み書きされるバイト数を表わします。デバイスごとに 4 つのカウンターがあります。1 つのデバイスつき、同期、非同期 I/O の別、読み込み、書き込みの別があるからです。</td>
    </tr>
    <tr>
      <td><strong>blkio.io_serviced</strong></td>
      <td>処理された I/O 操作の数。そのサイズとは無関係です。デバイスごとに、やはり 4 つのカウンターがあります。</td>
    </tr>
    <tr>
      <td><strong>blkio.io_queued</strong></td>
      <td>この cgroup において、その時点でキューに入っている I/O 操作の数を表わします。言い換えると  cgroup に I/O が発生していなければ、この値はゼロになります。一方、この逆は正しくなりません。I/O がキューに入っていなかったとしても、それは cgroup が（I/O 的に）アイドルであるとは言えません。普段は静止しているデバイスが、純粋に同期読み込み処理を行っているかもしれないからです。その場合には、I/O 操作をすぐに処理できるわけであり、キューに入れることなく扱うことができます。またこのメトリックスは I/O サブシステム上のどの cgroup に負荷がかかっているかがわかります。ただし示される値は相対的な量にすぎません。プロセスグループがこれ以上に I/O を処理しない場合であっても、他のデバイスの影響によりデバイス負荷が増加するため、キューサイズも増加することになります。</td>
    </tr>
  </tbody>
</table>

<h3 id="network-metrics">ネットワークメトリックス</h3>

<p>ネットワークメトリックスは、コントロールグループによって直接表わされるものではありません。
わかりやすく説明します。
ネットワークインターフェースは、<strong>ネットワーク名前空間</strong> コンテキストの中に存在します。
カーネルは、プロセスグループとの間で送受信されるパケットやバイトに関して、メトリックスを収集します。
ただこのメトリックスはあまり役に立つものではありません。
欲しいのはインターフェースごとのメトリックスであるはずです。
（なぜならメトリックスでは <code class="highlighter-rouge">lo</code> インターフェースに発生するトラフィックはカウントされません。）
もっとも 1 つの cgroup は、複数のネットワーク名前空間に属することができるため、そのメトリックスを計算することは、より難しくなります。
複数のネットワーク名前空間になるということは、<code class="highlighter-rouge">lo</code> インターフェースが複数あるということであり、場合によっては複数の <code class="highlighter-rouge">eth0</code> インターフェースを持つこともあります。
コントロールグループを用いてネットワークメトリックスを簡単に集めることができないのは、こういった理由によります。</p>

<p>そのかわり、ネットワークメトリックスは別の情報から収集することができます。</p>

<h4 id="iptables">IPtables</h4>

<p>iptables （むしろ iptables がインターフェースとなる netfilter フレームワーク）から重要な情報が得られます。</p>

<p>たとえばウェブサーバー上におけるアウトバウンド HTTP トラフィックを計算するルールを設定することができます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>iptables <span class="nt">-I</span> OUTPUT <span class="nt">-p</span> tcp <span class="nt">--sport</span> 80
</code></pre></div></div>

<p>ここでは <code class="highlighter-rouge">-j</code> フラグや <code class="highlighter-rouge">-g</code> フラグは用いません。
このルールがパケットをカウントし、後続のルールの処理を行います。</p>

<p>このカウンター値は以下のようにして確認できます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>iptables <span class="nt">-nxvL</span> OUTPUT
</code></pre></div></div>

<p>技術的なことだけで言えば <code class="highlighter-rouge">-n</code> は必要ありません。
DNS の逆引きを避けるためのものですが、ここでの作業ではおそらく不要です。</p>

<p>カウンターにはパケット数とバイト数があります。
このトラフィックのようなメトリックスを設定したい場合は、<code class="highlighter-rouge">for</code> ループを実行して、コンテナー IP アドレスに対して 2 つの <code class="highlighter-rouge">iptables</code> ルールを <code class="highlighter-rouge">FORWARD</code> チェーンに追加します（1 方向に対して 1 つ）。
これにより NAT 層を通過するトラフィックのみ計測されます。
ユーザーランドプロキシーを通過するトラフィックを計測する場合も、ルールを追加する必要があります。</p>

<p>これを行ったら、カウンターを定期的に確認することになります。
<code class="highlighter-rouge">collectd</code> を使ってみるのであれば、iptables のカウンター情報を自動的に収集してくれる <a href="https://collectd.org/wiki/index.php/Table_of_Plugins">便利なプラグイン</a> があります。</p>

<h4 id="interface-level-counters">インターフェースレベルのカウンター</h4>

<p>各コンテナーには仮想イーサネットインターフェースがあるので、このインターフェースの TX および RX カウンターを直接確認したいかもしれません。
各コンテナーは、ホスト上の仮想イーサネットインターフェースに関連づけられていて、その名称は <code class="highlighter-rouge">vethKk8Zqi</code> などとなっています。
もっともどのコンテナーに対して、どのインターフェースが対応しているかを判別するのは、残念ながら困難です。</p>

<p>今のところ、メトリックスを確認する一番の方法は、<strong>そのコンテナー内部から</strong> 確認することです。
これを実現する方法は、<strong>ip netns を巧みに</strong> 利用します。
これを使えば、コンテナーのネットワーク名前空間内に、ホスト環境からモジュールを実行させることができます。</p>

<p><code class="highlighter-rouge">ip-netns exec</code> コマンドは、どのようなネットワーク名前空間内に対しても、現在のプロセスから状況を確認できる形で（ホスト内に存在する）プログラムを何でも実行することができます。
つまりコンテナーのネットワーク名前空間内に、ホストから入ることができるということです。
ただしコンテナーからは、ホストや別のコンテナーにはアクセスできません。
サブコンテナーであれば、互いに通信することができます。</p>

<p>このコマンドの正確な書式は以下のとおりです。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ip netns <span class="nb">exec</span> &lt;nsname&gt; &lt;command...&gt;
</code></pre></div></div>

<p>たとえば以下のように実行します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ip netns <span class="nb">exec </span>mycontainer netstat <span class="nt">-i</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ip netns</code> コマンドは、名前空間の擬似ファイルからコンテナー “mycontainer” を探します。
各プロセスは 1 つのネットワーク名前空間、1 つの PID 名前空間、1 つの <code class="highlighter-rouge">mnt</code> 名前空間、といったものに属します。
これらの名前空間は <code class="highlighter-rouge">/proc/&lt;pid&gt;/ns/</code> の下に実現されます。
たとえば PID が 42 であるネットワーク名前空間は、擬似ファイル <code class="highlighter-rouge">/proc/42/ns/net</code> として実現されます。</p>

<p><code class="highlighter-rouge">ip netns exec mycontainer ...</code> が実行されるとき、<code class="highlighter-rouge">/var/run/netns/mycontainer</code> が擬似ファイルの 1 つであるとみなされます。
（シンボリックリンクが張られています。）</p>

<p>別の点から表現すると、コンテナーのネットワーク名前空間内にてコマンドを実行するためには、以下のことが必要になるということです。</p>

<ul>
  <li>調査したいコンテナー内部で動作させるプロセスの PID を調べます。</li>
  <li><code class="highlighter-rouge">/var/run/netns/&lt;somename&gt;</code> から <code class="highlighter-rouge">/proc/&lt;pid&gt;/ns/net</code> へのシンボリックリンクを生成します。</li>
  <li><code class="highlighter-rouge">ip netns exec &lt;somename&gt; ....</code> を実行します。</li>
</ul>

<p>ネットワーク使用量の計測を行おうとしているコンテナー内部のプロセスに対し、その cgroup がどれであるかを探し出すには <a href="#enumerate-cgroups">cgroups の確認</a> を参照してください。
その方法に従って、<code class="highlighter-rouge">tasks</code> という名前の擬似ファイルを調べます。
その擬似ファイル内には cgroup 内の（つまりコンテナー内の） PID がすべて示されています。
そのうちの 1 つを取り出して扱います。</p>

<p>環境変数 <code class="highlighter-rouge">$CID</code> にコンテナーの「短めの ID」が設定されているとし、これまで説明してきたことをすべてまとめて、以下のコマンドとして実行します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ TASKS</span><span class="o">=</span>/sys/fs/cgroup/devices/docker/<span class="nv">$CID</span><span class="k">*</span>/tasks
<span class="nv">$ PID</span><span class="o">=</span><span class="k">$(</span>head <span class="nt">-n</span> 1 <span class="nv">$TASKS</span><span class="k">)</span>
<span class="nv">$ </span>mkdir <span class="nt">-p</span> /var/run/netns
<span class="nv">$ </span>ln <span class="nt">-sf</span> /proc/<span class="nv">$PID</span>/ns/net /var/run/netns/<span class="nv">$CID</span>
<span class="nv">$ </span>ip netns <span class="nb">exec</span> <span class="nv">$CID</span> netstat <span class="nt">-i</span>
</code></pre></div></div>

<h2 id="tips-for-high-performance-metric-collection">詳細なメトリックスを収集するためのヒント</h2>

<p>新しいプロセスを起動するたびに、メトリックスを最新のものにすることは（比較的）面倒なことです。
詳細なメトリックスが必要な場合、しかもそれが非常に多くのコンテナー（1 ホスト上に 1000 個くらいのコンテナー）を扱わなければならないとしたら、毎回の新規プロセス起動は行う気になれません。</p>

<p>1 つのプロセスを作り出してメトリックスを収集する方法をここに示します。
メトリックスを収集するプログラムを C 言語（あるいは低レベルシステムコールを実行できる言語）で記述する必要があります。
利用するのは特別なシステムコール <code class="highlighter-rouge">setns()</code> です。
これはその時点でのプロセスを、任意の名前空間に参加させることができます。
そこでは、その名前空間に応じた擬似ファイルへのファイルディスクリプターをオープンしておくことが必要とされます。
（擬似ファイルは <code class="highlighter-rouge">/proc/&lt;pid&gt;/ns/net</code> にあることを思い出してください。）</p>

<p>ただしこれは本当のことではありません。
実はファイルディスクリプターをオープンにしておく必要はないのです。
オープンにしたままであると、コントロールグループの最後の 1 つとなるプロセスがある場合に、名前空間は削除されず、そのネットワークリソース（コンテナーの仮想インターフェースなど）がずっと残り続けてしまいます。
（あるいはそれは、ファイルディスクリプターを閉じるまで続きます。）</p>

<p>適切なやり方は、各コンテナーの初めの PID を追跡し、ことあるごとに名前空間の擬似ファイルを、その都度開いて確認していくしかありません。</p>

<h2 id="collect-metrics-when-a-container-exits">コンテナー起動時のメトリックス収集</h2>

<p>リアルタイムにメトリックスを収集する、ということに気づかない方もいます。
しかしコンテナーがそこにあれば、CPU、メモリなどをどれだけ利用しているかを知りたくなります。</p>

<p>Docker は <code class="highlighter-rouge">lxc-start</code> によって処理を行うため、リアルタイムなメトリックス収集は困難です。
<code class="highlighter-rouge">lxc-start</code> が自身の処理の後に、まわりをきれいにしてしまうためです。
メトリックスの収集は、一定間隔をおいて取得するのが、より簡単な方法と言えます。
<code class="highlighter-rouge">collectd</code> にある LXC プラグインは、この方法により動作しています。</p>

<p>コンテナーを停止してから情報収集する方がよいのであれば、以下の方法をとります。</p>

<p>各コンテナーにおいて、情報収集用のプロセスを実行し、コントロールグループに移動させます。
そのコントロールグループとは監視対象としたいもので、cgroup のタスクファイル内に PID を記述しておきます。
情報収集のプロセスは、定期的にそのタスクファイルを読み込み、そのプロセス自体が、コントロールグループ内で残っている最後のプロセスであるかどうかを確認します。
（前節に示したように、ネットワーク統計情報も収集したい場合は、そのプロセスを適切なネットワーク名前空間において実行することも必要になります。）</p>

<p>コンテナーが終了するときに、<code class="highlighter-rouge">lxc-start</code> はコントロールグループを削除しようとします。
削除に失敗するのは、コントロールグループがまだ利用されているということです。
でも問題ありません。
情報収集用のプロセスはこのとき、コントロールグループ内にはただ 1 つのプロセスしか残っていないことが検出できるはずです。
このときこそ、メトリックスをすべて収集するタイミングとなります。</p>

<p>最後にそのプロセスを root コントロールグループに戻して、コンテナーのコントロールグループを削除します。
コントロールグループの削除は、単にそのディレクトリを <code class="highlighter-rouge">rmdir</code> で削除するだけです。
ディレクトリ内にファイルが残っているのに、ディレクトリを削除するというのは、やってはいけないことのように思えます。
しかしこれは擬似ファイルシステムです。
普通の取り扱いをする必要のないものです。
すべてをきれいにした後であれば、情報収集用のプロセスを安全に終了させることができます。</p>

                            <!-- tags -->
                            
                            <span class="glyphicon glyphicon-tags" style="padding-right: 10px"></span><span
                                style="vertical-align: 2px"><a
                                    href="https://docs.docker.com/search/?q=docker">docker</a>, <a
                                    href="https://docs.docker.com/search/?q=metrics">metrics</a>, <a
                                    href="https://docs.docker.com/search/?q=CPU">CPU</a>, <a
                                    href="https://docs.docker.com/search/?q=memory">memory</a>, <a
                                    href="https://docs.docker.com/search/?q=disk">disk</a>, <a
                                    href="https://docs.docker.com/search/?q=IO">IO</a>, <a
                                    href="https://docs.docker.com/search/?q=run">run</a>, <a
                                    href="https://docs.docker.com/search/?q=runtime">runtime</a>, <a
                                    href="https://docs.docker.com/search/?q=stats">stats</a></span>
                            
                            
                            <div id="ratings-div"
                                style="color:#b9c2cc; text-align: center; margin-top: 150px;">
                                <div id="pd_rating_holder_8453675"></div>
                                <script type="text/javascript">
                                    PDRTJS_settings_8453675 = {
                                        "id": "8453675",
                                        "unique_id": "config/containers/runmetrics.md",
                                        "title": "ランタイムメトリックス",
                                        "permalink": "https://github.com/docker/docker.github.io/blob/master/config/containers/runmetrics.md"
                                    };
                                    (function (d, c, j) {
                                        if (!document.getElementById(j)) {
                                            var pd = d.createElement(c),
                                                s;
                                            pd.id = j;
                                            pd.src = ('https:' == document.location.protocol) ? 'https://polldaddy.com/js/rating/rating.js' : 'http://i0.poll.fm/js/rating/rating.js';
                                            s = document.getElementsByTagName(c)[0];
                                            s.parentNode.insertBefore(pd, s);
                                        }
                                    }(document, 'script', 'pd-rating-js'));
                                </script>
                            </div>
                            
                        </section>
                    </main>
                    <nav class="col-nav">
                        <div id="sidebar-nav" class="sidebar hidden-sm hidden-xs">
                            <div id="navbar" class="nav-sidebar">
    <ul class="nav jsTOCHorizontal hidden-md hidden-lg">
    </ul>
    <div class="divider hidden-md hidden-lg"></div>
    <ul class="nav" id="jsTOCLeftNav">
    </ul>
</div>

                        </div>
                    </nav>
                    <div class="col-toc">
                        <div class="sidebar hidden-xs hidden-sm">
                            <div class="toc-nav">
                                <div class="feedback-links">
                                    <ul>
                                        
                                        <li><a href="https://github.com/matsuand/docs.docker.jp/edit/v19.03.local/config/containers/runmetrics.md"><i
                                                    class="fa fa-pencil-square-o" aria-hidden="true"></i> このページの編集</a></li>
                                        <li><a href="https://github.com/matsuand/docs.docker.jp/issues/new?body=ファイル: [config/containers/runmetrics.md](https://matsuand.github.io/docs.docker.jp.onthefly/config/containers/runmetrics/)"
                                                class="nomunge"><i class="fa fa-check" aria-hidden="true"></i> 文書変更のリクエスト</a></li>
                                        <!-- toggle mode -->
                                        <li>
                                            <div class="toggle-mode">
                                                <div class="icon">
                                                    <i class="fa fa-sun-o" aria-hidden="true"></i>
                                                </div>
                                                <div class="toggle-switch">
                                                    <label class="switch">
                                                        <input type="checkbox" id="switch-style">
                                                        <div class="slider round"></div>
                                                    </label>
                                                </div>
                                                <div class="icon">
                                                    <i class="fa fa-moon-o" aria-hidden="true"></i>
                                                </div>
                                            </div>
                                        </li>
                                    </ul>
                                </div>
                                
                                
                                
                                
                                <div id="side-toc-title">本ページ内:</div>
                                
<ul id="my_toc" class="inline_toc">
  <li><a href="#docker-stats" class="nomunge">docker stats</a></li>
  <li><a href="#control-groups" class="nomunge">コントロールグループ</a>
    <ul>
      <li><a href="#enumerate-cgroups" class="nomunge">cgroups の確認</a></li>
      <li><a href="#find-the-cgroup-for-a-given-container" class="nomunge">特定コンテナーに対応する cgroup の検索</a></li>
      <li><a href="#metrics-from-cgroups-memory-cpu-block-io" class="nomunge">cgroups の各メトリックス、メモリ、CPU、ブロック I/O</a></li>
      <li><a href="#cpu-metrics-cpuacctstat" class="nomunge">CPU メトリックス: cpuacct.stat</a></li>
      <li><a href="#network-metrics" class="nomunge">ネットワークメトリックス</a></li>
    </ul>
  </li>
  <li><a href="#tips-for-high-performance-metric-collection" class="nomunge">詳細なメトリックスを収集するためのヒント</a></li>
  <li><a href="#collect-metrics-when-a-container-exits" class="nomunge">コンテナー起動時のメトリックス収集</a></li>
</ul>


                                
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    
    <footer class="footer">
          
    <div class="container">
        <div class="top_footer">
            <div class="row">
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/why-docker">Why Docker?</a></b></li>
                        <li><a href="https://www.docker.com/what-container">What is a Container?</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/overview">Products</a></b></li>
                        <li><a href="https://www.docker.com/products/docker-desktop">Docker Desktop</a></li>
                        <li><a href="https://www.docker.com/products/docker-hub">Docker Hub</a></li>
                        <li><b><a href="https://www.docker.com/products/docker-desktop">Features</a></b></li>
                        <li><a href="https://www.docker.com/products/container-runtime">Container Runtime</a></li>
                        <li><a href="https://www.docker.com/products/developer-tools">Developer Tools</a></li>
                        <li><a href="https://www.docker.com/products/kubernetes">Kubernetes</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop">Developers</a></b></li>
                        <li><a href="https://www.docker.com/use-cases">Use Cases</a></li>
                        <li><a href="https://www.docker.com/play-with-docker">Play with Docker</a></li>
                        <li><a href="https://www.docker.com/docker-community">Community</a></li>
                        <li><a href="https://www.docker.com/open-source">Open Source</a></li>
                        <li><a href="https://www.docker.com/community/docker-captains">Docker Captains</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/company" target="_blank">Company</a></b></li>
                        <li><a href="https://www.docker.com/company">About Us</a></li>
                        <li><a href="https://www.docker.com/blog/" target="_blank">Blog</a></li>
                        <li><a href="https://www.docker.com/customers">Customers</a></li>
                        <li><a href="https://www.docker.com/partners">Partners</a></li>
                        <li><a href="https://www.docker.com/company/newsroom">Newsroom</a></li>
                        <li><a href="https://www.docker.com/careers">Careers</a></li>
                        <li><a href="https://www.docker.com/company/contact">Contact Us</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-nav">
                <nav class="footer_sub_nav">
                    <ul class="menu">
                        <li><a href="http://status.docker.com/">Status</a></li>
                        <li><a href="https://www.docker.com/docker-security">Security</a></li>
                        <li><a href="https://www.docker.com/legal">Legal</a></li>
                        <li><a href="https://www.docker.com/company/contact">Contact</a></li>
                    </ul>
                </nav>
            </div>
        </div>
        <div class="bottom_footer">
            <div class="footer-copyright col-xs-12 col-md-8">
                <p class="copyright">
                    Copyright &copy; 2013-2020 Docker Inc. All rights reserved. </p>
            </div>
            <div class="footer_social_nav">
                <ul class="nav-social">
                    <li class="fa fa-twitter"><a href="http://twitter.com/docker">Twitter</a></li>
                    <li class="fa fa-youtube"><a href="http://www.youtube.com/user/dockerrun">Youtube</a></li>
                    <li class="fa fa-github"><a href="https://github.com/docker">GitHub</a></li>
                    <li class="fa fa-linkedin"><a href="https://www.linkedin.com/company/docker">Linkedin</a></li>
                    <li class="fa fa-facebook"><a href="https://www.facebook.com/docker.run">Facebook</a></li>
                    <li class="fa fa-slideshare"><a href="https://www.slideshare.net/docker">Slideshare</a></li>
                    <li class="fa fa-reddit"><a href="https://www.reddit.com/r/docker">Reddit</a></li>
                </ul>
            </div>
        </div>
    </div>

    </footer>
    <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/github.css">
    
    <script>var pageURL = "/config/containers/runmetrics/";</script>
    <script defer src="/docs.docker.jp.onthefly/js/anchorlinks.js"></script>
    <script defer src="/docs.docker.jp.onthefly/js/menu.js"></script>
    <script src="/docs.docker.jp.onthefly/js/jquery.js"></script>
    <script src="/docs.docker.jp.onthefly/js/bootstrap.min.js"></script>
    <script src="/docs.docker.jp.onthefly/js/stickyfill.min.js"></script>
    <script defer src="/docs.docker.jp.onthefly/js/metadata.js"></script>
    <script src="/docs.docker.jp.onthefly/js/glossary.js"></script>
    <script defer src="/docs.docker.jp.onthefly/js/docs.js"></script>
    <script defer src="/docs.docker.jp.onthefly/js/toc.js"></script>
    <script defer src="/js/search.js"></script>
</body>


</html>
