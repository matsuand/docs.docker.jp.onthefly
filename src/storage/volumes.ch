%This is the change file for the original Docker's Documentation file.
%This is part of Japanese translation version for Docker's Documantation.

@x
---
description: Using volumes
title: Use volumes
keywords: storage, persistence, data persistence, volumes
redirect_from:
- /userguide/dockervolumes/
- /engine/tutorials/dockervolumes/
- /engine/userguide/dockervolumes/
- /engine/admin/volumes/volumes/
---
@y
---
description: ボリュームを利用します。
title: ボリュームの利用
keywords: storage, persistence, data persistence, volumes
redirect_from:
- /userguide/dockervolumes/
- /engine/tutorials/dockervolumes/
- /engine/userguide/dockervolumes/
- /engine/admin/volumes/volumes/
---
@z

@x
Volumes are the preferred mechanism for persisting data generated by and used
by Docker containers. While [bind mounts](bind-mounts.md) are dependent on the
directory structure and OS of the host machine, volumes are completely managed by
Docker. Volumes have several advantages over bind mounts:
@y
ボリュームとは、Docker コンテナーにおいて生成され利用されるデータを、永続的に保持する目的で利用される仕組みです。
[バインドマウント](bind-mounts.md) はホストマシン OS のディレクトリ構造に依存しますが、ボリュームは完全に Docker によって管理されます。
ボリュームにはバインドマウントに比べて、以下のように優れた点があります。
@z

@x
- Volumes are easier to back up or migrate than bind mounts.
- You can manage volumes using Docker CLI commands or the Docker API.
- Volumes work on both Linux and Windows containers.
- Volumes can be more safely shared among multiple containers.
- Volume drivers let you store volumes on remote hosts or cloud providers, to
  encrypt the contents of volumes, or to add other functionality.
- New volumes can have their content pre-populated by a container.
- Volumes on Docker Desktop have much higher performance than bind mounts from
  Mac and Windows hosts.
@y
- ボリュームはバインドマウントよりも、バックアップや移行が容易です。
- ボリュームは Docker CLI コマンドや Docker API を利用して管理することができます。
- ボリュームは Linux と Windows 上のコンテナーにおいて動作します。
- ボリュームは複数コンテナー間にて安全に共有できます。
- ボリュームドライバーを用いると、リモートホスト上、あるいはクラウドプロバイダー上のボリュームに保存できるようになります。保存の際にはボリューム内データを暗号化することができ、その他にも種々の機能を利用することができます。
- ボリュームを新たに生成すると、その内容はコンテナーがあらかじめ用意していた内容になります。
- Docker Desktop 上のボリュームは、Mac や Windows ホストからのバインドマウントに比べて、より高い性能を実現します。
@z

@x
In addition, volumes are often a better choice than persisting data in a
container's writable layer, because a volume does not increase the size of the
containers using it, and the volume's contents exist outside the lifecycle of a
given container.
@y
さらに永続的にデータを保持するならば、コンテナーの書き込みレイヤーを用いるのではなく、ボリュームを用いることの方が適切となる場合が多々あります。
というのもボリュームであれば、これを利用するコンテナーのサイズを増加させることはありません。
ボリューム内のデータは、コンテナーのライフサイクルから離れたところに存在しているからです。
@z

@x
![volumes on the Docker host](images/types-of-mounts-volume.png)
@y
![Docker ホスト上のボリューム](images/types-of-mounts-volume.png)
@z

@x
If your container generates non-persistent state data, consider using a
[tmpfs mount](tmpfs.md) to avoid storing the data anywhere permanently, and to
increase the container's performance by avoiding writing into the container's
writable layer.
@y
コンテナーが一時的な状態を保持するデータを生成しているなら、[tmpfs マウント](tmpfs.md) を使うことで、そのデータが永続的に保存されないようにすることを考えてください。
あるいは [tmpfs マウント](tmpfs.md) を使うことで、コンテナーの書き込みレイヤーに出力されることも防ぐことができるので、コンテナーの性能を向上させることもできます。
@z

@x
Volumes use `rprivate` bind propagation, and bind propagation is not
configurable for volumes.
@y
ボリュームはバインドプロパゲーションの 1 つである`rprivate`を利用します。
ただしボリュームにおいてバインドプロパゲーションを設定することはできません。
@z

@x
## Choose the -v or --mount flag
@y
{: #choose-the--v-or---mount-flag }
## -v または --mount フラグの選択
@z

@x
In general, `--mount` is more explicit and verbose. The biggest difference is that
the `-v` syntax combines all the options together in one field, while the `--mount`
syntax separates them. Here is a comparison of the syntax for each flag.
@y
全般に`--mount`の方がわかりやすいものですが、記述は増えます。
両者の最大の違いは、`-v`の文法がオプション指定のすべてを 1 項目にとりまとめるものであるのに対して、`--mount`の文法はそれを 1 つずつ個別に分けている点です。
以下に両フラグにおける文法を比較します。
@z

@x
If you need to specify volume driver options, you must use `--mount`.
@y
ボリュームドライバーのオプションを指定する必要がある場合は、`--mount`を用いなければなりません。
@z

@x
- **`-v` or `--volume`**: Consists of three fields, separated by colon characters
  (`:`). The fields must be in the correct order, and the meaning of each field
  is not immediately obvious.
  - In the case of named volumes, the first field is the name of the volume, and is
    unique on a given host machine. For anonymous volumes, the first field is
    omitted.
  - The second field is the path where the file or directory are mounted in
    the container.
  - The third field is optional, and is a comma-separated list of options, such
    as `ro`. These options are discussed below.
@y
- **`-v`または`--volume`**: 3 つの項目から構成され、それぞれをコロン（`:`）で区切ります。
  各項目は正しい順に記述する必要があります。
  各項目の意味は、そのときどきによって変わります。
  - 名前つきボリュームの場合、1 つめの項目は、そのボリューム名です。
    指定されるホストマシン上において固有の名称であるものです。
    匿名ボリュームの場合、1 つめの項目は省略されます。
  - 2 つめは、コンテナー内にマウントされるファイルまたディレクトリのパスです。
  - 3 つめは任意の指定項目であり、オプション指定をカンマ区切りで指定します。
    指定内容には`ro`などがあります。
    このオプションに関しては後に説明しています。
@z

@x
- **`--mount`**: Consists of multiple key-value pairs, separated by commas and each
  consisting of a `<key>=<value>` tuple. The `--mount` syntax is more verbose
  than `-v` or `--volume`, but the order of the keys is not significant, and
  the value of the flag is easier to understand.
  - The `type` of the mount, which can be [`bind`](bind-mounts.md), `volume`, or
    [`tmpfs`](tmpfs.md). This topic discusses volumes, so the type is always
    `volume`.
  - The `source` of the mount. For named volumes, this is the name of the volume.
    For anonymous volumes, this field is omitted. May be specified as `source`
    or `src`.
  - The `destination` takes as its value the path where the file or directory
    is mounted in the container. May be specified as `destination`, `dst`,
    or `target`.
  - The `readonly` option, if present, causes the bind mount to be [mounted into
    the container as read-only](#use-a-read-only-volume). May be specified as `readonly` or `ro`.
  - The `volume-opt` option, which can be specified more than once, takes a
    key-value pair consisting of the option name and its value.
@y
- **`--mount`**: 複数のキーバリューペアを指定し、各ペアはカンマにより区切ります。
  そしてそれぞれのペアは`<key>=<value>`という記述を行います。
  `--mount`における記述は`-v`や`--volume`におけるものよりも長くなります。
  しかしキーの並び順に意味はなく、このフラグに与えられたキーバリューの内容は容易に理解することができます。
  - `type`はマウントのタイプであり、[`bind`](bind-mounts.md), `volume`, [`tmpfs`](tmpfs.md) といった値を指定します。
    ここで説明しているのはボリュームであるため、常に`volume`であるものとします。
  - `source`はマウント元です。
    名前つきボリュームの場合は、そのボリューム名です。
    匿名ボリュームの場合、この項目は省略します。
    `source`あるいは`src`といった指定がよく用いられます。
  - `destination`には、コンテナー上にてマウントするファイルまたはディレクトリのパスを指定します。
    `destination`、`dst`、`target`といった指定がよく用いられます。
  - オプション`readonly`が指定されると、そのボリュームが [コンテナーにおける読み込み専用マウント](#use-a-read-only-volume) としてマウントされます。
    これは`readonly`または`ro`として指定が可能です。
  - `volume-opt`オプションは複数の指定が可能です。
    オプション名とその値からなるキーバリューペアを指定します。
@z

@x
> Escape values from outer CSV parser
>
> If your volume driver accepts a comma-separated list as an option,
> you must escape the value from the outer CSV parser. To escape a `volume-opt`,
> surround it with double quotes (`"`) and surround the entire mount parameter
> with single quotes (`'`).
>
> For example, the `local` driver accepts mount options as a comma-separated
> list in the `o` parameter. This example shows the correct way to escape the list.
>
>     $ docker service create \
>         --mount 'type=volume,src=<VOLUME-NAME>,dst=<CONTAINER-PATH>,volume-driver=local,volume-opt=type=nfs,volume-opt=device=<nfs-server>:<nfs-path>,"volume-opt=o=addr=<nfs-address>,vers=4,soft,timeo=180,bg,tcp,rw"'
>         --name myservice \
>         <IMAGE>
> {: .warning}
@y
> 上位レベルの CSV 解析をエスケープする
>
> 利用するボリュームドライバーが、オプションとしてカンマ区切りリストを受け取る場合、そのリストが上位レベルの CSV として解析されないようにエスケープすることが必要になります。
> `volume-opt`をエスケープするには、そのオプションをダブルクォート（`"`）で囲み、かつマウントパラメーター全体の文字列をシングルクォート（`'`）で囲みます。
>
> たとえば`local`ドライバーは`o`パラメーターにおいて、マウントオプションにカンマ区切りリストを受けつけます。
> ここに示す例は、そのリストを正しくエスケープする方法を示しています。
>
>     $ docker service create \
>          --mount 'type=volume,src=<VOLUME-NAME>,dst=<CONTAINER-PATH>,volume-driver=local,volume-opt=type=nfs,volume-opt=device=<nfs-server>:<nfs-path>,"volume-opt=o=addr=<nfs-address>,vers=4,soft,timeo=180,bg,tcp,rw"'
>         --name myservice \
>         <IMAGE>
> {: .warning}
@z

@x
The examples below show both the `--mount` and `-v` syntax where possible, and
    `--mount` is presented first.
@y
これ以降においては、可能なら`--mount`と`-v`の両方の例を示していきます。
先に示すのは`--mount`とします。
@z

@x
### Differences between `-v` and `--mount` behavior
@y
{: #differences-between--v-and---mount-behavior }
### `-v`と`--mount`の動作の違い
@z

@x
As opposed to bind mounts, all options for volumes are available for both
`--mount` and `-v` flags.
@y
バインドマウントの場合とは違い、ボリュームのオプションは、`--mount`と`-v`フラグの両方においてすべて利用できます。
@z

@x
When using volumes with services, only `--mount` is supported.
@y
サービスにおいてボリュームを利用する場合は`--mount`のみがサポートされます。
@z

@x
## Create and manage volumes
@y
{: #create-and-manage-volumes }
## ボリュームの生成と管理
@z

@x
Unlike a bind mount, you can create and manage volumes outside the scope of any
container.
@y
バインドマウントとは異なり、ボリュームの生成と管理はコンテナーの外部から行います。
@z

@x
**Create a volume**:
@y
**ボリュームの生成**
@z

@x
```console
$ docker volume create my-vol
```
@y
```console
$ docker volume create my-vol
```
@z

@x
**List volumes**:
@y
**ボリュームの一覧表示**
@z

@x
```console
$ docker volume ls
@y
```console
$ docker volume ls
@z

@x
local               my-vol
```
@y
local               my-vol
```
@z

@x
**Inspect a volume**:
@y
**ボリュームの確認**
@z

@x
```console
$ docker volume inspect my-vol
[
    {
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
        "Name": "my-vol",
        "Options": {},
        "Scope": "local"
    }
]
```
@y
```console
$ docker volume inspect my-vol
[
    {
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
        "Name": "my-vol",
        "Options": {},
        "Scope": "local"
    }
]
```
@z

@x
**Remove a volume**:
@y
**ボリュームの削除**
@z

@x
```console
$ docker volume rm my-vol
```
@y
```console
$ docker volume rm my-vol
```
@z

@x
## Start a container with a volume
@y
{: #start-a-container-with-a-volume }
## ボリュームを使ったコンテナーの起動
@z

@x
If you start a container with a volume that does not yet exist, Docker creates
the volume for you. The following example mounts the volume `myvol2` into
`/app/` in the container.
@y
ボリュームがまだ存在していない状態で、そのボリュームを使ったコンテナーを起動すると、Docker はその際にボリュームを生成します。
以下の例はボリューム`myvol2`をコンテナー内の`/app/`にマウントするものです。
@z

@x
The `-v` and `--mount` examples below produce the same result. You can't run
them both unless you remove the `devtest` container and the `myvol2` volume
after running the first one.
@y
`--mount`と`-v`によるそれぞれの例は、同一の結果になります。
ただし 2 つの例を同時に実行することはできません。
実行するためには、実行前に`devtest`コンテナーと`myvol2`ボリュームを削除しておくことが必要になります。
@z

@x
<ul class="nav nav-tabs">
  <li class="active"><a data-toggle="tab" data-group="mount" data-target="#mount-run"><code>--mount</code></a></li>
  <li><a data-toggle="tab" data-group="volume" data-target="#v-run"><code>-v</code></a></li>
</ul>
<div class="tab-content">
<div id="mount-run" class="tab-pane fade in active" markdown="1">
@y
<ul class="nav nav-tabs">
  <li class="active"><a data-toggle="tab" data-group="mount" data-target="#mount-run"><code>--mount</code></a></li>
  <li><a data-toggle="tab" data-group="volume" data-target="#v-run"><code>-v</code></a></li>
</ul>
<div class="tab-content">
<div id="mount-run" class="tab-pane fade in active" markdown="1">
@z

@x
```console
$ docker run -d \
  --name devtest \
  --mount source=myvol2,target=/app \
  nginx:latest
```
@y
```console
$ docker run -d \
  --name devtest \
  --mount source=myvol2,target=/app \
  nginx:latest
```
@z

@x
</div><!--mount-->
<div id="v-run" class="tab-pane fade" markdown="1">
@y
</div><!--mount-->
<div id="v-run" class="tab-pane fade" markdown="1">
@z

@x
```console
$ docker run -d \
  --name devtest \
  -v myvol2:/app \
  nginx:latest
```
@y
```console
$ docker run -d \
  --name devtest \
  -v myvol2:/app \
  nginx:latest
```
@z

@x
</div><!--volume-->
</div><!--tab-content-->
@y
</div><!--volume-->
</div><!--tab-content-->
@z

@x
Use `docker inspect devtest` to verify that the volume was created and mounted
correctly. Look for the `Mounts` section:
@y
ボリュームが正しく生成されたかどうかを`docker inspect devtest`により確認します。
出力の中で`Mounts`の項目を見てみます。
@z

@x
```json
"Mounts": [
    {
        "Type": "volume",
        "Name": "myvol2",
        "Source": "/var/lib/docker/volumes/myvol2/_data",
        "Destination": "/app",
        "Driver": "local",
        "Mode": "",
        "RW": true,
        "Propagation": ""
    }
],
```
@y
```json
"Mounts": [
    {
        "Type": "volume",
        "Name": "myvol2",
        "Source": "/var/lib/docker/volumes/myvol2/_data",
        "Destination": "/app",
        "Driver": "local",
        "Mode": "",
        "RW": true,
        "Propagation": ""
    }
],
```
@z

@x
This shows that the mount is a volume, it shows the correct source and
destination, and that the mount is read-write.
@y
この情報から、マウントはボリュームであることがわかります。
そしてマウント元、マウント先が正しいものであること、マウントが読み書き可能であることがわかります。
@z

@x
Stop the container and remove the volume. Note volume removal is a separate
step.
@y
コンテナーを停止し、ボリュームを削除します。
ボリュームの削除は別操作になります。
@z

@x
```console
$ docker container stop devtest

$ docker container rm devtest

$ docker volume rm myvol2
```
@y
```console
$ docker container stop devtest

$ docker container rm devtest

$ docker volume rm myvol2
```
@z

@x
## Use a volume with docker-compose
@y
{: #use-a-volume-with-docker-compose }
## docker-compose でのボリューム利用
@z

@x
A single docker compose service with a volume looks like this:
@y
ボリュームを利用する単一の Compose サービスは、たとえば以下のようなものです。
@z

@x
```yaml
version: "{{ site.compose_file_v3 }}"
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
```
@y
```yaml
version: "{{ site.compose_file_v3 }}"
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
```
@z

@x
On the first invocation of `docker-compose up` the volume will be created. The same
volume will be reused on following invocations.
@y
`docker-compose up`の初回実行時に、そのボリュームが生成されます。
このボリュームが、それ以降の実行時においても再利用されます。
@z

@x
A volume may be created directly outside of compose with `docker volume create` and
then referenced inside `docker-compose.yml` as follows:
@y
ボリュームは`docker volume create`の実行によって、Compose の外部に直接生成されているかもしれません。
その後は`docker-compose.yml`内から、以下のようにして参照されます。
@z

@x
```yaml
version: "{{ site.compose_file_v3 }}"
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
    external: true
```
@y
```yaml
version: "{{ site.compose_file_v3 }}"
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
    external: true
```
@z

@x
For more information about using volumes with compose see
[the compose reference](../compose/compose-file/compose-file-v3.md#volume-configuration-reference).
@y
Compose においてボリュームを利用する方法に関しては [Compose リファレンス](../compose/compose-file/compose-file-v3.md#volume-configuration-reference) を参照してください。
@z

@x
### Start a service with volumes
@y
{: #start-a-service-with-volumes }
### ボリュームを使ったサービスの起動
@z

@x
When you start a service and define a volume, each service container uses its own
local volume. None of the containers can share this data if you use the `local`
volume driver, but some volume drivers do support shared storage. Docker for AWS and
Docker for Azure both support persistent storage using the Cloudstor plugin.
@y
サービスを起動してボリュームを定義すると、各サービスそれぞれは固有のローカルボリュームを利用します。
`local`ボリュームドライバーを利用する場合は、コンテナー間でデータが共有されることはありません。
一方、ボリュームドライバーの中には、ストレージの共有をサポートするものがあります。
Docker for AWS と Docker for Azure では、Cloudstor プラグインを利用して恒常的なストレージをサポートしています。
@z

@x
The following example starts a `nginx` service with four replicas, each of which
uses a local volume called `myvol2`.
@y
以下の例は`nginx`サービスを 4 つのレプリカを使って起動し、そのレプリカの個々が`myvol2`というローカルボリュームを利用します。
@z

@x
```console
$ docker service create -d \
  --replicas=4 \
  --name devtest-service \
  --mount source=myvol2,target=/app \
  nginx:latest
```
@y
```console
$ docker service create -d \
  --replicas=4 \
  --name devtest-service \
  --mount source=myvol2,target=/app \
  nginx:latest
```
@z

@x
Use `docker service ps devtest-service` to verify that the service is running:
@y
`docker service ps devtest-service`を実行して、サービスが起動していることを確認します。
@z

@x
```console
$ docker service ps devtest-service
@y
```console
$ docker service ps devtest-service
@z

@x
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS
4d7oz1j85wwn        devtest-service.1   nginx:latest        moby                Running             Running 14 seconds ago
```
@y
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS
4d7oz1j85wwn        devtest-service.1   nginx:latest        moby                Running             Running 14 seconds ago
```
@z

@x
Remove the service, which stops all its tasks:
@y
サービスを削除します。
これによりすべてのタスクが止まります。
@z

@x
```console
$ docker service rm devtest-service
```
@y
```console
$ docker service rm devtest-service
```
@z

@x
Removing the service does not remove any volumes created by the service.
Volume removal is a separate step.
@y
サービスを削除しても、そのサービスによって生成されたボリュームは削除されません。
ボリュームの削除は別操作になります。
@z

@x
#### Syntax differences for services
@y
{: #syntax-differences-for-services }
#### サービスにおける文法の違い
@z

@x
The `docker service create` command does not support the `-v` or `--volume` flag.
When mounting a volume into a service's containers, you must use the `--mount`
flag.
@y
`docker service create`コマンドは`-v`フラグや`--volume`フラグをサポートしていません。
サービスコンテナー内にボリュームをマウントするには、`--mount`フラグを使う必要があります。
@z

@x
### Populate a volume using a container
@y
{: #populate-a-volume-using-a-container }
### コンテナーからボリュームへのデータコピー
@z

@x
If you start a container which creates a new volume, as above, and the container
has files or directories in the directory to be mounted (such as `/app/` above),
the directory's contents are copied into the volume. The container then
mounts and uses the volume, and other containers which use the volume also
have access to the pre-populated content.
@y
上で示したように起動するコンテナーが、新たなボリュームを生成するとします。
そして（上でいうと`/app`のように）マウントされるディレクトリ内に、すでにファイルやサブディレクトリが存在していた場合、このディレクトリの内容はボリュームにコピーされます。
そうしてからコンテナーは、ボリュームをマウントして利用していきます。
このボリュームを利用する別のコンテナーは、コピーを済ませた内容にアクセスすることになります。
@z

@x
To illustrate this, this example starts an `nginx` container and populates the
new volume `nginx-vol` with the contents of the container's
`/usr/share/nginx/html` directory, which is where Nginx stores its default HTML
content.
@y
この状況を示すために、以下では`nginx`コンテナーを起動して、コンテナー内の`/usr/share/nginx/html`の内容を、新たなボリューム`nginx-vol`にコピーする例を示します。
`/usr/share/nginx/html`内には、Nginx によるデフォルトの HTML ファイルが保存されています。
@z

@x
The `--mount` and `-v` examples have the same end result.
@y
`--mount`と`-v`の例は、いずれも同一の結果となります。
@z

@x
<ul class="nav nav-tabs">
  <li class="active"><a data-toggle="tab" data-group="mount" data-target="#mount-empty-run"><code>--mount</code></a></li>
  <li><a data-toggle="tab" data-group="volume" data-target="#v-empty-run"><code>-v</code></a></li>
</ul>
<div class="tab-content">
<div id="mount-empty-run" class="tab-pane fade in active" markdown="1">
@y
<ul class="nav nav-tabs">
  <li class="active"><a data-toggle="tab" data-group="mount" data-target="#mount-empty-run"><code>--mount</code></a></li>
  <li><a data-toggle="tab" data-group="volume" data-target="#v-empty-run"><code>-v</code></a></li>
</ul>
<div class="tab-content">
<div id="mount-empty-run" class="tab-pane fade in active" markdown="1">
@z

@x
```console
$ docker run -d \
  --name=nginxtest \
  --mount source=nginx-vol,destination=/usr/share/nginx/html \
  nginx:latest
```
@y
```console
$ docker run -d \
  --name=nginxtest \
  --mount source=nginx-vol,destination=/usr/share/nginx/html \
  nginx:latest
```
@z

@x
</div><!--mount-->
<div id="v-empty-run" class="tab-pane fade" markdown="1">
@y
</div><!--mount-->
<div id="v-empty-run" class="tab-pane fade" markdown="1">
@z

@x
```console
$ docker run -d \
  --name=nginxtest \
  -v nginx-vol:/usr/share/nginx/html \
  nginx:latest
```
@y
```console
$ docker run -d \
  --name=nginxtest \
  -v nginx-vol:/usr/share/nginx/html \
  nginx:latest
```
@z

@x
</div><!--volume-->
</div><!--tab-content-->
@y
</div><!--volume-->
</div><!--tab-content-->
@z

@x
After running either of these examples, run the following commands to clean up
the containers and volumes.  Note volume removal is a separate step.
@y
どちらかの例を実行した後は、以下のコマンドを実行して、コンテナーとボリュームを削除します。
ボリュームの削除は別操作になります。
@z

@x
```console
$ docker container stop nginxtest
@y
```console
$ docker container stop nginxtest
@z

@x
$ docker container rm nginxtest
@y
$ docker container rm nginxtest
@z

@x
$ docker volume rm nginx-vol
```
@y
$ docker volume rm nginx-vol
```
@z

@x
## Use a read-only volume
@y
{: #use-a-read-only-volume }
## 読み込み専用ボリュームの利用
@z

@x
For some development applications, the container needs to write into the bind
mount so that changes are propagated back to the Docker host. At other times,
the container only needs read access to the data. Remember that multiple
containers can mount the same volume, and it can be mounted read-write for some
of them and read-only for others, at the same time.
@y
開発アプリケーションによっては、コンテナーからバインドマウントへの書き込みを行って、変更内容を Docker ホストにコピーし直すことが必要になる場合があります。
単にコンテナーが、データの読み込みができさえすればよい場合もあります。
複数のコンテナーは同一のボリュームをマウントすることが可能であり、その場合、一部を読み書き可能なボリュームとしてマウントし、残りは読み込み専用のボリュームとしてマウントする、といったことが同時にできます。
@z

@x
This example modifies the one above but mounts the directory as a read-only
volume, by adding `ro` to the (empty by default) list of options, after the
mount point within the container. Where multiple options are present, separate
them by commas.
@y
上の例を修正して次の例では、ディレクトリを読み込み専用ボリュームとしてマウントします。
これを実現するには、コンテナー内のマウントポイントの指定に続けて（デフォルトでは空の）オプションリストに`ro`を加えます。
複数のオプション指定がある場合は、カンマで区切ります。
@z

@x
The `--mount` and `-v` examples have the same result.
@y
`--mount`と`-v`の例は、いずれも同一の結果となります。
@z

@x
<ul class="nav nav-tabs">
  <li class="active"><a data-toggle="tab" data-group="mount" data-target="#mount-readonly"><code>--mount</code></a></li>
  <li><a data-toggle="tab" data-group="volume" data-target="#v-readonly"><code>-v</code></a></li>
</ul>
<div class="tab-content">
<div id="mount-readonly" class="tab-pane fade in active" markdown="1">
@y
<ul class="nav nav-tabs">
  <li class="active"><a data-toggle="tab" data-group="mount" data-target="#mount-readonly"><code>--mount</code></a></li>
  <li><a data-toggle="tab" data-group="volume" data-target="#v-readonly"><code>-v</code></a></li>
</ul>
<div class="tab-content">
<div id="mount-readonly" class="tab-pane fade in active" markdown="1">
@z

@x
```console
$ docker run -d \
  --name=nginxtest \
  --mount source=nginx-vol,destination=/usr/share/nginx/html,readonly \
  nginx:latest
```
@y
```console
$ docker run -d \
  --name=nginxtest \
  --mount source=nginx-vol,destination=/usr/share/nginx/html,readonly \
  nginx:latest
```
@z

@x
</div><!--mount-->
<div id="v-readonly" class="tab-pane fade" markdown="1">
@y
</div><!--mount-->
<div id="v-readonly" class="tab-pane fade" markdown="1">
@z

@x
```console
$ docker run -d \
  --name=nginxtest \
  -v nginx-vol:/usr/share/nginx/html:ro \
  nginx:latest
```
@y
```console
$ docker run -d \
  --name=nginxtest \
  -v nginx-vol:/usr/share/nginx/html:ro \
  nginx:latest
```
@z

@x
</div><!--volume-->
</div><!--tab-content-->
@y
</div><!--volume-->
</div><!--tab-content-->
@z

@x
Use `docker inspect nginxtest` to verify that the readonly mount was created
correctly. Look for the `Mounts` section:
@y
`docker inspect nginxtest`を実行して、読み込み専用のマウントが正しく生成されていることを確認します。
確認するのは`Mounts`の項です。
@z

@x
```json
"Mounts": [
    {
        "Type": "volume",
        "Name": "nginx-vol",
        "Source": "/var/lib/docker/volumes/nginx-vol/_data",
        "Destination": "/usr/share/nginx/html",
        "Driver": "local",
        "Mode": "",
        "RW": false,
        "Propagation": ""
    }
],
```
@y
```json
"Mounts": [
    {
        "Type": "volume",
        "Name": "nginx-vol",
        "Source": "/var/lib/docker/volumes/nginx-vol/_data",
        "Destination": "/usr/share/nginx/html",
        "Driver": "local",
        "Mode": "",
        "RW": false,
        "Propagation": ""
    }
],
```
@z

@x
Stop and remove the container, and remove the volume. Volume removal is a
separate step.
@y
コンテナーを停止して削除します。
またボリュームも削除します。
ボリュームの削除は別操作になります。
@z

@x
```console
$ docker container stop nginxtest
@y
```console
$ docker container stop nginxtest
@z

@x
$ docker container rm nginxtest
@y
$ docker container rm nginxtest
@z

@x
$ docker volume rm nginx-vol
```
@y
$ docker volume rm nginx-vol
```
@z

@x
## Share data among machines
@y
{: #share-data-among-machines }
## マシン間でのデータ共有
@z

@x
When building fault-tolerant applications, you might need to configure multiple
replicas of the same service to have access to the same files.
@y
フォールトトレラントなアプリケーションを構築する場合、1 つのサービスに対するレプリカを複数生成して、それらがアクセスするファイルを同一にするような設定を行う場合があります。
@z

@x
![shared storage](images/volumes-shared-storage.svg)
@y
![共有ストレージ](images/volumes-shared-storage.svg)
@z

@x
There are several ways to achieve this when developing your applications.
One is to add logic to your application to store files on a cloud object
storage system like Amazon S3. Another is to create volumes with a driver that
supports writing files to an external storage system like NFS or Amazon S3.
@y
開発アプリケーションにおいて、これを実現する方法はいくつかあります。
1 つは、Amazon S3 のようなクラウド上のストレージシステムに、ファイルを保存するようなロジックをアプリケーションに組み入れることです。
別の方法として、NFS や Amazon S3 などの外部ストレージシステムにファイル書き込みを行うドライバーを利用して、ボリュームを生成する方法です。
@z

@x
Volume drivers allow you to abstract the underlying storage system from the
application logic. For example, if your services use a volume with an NFS
driver, you can update the services to use a different driver, as an example to
store data in the cloud, without changing the application logic.
@y
ボリュームドライバーを使うと、アプリケーションロジックが利用するストレージシステムを抽象化することができます。
たとえば NFS ドライバーを使ったボリュームを持つサービスがあったとします。
そして別のドライバーを使うようにサービスを変更したいとします。
このような場合、たとえばクラウド上にデータを保存するような変更は、アプリケーションロジックを変更することなく実現できます。
@z

@x
## Use a volume driver
@y
{: #use-a-volume-driver }
## ボリュームドライバーの利用
@z

@x
When you create a volume using `docker volume create`, or when you start a
container which uses a not-yet-created volume, you can specify a volume driver.
The following examples use the `vieux/sshfs` volume driver, first when creating
a standalone volume, and then when starting a container which creates a new
volume.
@y
`docker volume create`を実行してボリュームを生成する場合、あるいはコンテナーを起動した際にボリュームがまだ生成されていない場合に、ボリュームドライバーを指定することができます。
以下の例では`vieux/sshfs`ボリュームドライバーというものを利用しています。
はじめはスタンドアロンのボリュームを生成する場合であり、次はコンテナー起動時に新たなボリュームが生成される場合です。
@z

@x
### Initial set-up
@y
{: #initial-set-up }
### 初期設定
@z

@x
This example assumes that you have two nodes, the first of which is a Docker
host and can connect to the second using SSH.
@y
この例では 2 つのノードがあるものとします。
1 つめが Docker ホストであり、2 つめのノードに対して SSH により接続するものとします。
@z

@x
On the Docker host, install the `vieux/sshfs` plugin:
@y
Docker ホストでは`vieux/sshfs`プラグインをインストールします。
@z

@x
```console
$ docker plugin install --grant-all-permissions vieux/sshfs
```
@y
```console
$ docker plugin install --grant-all-permissions vieux/sshfs
```
@z

@x
### Create a volume using a volume driver
@y
{: #create-a-volume-using-a-volume-driver }
### ボリュームドライバーを用いたボリュームの生成
@z

@x
This example specifies a SSH password, but if the two hosts have shared keys
configured, you can omit the password. Each volume driver may have zero or more
configurable options, each of which is specified using an `-o` flag.
@y
この例では SSH パスワードを指定することにしていますが、2 つのホスト間で鍵を共有する設定しているのであれば、パスワードは省略可能です。
各ボリュームドライバーは、設定可能なオプションを持つことがあります。
オプションの指定には`-o`フラグを用います。
@z

@x
```console
$ docker volume create --driver vieux/sshfs \
  -o sshcmd=test@node2:/home/test \
  -o password=testpassword \
  sshvolume
```
@y
```console
$ docker volume create --driver vieux/sshfs \
  -o sshcmd=test@node2:/home/test \
  -o password=testpassword \
  sshvolume
```
@z

@x
### Start a container which creates a volume using a volume driver
@y
{: #start-a-container-which-creates-a-volume-using-a-volume-driver }
### ボリュームドライバーを用いた、ボリューム生成を行うコンテナーの起動
@z

@x
This example specifies a SSH password, but if the two hosts have shared keys
configured, you can omit the password. Each volume driver may have zero or more
configurable options. **If the volume driver requires you to pass options, you
must use the `--mount` flag to mount the volume, rather than `-v`.**
@y
この例では SSH パスワードを指定することにしていますが、2 つのホスト間で鍵を共有する設定しているのであれば、パスワードは省略可能です。
各ボリュームドライバーは、設定可能なオプションを持つことがあります。
**ボリュームドライバーにオプション指定が必要な場合、ボリュームマウントを行うには`-v`フラグではなく`--mount`フラグを用いなければなりません。**
@z

@x
```console
$ docker run -d \
  --name sshfs-container \
  --volume-driver vieux/sshfs \
  --mount src=sshvolume,target=/app,volume-opt=sshcmd=test@node2:/home/test,volume-opt=password=testpassword \
  nginx:latest
```
@y
```console
$ docker run -d \
  --name sshfs-container \
  --volume-driver vieux/sshfs \
  --mount src=sshvolume,target=/app,volume-opt=sshcmd=test@node2:/home/test,volume-opt=password=testpassword \
  nginx:latest
```
@z

@x
### Create a service which creates an NFS volume
@y
{: #create-a-service-which-creates-an-nfs-volume }
### NFS ボリュームを生成するサービスの起動
@z

@x
This example shows how you can create an NFS volume when creating a service. This example uses `10.0.0.10` as the NFS server and `/var/docker-nfs` as the exported directory on the NFS server. Note that the volume driver specified is `local`.
@y
この例は、サービス生成時に NFS ボリュームを生成する方法を示すものです。
ここでは NFS サーバーとして`10.0.0.10`を利用し、NFS サーバーにエクスポートするディレクトリを`/var/docker-nfs`とします。
指定するボリュームドライバーは`local`です。
@z

@x
#### NFSv3
@y
#### NFSv3
@z

@x
```console
$ docker service create -d \
  --name nfs-service \
  --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,volume-opt=o=addr=10.0.0.10' \
  nginx:latest
```
@y
```console
$ docker service create -d \
  --name nfs-service \
  --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,volume-opt=o=addr=10.0.0.10' \
  nginx:latest
```
@z

@x
#### NFSv4
@y
#### NFSv4
@z

@x
```console
$ docker service create -d \
    --name nfs-service \
    --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,"volume-opt=o=addr=10.0.0.10,rw,nfsvers=4,async"' \
    nginx:latest
```
@y
```console
$ docker service create -d \
    --name nfs-service \
    --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,"volume-opt=o=addr=10.0.0.10,rw,nfsvers=4,async"' \
    nginx:latest
```
@z

@x
### Create CIFS/Samba volumes
@y
{: #create-cifssamba-volumes }
### CIFS/Samba ボリュームの生成
@z

@x
You can mount a Samba share directly in docker without configuring a mount point on your host.
@y
Samba 共有は、ホスト上でのマウントポイントを設定することなく、直接マウントすることができます。
@z

@x
```console
$ docker volume create \
	--driver local \
	--opt type=cifs \
	--opt device=//uxxxxx.your-server.de/backup \
	--opt o=addr=uxxxxx.your-server.de,username=uxxxxxxx,password=*****,file_mode=0777,dir_mode=0777 \
	--name cif-volume
```
@y
```console
$ docker volume create \
	--driver local \
	--opt type=cifs \
	--opt device=//uxxxxx.your-server.de/backup \
	--opt o=addr=uxxxxx.your-server.de,username=uxxxxxxx,password=*****,file_mode=0777,dir_mode=0777 \
	--name cif-volume
```
@z

@x
Notice the `addr` option is required if using a hostname instead of an IP so docker can perform the hostname lookup.
@y
なお IP アドレスのかわりにホスト名を利用する場合には`addr`オプションの指定が必要です。
これにより Docker はホスト名による名前解決が可能になります。
@z

@x
## Backup, restore, or migrate data volumes
@y
{: #backup-restore-or-migrate-data-volumes }
## データボリュームのバックアップ、復元、移行
@z

@x
Volumes are useful for backups, restores, and migrations. Use the
`--volumes-from` flag to create a new container that mounts that volume.
@y
ボリュームはバックアップ、復元、移行が簡単にできます。
`--volumes-from`フラグを使うと、ボリュームをマウントする新たなコンテナーが生成されます。
@z

@x
### Back up a volume
@y
{: #back-up-a-volume }
### ボリュームのバックアップ
@z

@x
For example, create a new container named `dbstore`:
@y
たとえば`dbstore`という名のコンテナーを新規生成します。
@z

@x
```console
$ docker run -v /dbdata --name dbstore ubuntu /bin/bash
```
@y
```console
$ docker run -v /dbdata --name dbstore ubuntu /bin/bash
```
@z

@x
Then in the next command, we:
@y
次のコマンドでは以下のことを行います。
@z

@x
- Launch a new container and mount the volume from the `dbstore` container
- Mount a local host directory as `/backup`
- Pass a command that tars the contents of the `dbdata` volume to a `backup.tar` file inside our `/backup` directory.
@y
- 新規のコンテナーを起動し、`dbstore`コンテナーからボリュームをマウントします。
- ホストディレクトリを`/backup`としてマウントします。
- `/backup`ディレクトリ内に入って、`dbdata`ボリュームの内容を tar コマンドにより`backup.tar`ファイルとして生成します。
@z

@x
```console
$ docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
```
@y
```console
$ docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
```
@z

@x
When the command completes and the container stops, we are left with a backup of
our `dbdata` volume.
@y
コマンドが正常終了すると、コンテナーは停止されます。
そして`dbdata`ボリュームのバックアップを得ることができます。
@z

@x
### Restore volume from backup
@y
{: #restore-volume-from-backup }
### バックアップからのボリュームの復元
@z

@x
With the backup just created, you can restore it to the same container, or
another that you made elsewhere.
@y
上で生成したバックアップを使えば、同一コンテナー内にこれを復元することができます。
あるいはまったく別のところに作り出している別コンテナーでもかまいません。
@z

@x
For example, create a new container named `dbstore2`:
@y
たとえば`dbstore2`という名の新たなコンテナーを生成します。
@z

@x
```console
$ docker run -v /dbdata --name dbstore2 ubuntu /bin/bash
```
@y
```console
$ docker run -v /dbdata --name dbstore2 ubuntu /bin/bash
```
@z

@x
Then un-tar the backup file in the new container`s data volume:
@y
そして新たなコンテナーのデータボリューム内に、バックアップファイルを untar します。
@z

@x
```console
$ docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c "cd /dbdata && tar xvf /backup/backup.tar --strip 1"
```
@y
```console
$ docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c "cd /dbdata && tar xvf /backup/backup.tar --strip 1"
```
@z

@x
You can use the techniques above to automate backup, migration and restore
testing using your preferred tools.
@y
上で見てきた作業については、好みのツールを利用して、バックアップ、復元、移行を自動化してテストを行うようにすることができます。
@z

@x
## Remove volumes
@y
{: #remove-volumes }
## ボリュームの削除
@z

@x
A Docker data volume persists after a container is deleted. There are two types
of volumes to consider:
@y
Docker データボリュームは、コンテナーが削除された後も残り続けます。
ボリュームには 2 つのタイプがあるので考慮しておくことが必要です。
@z

@x
- **Named volumes** have a specific source from outside the container, for example `awesome:/bar`.
- **Anonymous volumes** have no specific source so when the container is deleted, instruct the Docker Engine daemon to remove them.
@y
- **名前つきボリューム** には、コンテナー外部から得られた所定の名称があります。
  たとえば`awesome:/bar`と表わされます。
- **匿名ボリューム** には名称がありません。
  したがってコンテナーが削除されたときには Docker Engine に対して、匿名ボリュームの削除を指示する必要があります。
@z

@x
### Remove anonymous volumes
@y
{: #remove-anonymous-volumes }
### 匿名ボリュームの削除
@z

@x
To automatically remove anonymous volumes, use the `--rm` option. For example,
this command creates an anonymous `/foo` volume. When the container is removed,
the Docker Engine removes the `/foo` volume but not the `awesome` volume.
@y
匿名ボリュームを自動的に削除するには`--rm`オプションを利用します。
たとえば以下のコマンドは、匿名の`/foo`というボリュームを生成します。
コンテナーが削除されると Docker Engine は`/foo`を削除します。
ただし`awesome`ボリュームは削除しません。
@z

@x
```console
$ docker run --rm -v /foo -v awesome:/bar busybox top
```
@y
```console
$ docker run --rm -v /foo -v awesome:/bar busybox top
```
@z

@x
> **Note**:
>
> If another container binds the volumes with
> `--volumes-from`, the volume definitions are _copied_ and the 
> anonymous volume also stays after the first container is removed.
@y
> **メモ**
>
> 別のコンテナーが、`--volumes-from`を使ってボリュームをマウントしている場合は、そのボリューム定義が **コピー** されます。
> そして、初めのコンテナーが削除されても、匿名ボリュームも残り続けます。
@z

@x
### Remove all volumes
@y
{: #remove-all-volumes }
### 全ボリュームの削除
@z

@x
To remove all unused volumes and free up space:
@y
未使用のボリュームを削除して容量を開放するには、以下のコマンドを実行します。
@z

@x
```console
$ docker volume prune
```
@y
```console
$ docker volume prune
```
@z

@x
## Next steps
@y
{: #next-steps }
## 次のステップ
@z

@x
- Learn about [bind mounts](bind-mounts.md).
- Learn about [tmpfs mounts](tmpfs.md).
- Learn about [storage drivers](/storage/storagedriver/).
- Learn about [third-party volume driver plugins](/engine/extend/legacy_plugins/).
@y
- [バインドマウント](bind-mounts.md) について学ぶ。
- [tmpfs マウント](tmpfs.md) について学ぶ。
- [ストレージドライバー](/storage/storagedriver/) について学ぶ。
- [サードパーティー製のボリュームドライバープラグイン](/engine/extend/legacy_plugins/) について学ぶ。
@z
