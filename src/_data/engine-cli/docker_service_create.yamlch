%This is the change file for the original Docker's Documentation file.
%This is part of Japanese translation version for Docker's Documantation.

@x
command: docker service create
short: Create a new service
@y
command: docker service create
short: 新たなサービスを生成します。
@z

@x
long: |-
  Creates a service as described by the specified parameters.
@y
long: |-
  指定されたパラメーターに従ってサービスを生成します。
@z

@x
  > **Note**
  >
  > This is a cluster management command, and must be executed on a swarm
  > manager node. To learn about managers and workers, refer to the
  > [Swarm mode section](https://docs.docker.com/engine/swarm/) in the
  > documentation.
@y
  > **メモ**
  >
  > これはクラスター管理コマンドです。
  > したがって Swarm 上のマネージャーノードにおいて実行する必要があります。
  > マネージャーノードやワーカーノードについては、[Swarm モード](__HOSTURL__/engine/swarm/) を参照してください。
@z

@x
usage: docker service create [OPTIONS] IMAGE [COMMAND] [ARG...]
pname: docker service
plink: docker_service.yaml
options:
@y
usage: docker service create [オプション] IMAGE [COMMAND] [ARG...]
pname: docker service
plink: docker_service.yaml
options:
@z

@x
- option: cap-add
  value_type: list
  description: Add Linux capabilities
  deprecated: false
  min_api_version: "1.41"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: cap-add
  value_type: list
  description: Linux ケーパビリティーを追加します。
  deprecated: false
  min_api_version: "1.41"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: cap-drop
  value_type: list
  description: Drop Linux capabilities
  deprecated: false
  min_api_version: "1.41"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: cap-drop
  value_type: list
  description: Linux ケーパビリティーを削除します。
  deprecated: false
  min_api_version: "1.41"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: config
  value_type: config
  description: Specify configurations to expose to the service
  deprecated: false
  min_api_version: "1.30"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: config
  value_type: config
  description: サービスに対して適用する設定を指定します。
  deprecated: false
  min_api_version: "1.30"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: constraint
  value_type: list
  description: Placement constraints
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: constraint
  value_type: list
  description: 制約（constraint）を指定します。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: container-label
  value_type: list
  description: Container labels
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: container-label
  value_type: list
  description: コンテナーラベルを指定します。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: credential-spec
  value_type: credential-spec
  description: Credential spec for managed service account (Windows only)
  deprecated: false
  min_api_version: "1.29"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: credential-spec
  value_type: credential-spec
  description: 管理サービスアカウントに対する資格情報スペック（Credential spec）。（Windows のみ）
  deprecated: false
  min_api_version: "1.29"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: detach
  shorthand: d
  value_type: bool
  default_value: "false"
  description: |
    Exit immediately instead of waiting for the service to converge
  deprecated: false
  min_api_version: "1.29"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: detach
  shorthand: d
  value_type: bool
  default_value: "false"
  description: |
    サービスの終了を待たずに即座に戻ります。
  deprecated: false
  min_api_version: "1.29"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: dns
  value_type: list
  description: Set custom DNS servers
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: dns
  value_type: list
  description: カスタム DNS サーバーを設定します。
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: dns-option
  value_type: list
  description: Set DNS options
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: dns-option
  value_type: list
  description: DNS オプションを設定します。
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: dns-search
  value_type: list
  description: Set custom DNS search domains
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: dns-search
  value_type: list
  description: カスタム DNS 検索ドメインを設定します。
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: endpoint-mode
  value_type: string
  default_value: vip
  description: Endpoint mode (vip or dnsrr)
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: endpoint-mode
  value_type: string
  default_value: vip
  description: Endpoint モードを設定します。(vip または dnsrr)
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: entrypoint
  value_type: command
  description: Overwrite the default ENTRYPOINT of the image
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: entrypoint
  value_type: command
  description: イメージのデフォルト ENTRYPOINT をオーバーライドします。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: env
  shorthand: e
  value_type: list
  description: Set environment variables
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: env
  shorthand: e
  value_type: list
  description: 環境変数を設定します。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: env-file
  value_type: list
  description: Read in a file of environment variables
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: env-file
  value_type: list
  description: 環境変数ファイルを読み込みます。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: generic-resource
  value_type: list
  description: User defined resources
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: generic-resource
  value_type: list
  description: ユーザー定義リソースを設定します。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: group
  value_type: list
  description: Set one or more supplementary user groups for the container
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: group
  value_type: list
  description: コンテナーに対して必要な補助ユーザーグループを設定します。
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: health-cmd
  value_type: string
  description: Command to run to check health
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: health-cmd
  value_type: string
  description: ヘルスチェックを実行するコマンド。
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: health-interval
  value_type: duration
  description: Time between running the check (ms|s|m|h)
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: health-interval
  value_type: duration
  description: ヘルスチェックの実行間隔。(ms|s|m|h)
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: health-retries
  value_type: int
  default_value: "0"
  description: Consecutive failures needed to report unhealthy
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: health-retries
  value_type: int
  default_value: "0"
  description: 不健康（unhealthy）であると報告するのに必要な連続失敗回数。
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: health-start-period
  value_type: duration
  description: |
    Start period for the container to initialize before counting retries towards unstable (ms|s|m|h)
  deprecated: false
  min_api_version: "1.29"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: health-start-period
  value_type: duration
  description: |
    ヘルスチェックのリトライを数え始める前の、コンテナー初期化を行う開始時間。(ms|s|m|h)
  deprecated: false
  min_api_version: "1.29"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: health-timeout
  value_type: duration
  description: Maximum time to allow one check to run (ms|s|m|h)
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: health-timeout
  value_type: duration
  description: 1 つのチェック処理実行に許容する最大時間。(ms|s|m|h) （デフォルトは 0s）
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: host
  value_type: list
  description: Set one or more custom host-to-IP mappings (host:ip)
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: host
  value_type: list
  description: 1 つまたは複数のカスタムホスト－IP 間マッピングを設定します。(host:ip)
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: hostname
  value_type: string
  description: Container hostname
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: hostname
  value_type: string
  description: コンテナーホスト名。
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: init
  value_type: bool
  default_value: "false"
  description: |
    Use an init inside each service container to forward signals and reap processes
  deprecated: false
  min_api_version: "1.37"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: init
  value_type: bool
  default_value: "false"
  description: |
    各サービスコンテナー内部にて、シグナル送信と子プロセス管理を行う初期化処理を実行します。
  deprecated: false
  min_api_version: "1.37"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: isolation
  value_type: string
  description: Service container isolation mode
  deprecated: false
  min_api_version: "1.35"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: isolation
  value_type: string
  description: サービスの分離技術（isolation technology）モード。
  deprecated: false
  min_api_version: "1.35"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: label
  shorthand: l
  value_type: list
  description: Service labels
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: label
  shorthand: l
  value_type: list
  description: サービスラベル。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: limit-cpu
  value_type: decimal
  description: Limit CPUs
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: limit-cpu
  value_type: decimal
  description: CPU 数を制限します。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: limit-memory
  value_type: bytes
  default_value: "0"
  description: Limit Memory
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: limit-memory
  value_type: bytes
  default_value: "0"
  description: メモリ容量を制限します。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: limit-pids
  value_type: int64
  default_value: "0"
  description: Limit maximum number of processes (default 0 = unlimited)
  deprecated: false
  min_api_version: "1.41"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: true
@y
- option: limit-pids
  value_type: int64
  default_value: "0"
  description: プロセスの最大数を制限します（デフォルトは 0 ＝ 無制限）。
  deprecated: false
  min_api_version: "1.41"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: true
@z

@x
- option: log-driver
  value_type: string
  description: Logging driver for service
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: log-driver
  value_type: string
  description: サービスにおけるログドライバー。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: log-opt
  value_type: list
  description: Logging driver options
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: log-opt
  value_type: list
  description: ログドライバーオプション。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: max-concurrent
  value_type: uint
  description: |
    Number of job tasks to run concurrently (default equal to --replicas)
  deprecated: false
  min_api_version: "1.41"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: max-concurrent
  value_type: uint
  description: |
    同時に実行するジョブタスク数（デフォルトは --replicas に等しい）。
  deprecated: false
  min_api_version: "1.41"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: mode
  value_type: string
  default_value: replicated
  description: |
    Service mode (replicated, global, replicated-job, or global-job)
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: mode
  value_type: string
  default_value: replicated
  description: |
    サービスモード（replicated、global、replicated-job、global-job）。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: mount
  value_type: mount
  description: Attach a filesystem mount to the service
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: mount
  value_type: mount
  description: ファイルシステムマウントをサービスにアタッチします。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: name
  value_type: string
  description: Service name
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: name
  value_type: string
  description: サービス名。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: network
  value_type: network
  description: Network attachments
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: network
  value_type: network
  description: ネットワークアタッチ。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: no-healthcheck
  value_type: bool
  default_value: "false"
  description: Disable any container-specified HEALTHCHECK
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: no-healthcheck
  value_type: bool
  default_value: "false"
  description: コンテナー固有の HEALTHCHECK を無効にします。
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: no-resolve-image
  value_type: bool
  default_value: "false"
  description: |
    Do not query the registry to resolve image digest and supported platforms
  deprecated: false
  min_api_version: "1.30"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: no-resolve-image
  value_type: bool
  default_value: "false"
  description: |
    レジストリに対してイメージダイジェスト値や対応プラットフォームを確認しません。
  deprecated: false
  min_api_version: "1.30"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: placement-pref
  value_type: pref
  description: Add a placement preference
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: placement-pref
  value_type: pref
  description: 配置設定（placement preference）を追加します。
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: publish
  shorthand: p
  value_type: port
  description: Publish a port as a node port
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: publish
  shorthand: p
  value_type: port
  description: ノードのポートとしてポートを公開します。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: quiet
  shorthand: q
  value_type: bool
  default_value: "false"
  description: Suppress progress output
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: quiet
  shorthand: q
  value_type: bool
  default_value: "false"
  description: 経過出力を省略します。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: read-only
  value_type: bool
  default_value: "false"
  description: Mount the container's root filesystem as read only
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: read-only
  value_type: bool
  default_value: "false"
  description: コンテナーのルートファイルシステムを読み取り専用としてマウントします。
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: replicas
  value_type: uint
  description: Number of tasks
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: replicas
  value_type: uint
  description: タスク数。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: replicas-max-per-node
  value_type: uint64
  default_value: "0"
  description: Maximum number of tasks per node (default 0 = unlimited)
  deprecated: false
  min_api_version: "1.40"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: replicas-max-per-node
  value_type: uint64
  default_value: "0"
  description: ノード当たりの最大タスク数。(デフォルトは 0、つまり無制限)
  deprecated: false
  min_api_version: "1.40"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: reserve-cpu
  value_type: decimal
  description: Reserve CPUs
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: reserve-cpu
  value_type: decimal
  description: CPU の予約数。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: reserve-memory
  value_type: bytes
  default_value: "0"
  description: Reserve Memory
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: reserve-memory
  value_type: bytes
  default_value: "0"
  description: メモリの予約容量。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: restart-condition
  value_type: string
  description: |
    Restart when condition is met ("none"|"on-failure"|"any") (default "any")
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: restart-condition
  value_type: string
  description: |
    条件を満たした際に再起動します。("none"|"on-failure"|"any") (デフォルトは "any")
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: restart-delay
  value_type: duration
  description: Delay between restart attempts (ns|us|ms|s|m|h) (default 5s)
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: restart-delay
  value_type: duration
  description: 再起動実施の遅延時間（ns|us|ms|s|m|h）。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: restart-max-attempts
  value_type: uint
  description: Maximum number of restarts before giving up
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: restart-max-attempts
  value_type: uint
  description: 再起動の最大リトライ回数。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: restart-window
  value_type: duration
  description: Window used to evaluate the restart policy (ns|us|ms|s|m|h)
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: restart-window
  value_type: duration
  description: 再起動ポリシーの評価に利用されるウィンドウ（ns|us|ms|s|m|h）。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: rollback-delay
  value_type: duration
  default_value: 0s
  description: Delay between task rollbacks (ns|us|ms|s|m|h) (default 0s)
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: rollback-delay
  value_type: duration
  default_value: 0s
  description: タスクロールバック時の遅延時間（ns|us|ms|s|m|h）。（デフォルトは 0s）
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: rollback-failure-action
  value_type: string
  description: |
    Action on rollback failure ("pause"|"continue") (default "pause")
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: rollback-failure-action
  value_type: string
  description: |
    ロールバック失敗時の処理（「pause」|「continue」）。（デフォルトは「pause」）
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: rollback-max-failure-ratio
  value_type: float
  default_value: "0"
  description: Failure rate to tolerate during a rollback (default 0)
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: rollback-max-failure-ratio
  value_type: float
  default_value: "0"
  description: ロールバック時に許容される失敗率（デフォルトは 0）。
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: rollback-monitor
  value_type: duration
  default_value: 0s
  description: |
    Duration after each task rollback to monitor for failure (ns|us|ms|s|m|h) (default 5s)
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: rollback-monitor
  value_type: duration
  default_value: 0s
  description: |
    各タスクのロールバックが失敗しないかを監視する時間間隔（ns|us|ms|s|m|h）。（デフォルトは 5s）
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: rollback-order
  value_type: string
  description: |
    Rollback order ("start-first"|"stop-first") (default "stop-first")
  deprecated: false
  min_api_version: "1.29"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: rollback-order
  value_type: string
  description: |
    ロールバック順。 (「start-first」|「stop-first」) (デフォルトは「stop-first」)
  deprecated: false
  min_api_version: "1.29"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: rollback-parallelism
  value_type: uint64
  default_value: "1"
  description: |
    Maximum number of tasks rolled back simultaneously (0 to roll back all at once)
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: rollback-parallelism
  value_type: uint64
  default_value: "1"
  description: |
    同時にロールバックする最大タスク数（0 は全タスク同時）。
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: secret
  value_type: secret
  description: Specify secrets to expose to the service
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: secret
  value_type: secret
  description: サービスに公開する Secret ファイル。
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: stop-grace-period
  value_type: duration
  description: |
    Time to wait before force killing a container (ns|us|ms|s|m|h) (default 10s)
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: stop-grace-period
  value_type: duration
  description: |
    強制的にコンテナーを kill する際の待機時間（ns|us|ms|s|m|h）。（デフォルトは 10s）
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: stop-signal
  value_type: string
  description: Signal to stop the container
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: stop-signal
  value_type: string
  description: コンテナーを停止するためのシグナル。
  deprecated: false
  min_api_version: "1.28"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: sysctl
  value_type: list
  description: Sysctl options
  deprecated: false
  min_api_version: "1.40"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: sysctl
  value_type: list
  description: sysctl オプション。
  deprecated: false
  min_api_version: "1.40"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: tty
  shorthand: t
  value_type: bool
  default_value: "false"
  description: Allocate a pseudo-TTY
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: tty
  shorthand: t
  value_type: bool
  default_value: "false"
  description: 擬似 TTY を割り当てます。
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: ulimit
  value_type: ulimit
  default_value: '[]'
  description: Ulimit options
  deprecated: false
  min_api_version: "1.41"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: ulimit
  value_type: ulimit
  default_value: '[]'
  description: ulimit オプション。
  deprecated: false
  min_api_version: "1.41"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: update-delay
  value_type: duration
  default_value: 0s
  description: Delay between updates (ns|us|ms|s|m|h) (default 0s)
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: update-delay
  value_type: duration
  default_value: 0s
  description: 更新間の遅延時間（ns|us|ms|s|m|h）。（デフォルトは 0s）
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: update-failure-action
  value_type: string
  description: |
    Action on update failure ("pause"|"continue"|"rollback") (default "pause")
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: update-failure-action
  value_type: string
  description: |
  description: 更新失敗時のアクション（「pause」|「continue」|「rollback」）。（デフォルトは「pause」）
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: update-max-failure-ratio
  value_type: float
  default_value: "0"
  description: Failure rate to tolerate during an update (default 0)
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: update-max-failure-ratio
  value_type: float
  default_value: "0"
  description: 更新時に許容される失敗率。（デフォルトは 0）
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: update-monitor
  value_type: duration
  default_value: 0s
  description: |
    Duration after each task update to monitor for failure (ns|us|ms|s|m|h) (default 5s)
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: update-monitor
  value_type: duration
  default_value: 0s
  description: |
    各タスクの更新が失敗しないかを監視する時間間隔（ns|us|ms|s|m|h）。（デフォルトは 5s）
  deprecated: false
  min_api_version: "1.25"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: update-order
  value_type: string
  description: |
    Update order ("start-first"|"stop-first") (default "stop-first")
  deprecated: false
  min_api_version: "1.29"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: update-order
  value_type: string
  description: |
  description: 更新順（「start-first」|「stop-first」）。（デフォルトは「stop-first」）
  deprecated: false
  min_api_version: "1.29"
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: update-parallelism
  value_type: uint64
  default_value: "1"
  description: |
    Maximum number of tasks updated simultaneously (0 to update all at once)
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: update-parallelism
  value_type: uint64
  default_value: "1"
  description: |
    同時に更新する最大タスク数（0 は全タスク同時）。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: user
  shorthand: u
  value_type: string
  description: 'Username or UID (format: <name|uid>[:<group|gid>])'
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: user
  shorthand: u
  value_type: string
  description: 'ユーザー名または UID。（記述書式: <name|uid>[:<group|gid>]）'
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: with-registry-auth
  value_type: bool
  default_value: "false"
  description: Send registry authentication details to swarm agents
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: with-registry-auth
  value_type: bool
  default_value: "false"
  description: レジストリ認証情報の詳細を Swarm エージェントに送信します。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
- option: workdir
  shorthand: w
  value_type: string
  description: Working directory inside the container
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@y
- option: workdir
  shorthand: w
  value_type: string
  description: コンテナー内部のワーキングディレクトリ。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
@z

@x
examples: |-
  ### Create a service
@y
examples: |-
  {: #create-a-service }
  ### サービスの生成
@z

@x
  ```console
  $ docker service create --name redis redis:3.0.6

  dmu1ept4cxcfe8k8lhtux3ro3

  $ docker service create --mode global --name redis2 redis:3.0.6

  a8q9dasaafudfs8q8w32udass

  $ docker service ls

  ID            NAME    MODE        REPLICAS  IMAGE
  dmu1ept4cxcf  redis   replicated  1/1       redis:3.0.6
  a8q9dasaafud  redis2  global      1/1       redis:3.0.6
  ```
@y
  ```console
  $ docker service create --name redis redis:3.0.6

  dmu1ept4cxcfe8k8lhtux3ro3

  $ docker service create --mode global --name redis2 redis:3.0.6

  a8q9dasaafudfs8q8w32udass

  $ docker service ls

  ID            NAME    MODE        REPLICAS  IMAGE
  dmu1ept4cxcf  redis   replicated  1/1       redis:3.0.6
  a8q9dasaafud  redis2  global      1/1       redis:3.0.6
  ```
@z

@x
  #### Create a service using an image on a private registry
@y
  {: #create-a-service-using-an-image-on-a-private-registry }
  #### プライベートリポジトリ上のイメージを利用したサービス生成
@z

@x
  If your image is available on a private registry which requires login, use the
  `--with-registry-auth` flag with `docker service create`, after logging in. If
  your image is stored on `registry.example.com`, which is a private registry, use
  a command like the following:
@y
  利用するイメージが、ログインを必要とするプライベートリポジトリ上にある場合は、ログインを済ませた後に、`docker service create`に`--with-registry-auth`フラグをつけて実行します。
  プライベートリポジトリ`registry.example.com`にイメージがあるとすると、以下のようなコマンドを実行します。
@z

@x
  ```console
  $ docker login registry.example.com

  $ docker service  create \
    --with-registry-auth \
    --name my_service \
    registry.example.com/acme/my_image:latest
  ```
@y
  ```console
  $ docker login registry.example.com

  $ docker service  create \
    --with-registry-auth \
    --name my_service \
    registry.example.com/acme/my_image:latest
  ```
@z

@x
  This passes the login token from your local client to the swarm nodes where the
  service is deployed, using the encrypted WAL logs. With this information, the
  nodes are able to log into the registry and pull the image.
@y
  このコマンド実行によってローカルクライアントにあるログイントークンが、サービスがデプロイされている Swarm ノードに送信されます。
  その際には暗号化された WAL ログが利用されます。
  この情報に基づいて各ノードからのレジストリへのログインが可能となり、イメージのプルが行われます。
@z

@x
  ### Create a service with 5 replica tasks (--replicas)
@y
  {: #create-a-service-with-5-replica-tasks---replicas }
  ### レプリカタスク 5 を指定したサービス生成 (--replicas)
@z

@x
  Use the `--replicas` flag to set the number of replica tasks for a replicated
  service. The following command creates a `redis` service with `5` replica tasks:
@y
  `--replicas`フラグを使って、複製化されているサービスに対してのレプリカタスク数を設定します。
  以下のコマンドはレプリカタスク数`5`の`redis`サービスを生成します。
@z

@x
  ```console
  $ docker service create --name redis --replicas=5 redis:3.0.6

  4cdgfyky7ozwh3htjfw0d12qv
  ```
@y
  ```console
  $ docker service create --name redis --replicas=5 redis:3.0.6

  4cdgfyky7ozwh3htjfw0d12qv
  ```
@z

@x
  The above command sets the *desired* number of tasks for the service. Even
  though the command returns immediately, actual scaling of the service may take
  some time. The `REPLICAS` column shows both the *actual* and *desired* number
  of replica tasks for the service.
@y
  上のコマンドでは、サービスに対して **期待する** タスク数を設定しています。
  コマンドからの応答がすぐに返ってきても、実際にサービスがスケーリングするには多少の時間を要します。
  `REPLICAS`欄には、サービスにおけるレプリカタスクの **実際の数** と **期待する数** がともに示されます。
@z

@x
  In the following example the desired state is  `5` replicas, but the current
  number of `RUNNING` tasks is `3`:
@y
  以下の例では、期待するレプリカ数が`5`と示されていますが、`RUNNING`（実行中）タスク数は`3`となっています。
@z

@x
  ```console
  $ docker service ls

  ID            NAME   MODE        REPLICAS  IMAGE
  4cdgfyky7ozw  redis  replicated  3/5       redis:3.0.7
  ```
@y
  ```console
  $ docker service ls

  ID            NAME   MODE        REPLICAS  IMAGE
  4cdgfyky7ozw  redis  replicated  3/5       redis:3.0.7
  ```
@z

@x
  Once all the tasks are created and `RUNNING`, the actual number of tasks is
  equal to the desired number:
@y
  すべてのタスクが生成され実行されると、実際のタスク数と期待されているタスク数が一致します。
@z

@x
  ```console
  $ docker service ls

  ID            NAME   MODE        REPLICAS  IMAGE
  4cdgfyky7ozw  redis  replicated  5/5       redis:3.0.7
  ```
@y
  ```console
  $ docker service ls

  ID            NAME   MODE        REPLICAS  IMAGE
  4cdgfyky7ozw  redis  replicated  5/5       redis:3.0.7
  ```
@z

@x
  ### Create a service with secrets
@y
  {: #create-a-service-with-secrets }
  ### Secret を使ったサービス生成
@z

@x
  Use the `--secret` flag to give a container access to a
  [secret](secret_create.md).
@y
  `--secret`フラグの指定により、コンテナーに対して [Secret](__HOSTURL__/engine/reference/commandline/secret_create/)（機密情報）へのアクセスを許可します。
@z

@x
  Create a service specifying a secret:
@y
  以下では Secret を指定してサービスを生成します。
@z

@x
  ```console
  $ docker service create --name redis --secret secret.json redis:3.0.6

  4cdgfyky7ozwh3htjfw0d12qv
  ```
@y
  ```console
  $ docker service create --name redis --secret secret.json redis:3.0.6

  4cdgfyky7ozwh3htjfw0d12qv
  ```
@z

@x
  Create a service specifying the secret, target, user/group ID, and mode:
@y
  以下では Secret、ターゲット、ユーザーおよびグループ ID、モードを指定してサービスを生成します。
@z

@x
  ```console
  $ docker service create --name redis \
      --secret source=ssh-key,target=ssh \
      --secret source=app-key,target=app,uid=1000,gid=1001,mode=0400 \
      redis:3.0.6

  4cdgfyky7ozwh3htjfw0d12qv
  ```
@y
  ```console
  $ docker service create --name redis \
      --secret source=ssh-key,target=ssh \
      --secret source=app-key,target=app,uid=1000,gid=1001,mode=0400 \
      redis:3.0.6

  4cdgfyky7ozwh3htjfw0d12qv
  ```
@z

@x
  To grant a service access to multiple secrets, use multiple `--secret` flags.
@y
  サービスから複数の Secret へのアクセスを許可するには、`--secret`フラグを複数指定します。
@z

@x
  Secrets are located in `/run/secrets` in the container if no target is specified.
  If no target is specified, the name of the secret is used as the in memory file
  in the container. If a target is specified, that is used as the filename. In the
  example above, two files are created: `/run/secrets/ssh` and
  `/run/secrets/app` for each of the secret targets specified.
@y
  ターゲットの指定がない場合、Secret はコンテナー内の`/run/secrets`に置かれます。
  ターゲット指定がなければ、Secret 名がコンテナー内のインメモリファイルとして用いられます。
  ターゲットが指定されれば、それがファイル名として用いられます。
  上のコマンド例においては、指定されている Secret ターゲットのそれぞれに対応して、`/run/secrets/ssh`と`/run/secrets/app`という 2 つのファイルが生成されます。
@z

@x
  ### Create a service with configs
@y
  {: #create-a-service-with-configs }
  ### Config を使ったサービス生成
@z

@x
  Use the `--config` flag to give a container access to a
  [config](config_create.md).
@y
  `--config`フラグの指定により、コンテナーに対して [Config](__HOSTURL__/engine/reference/commandline/config_create/)（設定情報）へのアクセスを許可します
@z

@x
  Create a service with a config. The config will be mounted into `redis-config`,
  be owned by the user who runs the command inside the container (often `root`),
  and have file mode `0444` or world-readable. You can specify the `uid` and `gid`
  as numerical IDs or names. When using names, the provided group/user names must
  pre-exist in the container. The `mode` is specified as a 4-number sequence such
  as `0755`.
@y
  以下では Config を使ってサービスを生成します。
  Config は`redis-config`にマウントされます。
  その所有ユーザーはコンテナー内部においてこのコマンドを実行したユーザーです（たいていは`root`です）。
  そしてファイルモードを`0444`、つまり全読み込み可とします。
  `uid`と`gid`は、数値あるいは名称での指定ができます。
  名称を利用する場合、指定するグループまたはユーザー名は、あらかじめコンテナー内において存在していなければなりません。
  `mod`は`0755`などのように、4 桁からなる数字で指定します。
@z

@x
  ```console
  $ docker service create --name=redis --config redis-conf redis:3.0.6
  ```
@y
  ```console
  $ docker service create --name=redis --config redis-conf redis:3.0.6
  ```
@z

@x
  Create a service with a config and specify the target location and file mode:
@y
  以下では Config を使ってサービスを生成し、ターゲットとファイルモードを指定します。
@z

@x
  ```console
  $ docker service create --name redis \
    --config source=redis-conf,target=/etc/redis/redis.conf,mode=0400 redis:3.0.6
  ```
@y
  ```console
  $ docker service create --name redis \
    --config source=redis-conf,target=/etc/redis/redis.conf,mode=0400 redis:3.0.6
  ```
@z

@x
  To grant a service access to multiple configs, use multiple `--config` flags.
@y
  サービスから複数の Config へのアクセスを許可するには、`--config`フラグを複数指定します。
@z

@x
  Configs are located in `/` in the container if no target is specified. If no
  target is specified, the name of the config is used as the name of the file in
  the container. If a target is specified, that is used as the filename.
@y
  ターゲットが指定されなかった場合、Config はコンテナー内の`/`に置かれます。
  ターゲット指定がない場合、Config 名がコンテナー内のファイル名として用いられます。
  ターゲット指定がある場合、それがファイル名に用いられます。
@z

@x
  ### Create a service with a rolling update policy
@y
  {: #create-a-service-with-a-rolling-update-policy }
  ### ローリングアップデートポリシーを使ったサービス生成
@z

@x
  ```console
  $ docker service create \
    --replicas 10 \
    --name redis \
    --update-delay 10s \
    --update-parallelism 2 \
    redis:3.0.6
  ```
@y
  ```console
  $ docker service create \
    --replicas 10 \
    --name redis \
    --update-delay 10s \
    --update-parallelism 2 \
    redis:3.0.6
  ```
@z

@x
  When you run a [service update](service_update.md), the scheduler updates a
  maximum of 2 tasks at a time, with `10s` between updates. For more information,
  refer to the [rolling updates
  tutorial](https://docs.docker.com/engine/swarm/swarm-tutorial/rolling-update/).
@y
  この後に [service update](__HOSTURL__/engine/reference/commandline/service_update/) を実行すると、スケジューラーは一度に最大で 2 つのタスクのアップデートを行い、`10s`間隔でアップデートを行います。
  詳しくは [ローリングアップデートのチュートリアル](__HOSTURL__/engine/swarm/swarm-tutorial/rolling-update/) を参照してください。
@z

@x
  ### Set environment variables (-e, --env)
@y
  {: #set-environment-variables--e---env }
  ### 環境変数の設定（-e、--env）
@z

@x
  This sets an environment variable for all tasks in a service. For example:
@y
  これはサービス内のタスクすべてに対して環境変数を設定します。
  たとえば以下のとおりです。
@z

@x
  ```console
  $ docker service create \
    --name redis_2 \
    --replicas 5 \
    --env MYVAR=foo \
    redis:3.0.6
  ```
@y
  ```console
  $ docker service create \
    --name redis_2 \
    --replicas 5 \
    --env MYVAR=foo \
    redis:3.0.6
  ```
@z

@x
  To specify multiple environment variables, specify multiple `--env` flags, each
  with a separate key-value pair.
@y
  サービスから複数の Config へのアクセスを許可するには、`--config`フラグを複数指定します。
  複数の環境変数を指定するには、`--env`フラグを複数用いて、個々においてキーバリューのペアを指定します。
@z

@x
  ```console
  $ docker service create \
    --name redis_2 \
    --replicas 5 \
    --env MYVAR=foo \
    --env MYVAR2=bar \
    redis:3.0.6
  ```
@y
  ```console
  $ docker service create \
    --name redis_2 \
    --replicas 5 \
    --env MYVAR=foo \
    --env MYVAR2=bar \
    redis:3.0.6
  ```
@z

@x
  ### Create a service with specific hostname (--hostname)
@y
  {: #create-a-service-with-specific-hostname---hostname }
  ### ホスト名を指定したサービス生成 (--hostname)
@z

@x
  This option sets the docker service containers hostname to a specific string.
  For example:
@y
  このオプションはサービスコンテナーのホスト名に、指定文字列を設定します。
  たとえば以下のとおりです。
@z

@x
  ```console
  $ docker service create --name redis --hostname myredis redis:3.0.6
  ```
@y
  ```console
  $ docker service create --name redis --hostname myredis redis:3.0.6
  ```
@z

@x
  ### Set metadata on a service (-l, --label)
@y
  {: #set-metadata-on-a-service--l---label }
  ### サービスへのメタデータの設定（-l、--label）
@z

@x
  A label is a `key=value` pair that applies metadata to a service. To label a
  service with two labels:
@y
  ラベルは`key=value`ペアであり、サービスに対してのメタデータとして適用されます。
  サービスに 2 つのラベルをつけるには以下のようにします。
@z

@x
  ```console
  $ docker service create \
    --name redis_2 \
    --label com.example.foo="bar"
    --label bar=baz \
    redis:3.0.6
  ```
@y
  ```console
  $ docker service create \
    --name redis_2 \
    --label com.example.foo="bar"
    --label bar=baz \
    redis:3.0.6
  ```
@z

@x
  For more information about labels, refer to [apply custom
  metadata](https://docs.docker.com/config/labels-custom-metadata/).
@y
  ラベルに関する詳細は [カスタムメタデータの適用](__HOSTURL__/config/labels-custom-metadata/) を参照してください。
@z

@x
  ### Add bind mounts, volumes or memory filesystems
@y
  {: #add-bind-mounts-volumes-or-memory-filesystems }
  ### バインドマウント、ボリューム、メモリファイルシステムの追加
@z

@x
  Docker supports three different kinds of mounts, which allow containers to read
  from or write to files or directories, either on the host operating system, or
  on memory filesystems. These types are _data volumes_ (often referred to simply
  as volumes), _bind mounts_, _tmpfs_, and _named pipes_.
@y
  Docker では三種類のマウントをサポートします。
  これを利用してコンテナーはファイルやディレクトリに対する読み書きを実現します。
  ファイルやディレクトリは、ホストオペレーティングシステム上であっても、あるいはメモリ上のファイルシステムであってもかまいません。
  その種類とは **データボリューム**（単にボリュームと呼ぶことがあります）、**バインドマウント**、**tmpfs** であり、**名前つきパイプ** もあります。
@z

@x
  A **bind mount** makes a file or directory on the host available to the
  container it is mounted within. A bind mount may be either read-only or
  read-write. For example, a container might share its host's DNS information by
  means of a bind mount of the host's `/etc/resolv.conf` or a container might
  write logs to its host's `/var/log/myContainerLogs` directory. If you use
  bind mounts and your host and containers have different notions of permissions,
  access controls, or other such details, you will run into portability issues.
@y
  **バインドマウント** は、このマウントを行ったコンテナーから、ホスト上のファイルやディレクトリを利用できるようにします。
  バインドマウントは読み込み専用か読み書き可能かを選べます。
  たとえばホスト上の`/etc/resolv.conf`をバインドマウントすれば、ホストの DNS 情報を共有することができます。
  あるいはコンテナーから、ホストの`/var/log/myContainerLogs`ディレクトリに書き込むことができます。
  バインドマウントの利用にあたって、ホストとコンテナーの間にパーミッションやアクセス制御などの詳細な部分に差異があったとすると、移植性の問題が発生する場合があります。
@z

@x
  A **named volume** is a mechanism for decoupling persistent data needed by your
  container from the image used to create the container and from the host machine.
  Named volumes are created and managed by Docker, and a named volume persists
  even when no container is currently using it. Data in named volumes can be
  shared between a container and the host machine, as well as between multiple
  containers. Docker uses a _volume driver_ to create, manage, and mount volumes.
  You can back up or restore volumes using Docker commands.
@y
  **名前つきボリューム**（named volume）は、コンテナー内において必要となる永続的なデータを、コンテナー生成に用いるイメージやホストマシンから切り離すためのメカニズムのことです。
  名前つきボリュームは Docker によって生成され管理されます。
  そこで名前つきボリュームは、コンテナーが利用されていない状態でも存続できます。
  名前つきボリューム内のデータは、コンテナーとホストマシンとの間、複数コンテナー間でも共有が可能です。
  Docker はボリュームの生成、管理、マウントを行うために **ボリュームドライバー** を利用します。
  ボリュームは Docker コマンドを使って、バックアップや復元を行うことができます。
@z

@x
  A **tmpfs** mounts a tmpfs inside a container for volatile data.
@y
  **tmpfs** マウントは、コンテナー内部において一時的なデータを利用するための tmpfs です。
@z

@x
  A **npipe** mounts a named pipe from the host into the container.
@y
  **npipe** マウントは、ホストからコンテナーに向けて名前つきパイプをマウントします。
@z

@x
  Consider a situation where your image starts a lightweight web server. You could
  use that image as a base image, copy in your website's HTML files, and package
  that into another image. Each time your website changed, you'd need to update
  the new image and redeploy all of the containers serving your website. A better
  solution is to store the website in a named volume which is attached to each of
  your web server containers when they start. To update the website, you just
  update the named volume.
@y
  たとえば、軽量なウェブサーバーを起動させるイメージがあるとします。
  これをベースイメージとして利用したり、ウェブサイトの HTML ファイルをコピーして別イメージにパッケージしたりすることも行うでしょう。
  ウェブサイト内容が変更するたびに、新たなイメージとして更新することが必要となり、ウェブサイトを提供するコンテナーすべて再デプロイする必要に迫られます。
  そんなやり方ではなく、ウェブサイト内容は名前つきボリューム内に保存するのが適切です。
  そうすればウェブサーバーを構成するコンテナーの起動時に、その名前つきボリュームを割り当てて利用することができます。
  ウェブサイトの更新時には、単に名前つきボリュームを更新するだけで済みます。
@z

@x
  For more information about named volumes, see
  [Data Volumes](https://docs.docker.com/storage/volumes/).
@y
  名前つきボリュームについての詳細は [データボリューム](__HOSTURL__/storage/volumes/) を参照してください。
@z

@x
  The following table describes options which apply to both bind mounts and named
  volumes in a service:
@y
  以下の表は、サービス内のバインドマウントまたは名前つきボリュームに適用されるオプションを説明するものです。
@z

@x
  <table>
    <tr>
      <th>Option</th>
      <th>Required</th>
      <th>Description</th>
    </tr>
@y
  <table>
    <tr>
      <th>オプション</th>
      <th>必須</th>
      <th>内容説明</th>
    </tr>
@z

@x
    <tr>
      <td><b>type</b></td>
      <td></td>
      <td>
        <p>The type of mount, can be either <tt>volume</tt>, <tt>bind</tt>, <tt>tmpfs</tt>, or <tt>npipe</tt>. Defaults to <tt>volume</tt> if no type is specified.</p>
        <ul>
          <li><tt>volume</tt>: mounts a <a href="https://docs.docker.com/engine/reference/commandline/volume_create/">managed volume</a>
          into the container.</li> <li><tt>bind</tt>:
          bind-mounts a directory or file from the host into the container.</li>
          <li><tt>tmpfs</tt>: mount a tmpfs in the container</li>
          <li><tt>npipe</tt>: mounts named pipe from the host into the container (Windows containers only).</li>
        </ul>
      </td>
    </tr>
@y
    <tr>
      <td><b>type</b></td>
      <td></td>
      <td>
        <p>マウントのタイプを示します。<tt>volume</tt>、<tt>bind</tt>、<tt>tmpfs</tt>、<tt>npipe</tt> のいずれかです。type が指定されなかった場合のデフォルトは <tt>volume</tt> です。</p>
        <ul>
          <li><tt>volume</tt> は <a href="__HOSTURL__/engine/reference/commandline/volume_create/">管理ボリューム</a>（managed volume）をコンテナーにマウントします。</li>
          <li><tt>bind</tt> は、ホスト上のディレクトリまたはファイルをコンテナーにバインドマウントします。</li>
          <li><tt>tmpfs</tt> はコンテナー内に tmpfs をマウントします。</li>
          <li><tt>npipe</tt> は、ホストからコンテナーに向けて名前つきパイプをマウントします（Windows コンテナーのみ）。</li>
        </ul>
      </td>
    </tr>
@z

@x
    <tr>
      <td><b>src</b> or <b>source</b></td>
      <td>for <tt>type=bind</tt> and <tt>type=npipe</tt></td>
      <td>
        <ul>
          <li>
           <tt>type=volume</tt>: <tt>src</tt> is an optional way to specify the name of the volume (for example, <tt>src=my-volume</tt>).
            If the named volume does not exist, it is automatically created. If no <tt>src</tt> is specified, the volume is
            assigned a random name which is guaranteed to be unique on the host, but may not be unique cluster-wide.
            A randomly-named volume has the same lifecycle as its container and is destroyed when the <i>container</i>
            is destroyed (which is upon <tt>service update</tt>, or when scaling or re-balancing the service)
          </li>
          <li>
            <tt>type=bind</tt>: <tt>src</tt> is required, and specifies an absolute path to the file or directory to bind-mount
            (for example, <tt>src=/path/on/host/</tt>). An error is produced if the file or directory does not exist.
          </li>
          <li>
            <tt>type=tmpfs</tt>: <tt>src</tt> is not supported.
          </li>
        </ul>
      </td>
    </tr>
@y
    <tr>
      <td><b>src</b> または <b>source</b></td>
      <td><tt>type=bind</tt> または <tt>type=npipe</tt> の場合</td>
      <td>
        <ul>
          <li>
           <tt>type=volume</tt>: <tt>src</tt> という記述によりボリューム名を指定することもできます（たとえば <tt>src=my-volume</tt>）。
            名前つきボリュームが存在しなかった場合は自動的に生成されます。
            <tt>src</tt> が指定されなかった場合、ボリュームに対してランダムな名前が割り当てられます。
            この名前はホスト上において必ずユニークなものとなります。
            ただしクラスター内においてはユニークにならないことがあります。
            ランダムに命名されたボリュームは、コンテナーと同一ライフサイクルとなります。
            つまり <i>container</i> が削除される（<tt>service update</tt> の実行時や、サービスのスケール変更あるいは再配置時）と同時に削除されます。
          </li>
          <li>
            <tt>type=bind</tt>: <tt>src</tt> は必須であり、バインドマウントするファイルまたはディレクトリへの絶対パスを指定します。（たとえば <tt>src=/path/on/host/</tt>）ファイルやディレクトリが存在しなかった場合にはエラーが発生します。
          </li>
          <li>
            <tt>type=tmpfs</tt>: <tt>src</tt> はサポートされません。
          </li>
        </ul>
      </td>
    </tr>
@z

@x
    <tr>
      <td><p><b>dst</b> or <b>destination</b> or <b>target</b></p></td>
      <td>yes</td>
      <td>
        <p>Mount path inside the container, for example <tt>/some/path/in/container/</tt>.
        If the path does not exist in the container's filesystem, the Engine creates
        a directory at the specified location before mounting the volume or bind mount.</p>
      </td>
    </tr>
@y
    <tr>
      <td><p><b>dst</b> または <b>destination</b> または <b>target</b></p></td>
      <td>必須</td>
      <td>
        <p>コンテナー内のマウントパス。たとえば <tt>/some/path/in/container/</tt>。
        コンテナーのファイルシステム内にそのパスが存在しなかった場合、Engine がその指定に従ってディレクトリを生成し、その後にボリュームやバインドマウントがマウントされます。</p>
      </td>
    </tr>
@z

@x
    <tr>
      <td><p><b>readonly</b> or <b>ro</b></p></td>
      <td></td>
      <td>
        <p>The Engine mounts binds and volumes <tt>read-write</tt> unless <tt>readonly</tt> option
        is given when mounting the bind or volume. Note that setting <tt>readonly</tt> for a
        bind-mount does not make its submounts <tt>readonly</tt> on the current Linux implementation. See also <tt>bind-nonrecursive</tt>.</p>
        <ul>
          <li><tt>true</tt> or <tt>1</tt> or no value: Mounts the bind or volume read-only.</li>
          <li><tt>false</tt> or <tt>0</tt>: Mounts the bind or volume read-write.</li>
        </ul>
      </td>
    </tr>
  </table>
@y
    <tr>
      <td><p><b>readonly</b> または <b>ro</b></p></td>
      <td></td>
      <td>
        <p>マウントの際に <tt>readonly</tt> オプションが指定されていなければ、Engine は <tt>read-write</tt> としてバインドマウントまたはボリュームをマウントします。
        なお現状の Linux 実装においては <tt>readonly</tt> によりバインドマウントを行っても、そのサブマウントまでは <tt>readonly</tt> になりません。</p>
        <ul>
          <li><tt>true</tt> または <tt>1</tt> または値なしの場合、バインドマウントまたはボリュームをread-only としてマウントします。</li>
          <li><tt>false</tt> または <tt>0</tt> は、バインドマウントまたはボリュームを read-write としてマウントします。</li>
        </ul>
      </td>
    </tr>
  </table>
@z

@x
  #### Options for Bind Mounts
@y
  {: #options-for-bind-mounts }
  #### バインドマウントのオプション
@z

@x
  The following options can only be used for bind mounts (`type=bind`):
@y
  以下のオプションはバインドマウント（`type=bind`）の場合にのみ利用可能です。
@z

@x
  <table>
    <tr>
      <th>Option</th>
      <th>Description</th>
    </tr>
@y
  <table>
    <tr>
      <th>オプション</th>
      <th>内容説明</th>
    </tr>
@z

@x
    <tr>
      <td><b>bind-propagation</b></td>
      <td>
        <p>See the <a href="#bind-propagation">bind propagation section</a>.</p>
      </td>
    </tr>
@y
    <tr>
      <td><b>bind-propagation</b></td>
      <td>
        <p><a href="#bind-propagation">バインドプロパゲーション</a> の節を参照してください。</p>
      </td>
    </tr>
@z

@x
    <tr>
      <td><b>consistency</b></td>
      <td>
        <p>The consistency requirements for the mount; one of </p>
        <ul>
         <li><tt>default</tt>: Equivalent to <tt>consistent</tt>.</li>
         <li><tt>consistent</tt>: Full consistency.  The container runtime and the host maintain an identical view of the mount at all times.</li>
         <li><tt>cached</tt>: The host's view of the mount is authoritative.  There may be delays before updates made on the host are visible within a container.</li>
         <li><tt>delegated</tt>: The container runtime's view of the mount is authoritative.  There may be delays before updates made in a container are visible on the host.</li>
        </ul>
      </td>
    </tr>
@y
    <tr>
      <td><b>consistency</b></td>
      <td>
        <p>マウントにおける一貫性の要求状況。以下のいずれかです。</p>
        <ul>
         <li><tt>default</tt> は <tt>consistent</tt> と同じです。</li>
         <li><tt>consistent</tt> は完全な一貫性を表します。コンテナーランタイムとホストは、いかなる時点においても同一のマウント参照を維持します。</li>
         <li><tt>cached</tt> は、ホストから見たマウントの信頼性を維持します。ホスト上において発生した更新は、コンテナー内で参照できるようになるまでに時間を要します。</li>
         <li><tt>delegated</tt> は、コンテナーランタイムから見たマウントの信頼性を維持します。コンテナー上において発生した更新は、ホスト内で参照できるようになるまでに時間を要します。</li>
        </ul>
      </td>
    </tr>
@z

@x
    <tr>
      <td><b>bind-nonrecursive</b></td>
      <td>
        By default, submounts are recursively bind-mounted as well. However, this behavior can be confusing when a
        bind mount is configured with <tt>readonly</tt> option, because submounts are not mounted as read-only.
        Set <tt>bind-nonrecursive</tt> to disable recursive bind-mount.<br />
        <br />
        A value is optional:<br />
        <br />
        <ul>
          <li><tt>true</tt> or <tt>1</tt>: Disables recursive bind-mount.</li>
          <li><tt>false</tt> or <tt>0</tt>: Default if you do not provide a value. Enables recursive bind-mount.</li>
        </ul>
      </td>
    </tr>
  </table>
@y
    <tr>
      <td><b>bind-nonrecursive</b></td>
      <td>
        デフォルトにおいてサブマウントも、再帰的にバインドマウントされます。しかしこの動作は、<tt>readonly</tt> を使ってバインドマウントが行われた際には混乱の元となります。その場合のサブマウントは read-only にならないからです。
        <tt>bind-nonrecursive</tt> を設定すれば、再帰的なバインドマウントを無効にできます。<br />
        <br />
        設定値は以下のとおりです。<br />
        <br />
        <ul>
          <li><tt>true</tt> または <tt>1</tt> は、再帰的なバインドマウントを無効にします。</li>
          <li><tt>false</tt> または <tt>0</tt>、また設定がない場合にはこれがデフォルトになりますが、再帰的なバインドマウントを有効にします。</li>
        </ul>
      </td>
    </tr>
  </table>
@z

@x
  ##### Bind propagation
@y
  {: #bind-propagation }
  ##### バインドプロパゲーション
@z

@x
  Bind propagation refers to whether or not mounts created within a given
  bind mount or named volume can be propagated to replicas of that mount. Consider
  a mount point `/mnt`, which is also mounted on `/tmp`. The propagation settings
  control whether a mount on `/tmp/a` would also be available on `/mnt/a`. Each
  propagation setting has a recursive counterpoint. In the case of recursion,
  consider that `/tmp/a` is also mounted as `/foo`. The propagation settings
  control whether `/mnt/a` and/or `/tmp/a` would exist.
@y
  バインドプロパゲーションとは、指定されたバインドマウントや名前つきボリュームによって生成されるマウントが、そのレプリカに対して情報伝達（propagate）をするかどうかを表わします。
  ここで`/mnt`というマウントポイントを考えます。
  これが`/tmp`にマウントされているとします。
  これに対するプロパゲーションの設定は、`/tmp/a`上のマウントが`/mnt/a`として利用可能かどうかを制御するものです。
  プロパゲーションの各設定においては、再帰的に対応するマウントポイントが存在します。
  再帰的という点でいうと、仮に`/tmp/a`が`/foo`としてマウントされていたとします。
  このときプロパゲーション設定は`/mnt/a`や`/tmp/a`が存在するかどうかを定めるものです。
@z

@x
  The `bind-propagation` option defaults to `rprivate` for both bind mounts and
  volume mounts, and is only configurable for bind mounts. In other words, named
  volumes do not support bind propagation.
@y
  オプション`bind-propagation`は、バインドマウントとボリュームマウントのいずれにおいても、デフォルトは`rprivate`と設定されていますが、変更可能であるのはバインドマウントにおいてのみです。
  つまり名前つきボリュームではバインドプロパゲーションはサポートされていません。
@z

@x
  - **`shared`**: Sub-mounts of the original mount are exposed to replica mounts,
                  and sub-mounts of replica mounts are also propagated to the
                  original mount.
@y
  - **`shared`**＝ マウント元に対するサブマウントは、マウント先にも公開されます。
                    マウント先に対するサブマウントも、マウント元に対して公開されます。
@z

@x
  - **`slave`**: similar to a shared mount, but only in one direction. If the
                 original mount exposes a sub-mount, the replica mount can see it.
                 However, if the replica mount exposes a sub-mount, the original
                 mount cannot see it.
@y
  - **`slave`**＝ shared マウントに類似。
                   ただし一方向のみ。
                   マウント元がサブマウントを公開するなら、マウント先でもこれを見ることができますが、マウント先がサブマウントを公開しても、マウント元からは見ることができません。
@z

@x
  - **`private`**: The mount is private. Sub-mounts within it are not exposed to
                   replica mounts, and sub-mounts of replica mounts are not
                   exposed to the original mount.
@y
  - **`private`**＝ マウントはプライベートなものになります。
                     マウント元におけるサブマウントは、マウント先に公開されません。
                     またマウント先のサブマウントも、マウント元には公開されません。
@z

@x
  - **`rshared`**: The same as shared, but the propagation also extends to and from
                   mount points nested within any of the original or replica mount
                   points.
@y
  - **`rshared`**＝ shared と同様。
                     ただしプロパゲーションは、元々のマウントポイントまたはレプリカマウントポイントにネストされたマウントポイントとの間にも伝達されます。
@z

@x
  - **`rslave`**: The same as `slave`, but the propagation also extends to and from
                   mount points nested within any of the original or replica mount
                   points.
@y
  - **`rslave`**＝ slave と同様。
                    `slave` と同じく、プロパゲーションは、元々のマウントポイントまたはレプリカマウントポイントにネストされたマウントポイントとの間にも情報伝達されます。
@z

@x
  - **`rprivate`**: The default. The same as `private`, meaning that no mount points
                    anywhere within the original or replica mount points propagate
                    in either direction.
@y
  - **`rprivate`**＝ デフォルト。
                      `private`と同様。
                      つまり元々のマウントポイントまたはレプリカマウントポイント内のサブマウントは、どの方向にも情報伝達されません。
@z

@x
  For more information about bind propagation, see the
  [Linux kernel documentation for shared subtree](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt).
@y
  バインドプロパゲーションの詳細については [Linux カーネルの shared subtree に関するドキュメント](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt) を参照してください。
@z

@x
  #### Options for named volumes
@y
  {: #options-for-named-volumes }
  #### 名前つきボリュームのオプション
@z

@x
  The following options can only be used for named volumes (`type=volume`):
@y
  以下のオプションは名前つきボリューム（`type=volume`）の場合にのみ利用可能です。
@z

@x
  <table>
    <tr>
      <th>Option</th>
      <th>Description</th>
    </tr>
@y
  <table>
    <tr>
      <th>オプション</th>
      <th>内容説明</th>
    </tr>
@z

@x
    <tr>
      <td><b>volume-driver</b></td>
      <td>
        <p>Name of the volume-driver plugin to use for the volume. Defaults to
        <tt>"local"</tt>, to use the local volume driver to create the volume if the
        volume does not exist.</p>
      </td>
    </tr>
@y
    <tr>
      <td><b>volume-driver</b></td>
      <td>
        <p>ボリュームに対して利用するボリュームドライバープラグイン名。
        デフォルトは <tt>"local"</tt>。
        これが指定されている場合、ボリュームが存在しない場合にこのローカルボリュームドライバーを使ってボリュームが生成されます。</p>
      </td>
    </tr>
@z

@x
    <tr>
      <td><b>volume-label</b></td>
      <td>
        One or more custom metadata ("labels") to apply to the volume upon
        creation. For example,
        <tt>volume-label=mylabel=hello-world,my-other-label=hello-mars</tt>. For more
        information about labels, refer to
        <a href="https://docs.docker.com/config/labels-custom-metadata/">apply custom metadata</a>.
      </td>
    </tr>
@y
    <tr>
      <td><b>volume-label</b></td>
      <td>
        ボリュームの生成時に適用される 1 つまたは複数のカスタムメタデータ（"labels"）。
        たとえば <tt>volume-label=mylabel=hello-world,my-other-label=hello-mars</tt> など。
        ラベルに関する詳細は <a href="__HOSTURL__/config/labels-custom-metadata/">カスタムメタデータの適用</a> を参照してください。
      </td>
    </tr>
@z

@x
    <tr>
      <td><b>volume-nocopy</b></td>
      <td>
        By default, if you attach an empty volume to a container, and files or
        directories already existed at the mount-path in the container (<tt>dst</tt>),
        the Engine copies those files and directories into the volume, allowing
        the host to access them. Set <tt>volume-nocopy</tt> to disable copying files
        from the container's filesystem to the volume and mount the empty volume.<br />
        <br />
        A value is optional:<br />
        <br />
        <ul>
          <li><tt>true</tt> or <tt>1</tt>: Default if you do not provide a value. Disables copying.</li>
          <li><tt>false</tt> or <tt>0</tt>: Enables copying.</li>
        </ul>
      </td>
    </tr>
@y
    <tr>
      <td><b>volume-nocopy</b></td>
      <td>
        空のボリュームをコンテナーに割り当てた際に、コンテナー内のマウントパス（<tt>dst</tt>）にすでにファイルやディレクトリが存在していた場合は、デフォルトで Engine がそのファイルやディレクトリをボリューム内にコピーし、ホストからのアクセスを可能とします。
        この <tt>volume-nocopy</tt> を設定すると、コンテナー内のファイルシステムからボリュームへのファイルコピーが無効化され、空のボリュームがマウントされます。<br />
        <br />
        設定値は以下のとおりです。<br />
        <br />
        <ul>
          <li><tt>true</tt> または <tt>1</tt>、また設定がない場合にはこれがデフォルトになりますが、コピーを無効にします。</li>
          <li><tt>false</tt> または <tt>0</tt> はコピーを有効にします。</li>
        </ul>
      </td>
    </tr>
@z

@x
    <tr>
      <td><b>volume-opt</b></td>
      <td>
        Options specific to a given volume driver, which will be passed to the
        driver when creating the volume. Options are provided as a comma-separated
        list of key/value pairs, for example,
        <tt>volume-opt=some-option=some-value,volume-opt=some-other-option=some-other-value</tt>.
        For available options for a given driver, refer to that driver's
        documentation.
      </td>
    </tr>
  </table>
@y
    <tr>
      <td><b>volume-opt</b></td>
      <td>
        指定するボリュームドライバーに固有のオプション。
        このオプションはボリューム生成時にドライバーに受け渡されます。
        オプションはキーバリューのペアをカンマで区切ったリストとして指定します。
        たとえば <tt>volume-opt=some-option=some-value,volume-opt=some-other-option=some-other-value</tt> です。
        指定するドライバーにおいて利用可能なオプションについては、各ドライバーのドキュメントを参照してください。
      </td>
    </tr>
  </table>
@z

@x
  #### Options for tmpfs
@y
  {: #options-for-tmpfs }
  #### tmpfs のオプション
@z

@x
  The following options can only be used for tmpfs mounts (`type=tmpfs`);
@y
  以下のオプションは tmpfs マウント（`type=tmpfs`）の場合にのみ利用可能です。
@z

@x
  <table>
    <tr>
      <th>Option</th>
      <th>Description</th>
    </tr>
@y
  <table>
    <tr>
      <th>オプション</th>
      <th>内容説明</th>
    </tr>
@z

@x
    <tr>
      <td><b>tmpfs-size</b></td>
      <td>Size of the tmpfs mount in bytes. Unlimited by default in Linux.</td>
    </tr>
@y
    <tr>
      <td><b>tmpfs-size</b></td>
      <td>tmpfs マウントの容量をバイト単位で指定します。Linux におけるデフォルトは無制限です。</td>
    </tr>
@z

@x
    <tr>
      <td><b>tmpfs-mode</b></td>
      <td>File mode of the tmpfs in octal. (e.g. <tt>"700"</tt> or <tt>"0700"</tt>.) Defaults to <tt>"1777"</tt> in Linux.</td>
    </tr>
  </table>
@y
    <tr>
      <td><b>tmpfs-mode</b></td>
      <td>8 進数表記による tmpfs のファイルモード。（たとえば <tt>"700"</tt> や <tt>"0700"</tt> など。）
      Linux におけるデフォルトは <tt>"1777"</tt>。</td>
    </tr>
  </table>
@z

@x
  #### Differences between "--mount" and "--volume"
@y
  {: #differences-between---mount-and---volume }
  #### 「--mount」と「--volume」の違い
@z

@x
  The `--mount` flag supports most options that are supported by the `-v`
  or `--volume` flag for `docker run`, with some important exceptions:
@y
  `--mount`フラグは、`docker run`における`-v`または`--volume`フラグと、ほとんど同じオプションがサポートされています。
  ただし以下のように重要な違いがあります。
@z

@x
  - The `--mount` flag allows you to specify a volume driver and volume driver
    options *per volume*, without creating the volumes in advance. In contrast,
    `docker run` allows you to specify a single volume driver which is shared
    by all volumes, using the `--volume-driver` flag.
@y
  - `--mount`フラグではボリュームドライバーの指定が可能であり、**各ボリュームごとに** ボリュームドライバーオプションの指定ができます。
    これはボリュームを生成しなくてもできることです。
    それに比べて`docker run`では、`--volume-driver`フラグを使って、全ボリュームに共通するボリュームドライバーを指定します。
@z

@x
  - The `--mount` flag allows you to specify custom metadata ("labels") for a volume,
    before the volume is created.
@y
  - `--mount`フラグでは、ボリュームに対してカスタムメタデータ（「labels」）を指定することができます。
    これはボリューム生成前に設定されます。
@z

@x
  - When you use `--mount` with `type=bind`, the host-path must refer to an *existing*
    path on the host. The path will not be created for you and the service will fail
    with an error if the path does not exist.
@y
  - `type=bind`指定とともに`--mount`フラグを用いる場合、ホストパスはホスト上に **存在している** パスでなければなりません。
    パスは自動的に生成されないため、パスが存在していないとサービスはエラー終了します。
@z

@x
  - The `--mount` flag does not allow you to relabel a volume with `Z` or `z` flags,
    which are used for `selinux` labeling.
@y
  - `--mount`フラグでは、`Z`フラグまたは`z`フラグを使ったボリュームのラベル変更はできません。
    それらのフラグは`selinux`のラベルづけに利用されています。
@z

@x
  #### Create a service using a named volume
@y
  {: #create-a-service-using-a-named-volume }
  #### 名前つきボリュームを用いたサービス生成
@z

@x
  The following example creates a service that uses a named volume:
@y
  以下の例は、名前つきボリュームを利用するサービスを生成します。
@z

@x
  ```console
  $ docker service create \
    --name my-service \
    --replicas 3 \
    --mount type=volume,source=my-volume,destination=/path/in/container,volume-label="color=red",volume-label="shape=round" \
    nginx:alpine
  ```
@y
  ```console
  $ docker service create \
    --name my-service \
    --replicas 3 \
    --mount type=volume,source=my-volume,destination=/path/in/container,volume-label="color=red",volume-label="shape=round" \
    nginx:alpine
  ```
@z

@x
  For each replica of the service, the engine requests a volume named "my-volume"
  from the default ("local") volume driver where the task is deployed. If the
  volume does not exist, the engine creates a new volume and applies the "color"
  and "shape" labels.
@y
  サービスの各レプリカにおいては、タスクがデプロイされた場所のデフォルト（「local」）ボリュームドライバーから、Engine が「my-volume」という名のボリュームを要求します。
  ボリュームが存在しなかった場合、Engine は新たなボリュームを生成して、そのラベルとして「color」と「shape」を設定します。
@z

@x
  When the task is started, the volume is mounted on `/path/in/container/` inside
  the container.
@y
  タスクが起動すると、ボリュームはコンテナー内の`/path/in/container/`にマウントされます。
@z

@x
  Be aware that the default ("local") volume is a locally scoped volume driver.
  This means that depending on where a task is deployed, either that task gets a
  *new* volume named "my-volume", or shares the same "my-volume" with other tasks
  of the same service. Multiple containers writing to a single shared volume can
  cause data corruption if the software running inside the container is not
  designed to handle concurrent processes writing to the same location. Also take
  into account that containers can be re-scheduled by the Swarm orchestrator and
  be deployed on a different node.
@y
  注意する点として、デフォルトの（「local」）ボリュームドライバーのスコープは、あくまでローカルであるということです。
  これはつまり、タスクがどこにデプロイされているかに依存します。
  「my-volume」という名前のボリュームを **新たに** 生成するか、同一サービス内の別タスクとの間で同じ「my-volume」を共有するかは状況次第です。
  複数のコンテナーが 1 つの共有ボリュームに書き込みを行うとすると、コンテナー上で動作するソフトウェアが同一箇所への書き込みを並行処理するように設計されていないと、データ破壊を引き起こす可能性があります。
  さらにコンテナーというものは Swarm オーケストレーターによって再スケジュールされ、別のノードに再配置されることがあるので、このことにも留意する必要があります。
@z

@x
  #### Create a service that uses an anonymous volume
@y
  {: #create-a-service-that-uses-an-anonymous-volume }
  #### 匿名ボリュームを使ったサービス生成
@z

@x
  The following command creates a service with three replicas with an anonymous
  volume on `/path/in/container`:
@y
  以下の例では 3 つのレプリカを持つサービスを生成し、`/path/in/container`にマウントされた匿名ボリュームを利用します。
@z

@x
  ```console
  $ docker service create \
    --name my-service \
    --replicas 3 \
    --mount type=volume,destination=/path/in/container \
    nginx:alpine
  ```
@y
  ```console
  $ docker service create \
    --name my-service \
    --replicas 3 \
    --mount type=volume,destination=/path/in/container \
    nginx:alpine
  ```
@z

@x
  In this example, no name (`source`) is specified for the volume, so a new volume
  is created for each task. This guarantees that each task gets its own volume,
  and volumes are not shared between tasks. Anonymous volumes are removed after
  the task using them is complete.
@y
  上のコマンドにおいては、ボリュームに対する名前（`source`）が指定されていないため、新たなボリュームが各タスクにて生成されます。
  これは各タスクがそれぞれ独自のボリュームを確実に持つものとなるため、タスク間においてボリュームの共有は行われません。
  匿名ボリュームは、これを利用するタスクが終了すると削除されます。
@z

@x
  #### Create a service that uses a bind-mounted host directory
@y
  {: #create-a-service-that-uses-a-bind-mounted-host-directory }
  #### ホストのディレクトリにバインドマウントされたサービスの生成
@z

@x
  The following example bind-mounts a host directory at `/path/in/container` in
  the containers backing the service:
@y
  以下の例は、サービスを起動するコンテナーにおいて、ホストのディレクトリ`/path/in/container`をバインドマウントするものです。
@z

@x
  ```console
  $ docker service create \
    --name my-service \
    --mount type=bind,source=/path/on/host,destination=/path/in/container \
    nginx:alpine
  ```
@y
  ```console
  $ docker service create \
    --name my-service \
    --mount type=bind,source=/path/on/host,destination=/path/in/container \
    nginx:alpine
  ```
@z

@x
  ### Set service mode (--mode)
@y
  {: #set-service-mode---mode }
  ### サービスモードの設定（--mode）
@z

@x
  The service mode determines whether this is a _replicated_ service or a _global_
  service. A replicated service runs as many tasks as specified, while a global
  service runs on each active node in the swarm.
@y
  サービスモードは、サービスが **レプリカされた**（replicated）ものか **グローバルな** ものかを決定します。
  レプリカされたサービスは、指定に従って複数のタスクとして実行されます。
  一方グローバルなサービスは、Swarm 内においてアクティブな各ノード上で実行されます。
@z

@x
  The following command creates a global service:
@y
  以下のコマンドはグローバルサービスを生成します。
@z

@x
  ```console
  $ docker service create \
   --name redis_2 \
   --mode global \
   redis:3.0.6
  ```
@y
  ```console
  $ docker service create \
   --name redis_2 \
   --mode global \
   redis:3.0.6
  ```
@z

@x
  ### Specify service constraints (--constraint)
@y
  {: #specify-service-constraints---constraint }
  ### サービス制約の指定（--constraint）
@z

@x
  You can limit the set of nodes where a task can be scheduled by defining
  constraint expressions. Constraint expressions can either use a _match_ (`==`)
  or _exclude_ (`!=`) rule. Multiple constraints find nodes that satisfy every
  expression (AND match). Constraints can match node or Docker Engine labels as
  follows:
@y
  スケジューリングされるタスクに対しては制約表現（constraint expressions）を定義することができ、これにより一連のノードへの制限を課すことができます。
  制約表現は **合致する**（`==`）か、あるいは **除外する**（`!=`）というルールにより表現されます。
  制約が複数ある場合は、すべての表現に合致する（AND 条件による）ノードに適用されます。
  制約は以下のように、ノードまたは Docker Engine ラベルに適用されます。
@z

@x
  node attribute       | matches                        | example
  ---------------------|--------------------------------|-----------------------------------------------
  `node.id`            | Node ID                        | `node.id==2ivku8v2gvtg4`
  `node.hostname`      | Node hostname                  | `node.hostname!=node-2`
  `node.role`          | Node role (`manager`/`worker`) | `node.role==manager`
  `node.platform.os`   | Node operating system          | `node.platform.os==windows`
  `node.platform.arch` | Node architecture              | `node.platform.arch==x86_64`
  `node.labels`        | User-defined node labels       | `node.labels.security==high`
  `engine.labels`      | Docker Engine's labels         | `engine.labels.operatingsystem==ubuntu-14.04`
@y
  ノード属性           | 該当項目                             | 例
  ---------------------|--------------------------------------|-----------------------------------------------
  `node.id`            | ノード ID                            | `node.id==2ivku8v2gvtg4`
  `node.hostname`      | ノードホスト名                       | `node.hostname!=node-2`
  `node.role`          | ノードのロール（`manager`/`worker`） | `node.role==manager`
  `node.platform.os`   | ノードのオペレーティングシステム     | `node.platform.os==windows`
  `node.platform.arch` | ノードのアーキテクチャー             | `node.platform.arch==x86_64`
  `node.labels`        | ユーザー定義のノードラベル           | `node.labels.security==high`
  `engine.labels`      | Docker Engine のラベル               | `engine.labels.operatingsystem==ubuntu-14.04`
@z

@x
  `engine.labels` apply to Docker Engine labels like operating system, drivers,
  etc. Swarm administrators add `node.labels` for operational purposes by using
  the [`docker node update`](node_update.md) command.
@y
  `engine.labels`は、オペレーティングシステムやドライバーなどのような Docker Engine ラベルに適用されます。
  Swarm 管理者は操作をしやすくする目的で、[`docker node update`](__HOSTURL__/engine/reference/commandline/node_update/) コマンドを使って`node.labels`を追加します。
@z

@x
  For example, the following limits tasks for the redis service to nodes where the
  node type label equals queue:
@y
  たとえば以下の例では、redis サービスのタスクへの制約を設定するものであり、ノードのタイプラベルが queue であるものを対象とします。
@z

@x
  ```console
  $ docker service create \
    --name redis_2 \
    --constraint node.platform.os==linux \
    --constraint node.labels.type==queue \
    redis:3.0.6
  ```
@y
  ```console
  $ docker service create \
    --name redis_2 \
    --constraint node.platform.os==linux \
    --constraint node.labels.type==queue \
    redis:3.0.6
  ```
@z

@x
  If the service constraints exclude all nodes in the cluster, a message is printed
  that no suitable node is found, but the scheduler will start a reconciliation
  loop and deploy the service once a suitable node becomes available.
@y
  サービスへの制約がクラスター内のどのノードにも合致しなかった場合、対象となるノードが見つからなかったというメッセージが出力されます。
  ただし対象となるノードが出現した場合には、スケジューラーが調整ループを起動させてサービスをデプロイします。
@z

@x
  In the example below, no node satisfying the constraint was found, causing the
  service to not reconcile with the desired state:
@y
  以下の例では、制約を満たすノードが見つからなかったために、サービスが意図する状態にならなかったことを表しています。
@z

@x
  ```console
  $ docker service create \
    --name web \
    --constraint node.labels.region==east \
    nginx:alpine

  lx1wrhhpmbbu0wuk0ybws30bc
  overall progress: 0 out of 1 tasks
  1/1: no suitable node (scheduling constraints not satisfied on 5 nodes)

  $ docker service ls
  ID                  NAME     MODE         REPLICAS   IMAGE               PORTS
  b6lww17hrr4e        web      replicated   0/1        nginx:alpine
  ```
@y
  ```console
  $ docker service create \
    --name web \
    --constraint node.labels.region==east \
    nginx:alpine

  lx1wrhhpmbbu0wuk0ybws30bc
  overall progress: 0 out of 1 tasks
  1/1: no suitable node (scheduling constraints not satisfied on 5 nodes)

  $ docker service ls
  ID                  NAME     MODE         REPLICAS   IMAGE               PORTS
  b6lww17hrr4e        web      replicated   0/1        nginx:alpine
  ```
@z

@x
  After adding the `region=east` label to a node in the cluster, the service
  reconciles, and the desired number of replicas are deployed:
@y
  この後にクラスター内の 1 つのノードに対して`region=east`というラベルを追加すると、サービス調整が始まり、期待される数だけのレプリカがデプロイされます。
@z

@x
  ```console
  $ docker node update --label-add region=east yswe2dm4c5fdgtsrli1e8ya5l
  yswe2dm4c5fdgtsrli1e8ya5l

  $ docker service ls
  ID                  NAME     MODE         REPLICAS   IMAGE               PORTS
  b6lww17hrr4e        web      replicated   1/1        nginx:alpine
  ```
@y
  ```console
  $ docker node update --label-add region=east yswe2dm4c5fdgtsrli1e8ya5l
  yswe2dm4c5fdgtsrli1e8ya5l

  $ docker service ls
  ID                  NAME     MODE         REPLICAS   IMAGE               PORTS
  b6lww17hrr4e        web      replicated   1/1        nginx:alpine
  ```
@z

@x
  ### Specify service placement preferences (--placement-pref)
@y
  {: #specify-service-placement-preferences---placement-pref }
  ### サービスの配置設定の指定（--placement-pref）
@z

@x
  You can set up the service to divide tasks evenly over different categories of
  nodes. One example of where this can be useful is to balance tasks over a set
  of datacenters or availability zones. The example below illustrates this:
@y
  さまざまなカテゴリーのノードに対して、タスクを均等に割り振るようにサービスを設定することができます。
  1 つの例として有用になるのが、データセンターや利用可能なゾーンが複数にわたっていて、そこにバランスよくタスクを割り振る場合です。
  以下の例はこれを示しています。
@z

@x
  ```console
  $ docker service create \
    --replicas 9 \
    --name redis_2 \
    --placement-pref spread=node.labels.datacenter \
    redis:3.0.6
  ```
@y
  ```console
  $ docker service create \
    --replicas 9 \
    --name redis_2 \
    --placement-pref spread=node.labels.datacenter \
    redis:3.0.6
  ```
@z

@x
  This uses `--placement-pref` with a `spread` strategy (currently the only
  supported strategy) to spread tasks evenly over the values of the `datacenter`
  node label. In this example, we assume that every node has a `datacenter` node
  label attached to it. If there are three different values of this label among
  nodes in the swarm, one third of the tasks will be placed on the nodes
  associated with each value. This is true even if there are more nodes with one
  value than another. For example, consider the following set of nodes:
@y
  ここでは`--placement-pref`に`spread`ストラテジー（現時点においては唯一サポートされているストラテジー）を用いて、`datacenter`ノードラベルを持つノードにわたって均等にタスクを広げて（spread して）います。
  この例では、全ノードにおいてノードラベル`datacenter`が与えられているものとしています。
  もし Swarm 内のノードにおいて三種類のラベル値が存在していたとすると、各値が与えられているノードに 3 分の 1 ずつのタスクが割り振られることになります。
  たとえ 1 つの値を持つノードの数が他よりも多くても、この割り振りは変わりません。
  たとえばノードの状態が以下であるとします。
@z

@x
  - Three nodes with `node.labels.datacenter=east`
  - Two nodes with `node.labels.datacenter=south`
  - One node with `node.labels.datacenter=west`
@y
  - `node.labels.datacenter=east`を持つノードが 3 つ。
  - `node.labels.datacenter=south`を持つノードが 2 つ。
  - `node.labels.datacenter=west`を持つノードが 1 つ。
@z

@x
  Since we are spreading over the values of the `datacenter` label and the
  service has 9 replicas, 3 replicas will end up in each datacenter. There are
  three nodes associated with the value `east`, so each one will get one of the
  three replicas reserved for this value. There are two nodes with the value
  `south`, and the three replicas for this value will be divided between them,
  with one receiving two replicas and another receiving just one. Finally, `west`
  has a single node that will get all three replicas reserved for `west`.
@y
  上では`datacenter`ラベルを持つノードへの spread を行っており、サービスには 9 個のレプリカを設定しています。
  したがって各 datacenter へは 3 つのレプリカが配置されるはずです。
  ところでラベル値`east`を持つノードは 3 つでした。
  したがってその各ノードへは、この値に対して割り振られる 3 つのレプリカの 1 つがそれぞれに割り振られます。
  またラベル値`south`を持つノードは 2 つです。
  この値に対して割り振られる 3 つのレプリカは、そのノード間で分配されます。
  つまり 1 つのノードが 2 つのレプリカを受け持つこととなり、残る 1 つのノードがレプリカ 1 つだけを受け持ちます。
  最後にラベル値`west`を持つノードでは、`west`に割り当てられる 3 つのレプリカすべてを 1 つのノードが持つことになります。
@z

@x
  If the nodes in one category (for example, those with
  `node.labels.datacenter=south`) can't handle their fair share of tasks due to
  constraints or resource limitations, the extra tasks will be assigned to other
  nodes instead, if possible.
@y
  1 つのカテゴリー（たとえば`node.labels.datacenter=south`）を持つノードが、制約やリソース制限によって本来受け持つべきタスクを扱えない場合、余ったタスクは、可能であれば別のノードに割り当てられることになります。
@z

@x
  Both engine labels and node labels are supported by placement preferences. The
  example above uses a node label, because the label is referenced with
  `node.labels.datacenter`. To spread over the values of an engine label, use
  `--placement-pref spread=engine.labels.<labelname>`.
@y
  配置設定（placement preferences）においては、Engine ラベルとノードラベルの両方をサポートします。
  上の例ではノードラベルを用いていましたが、この例では`node.labels.datacenter`としてラベルを参照したからです。
  Engine ラベルの値に基づいて spread を行うのであれば、`--placement-pref spread=engine.labels.<labelname>` とします。
@z

@x
  It is possible to add multiple placement preferences to a service. This
  establishes a hierarchy of preferences, so that tasks are first divided over
  one category, and then further divided over additional categories. One example
  of where this may be useful is dividing tasks fairly between datacenters, and
  then splitting the tasks within each datacenter over a choice of racks. To add
  multiple placement preferences, specify the `--placement-pref` flag multiple
  times. The order is significant, and the placement preferences will be applied
  in the order given when making scheduling decisions.
@y
  サービスにおける配置設定は複数追加することができます。
  これを行うと設定が階層化されます。
  つまりタスクに対して 1 つのカテゴリーにより分配が行われ、さらに別のカテゴリーを通じて分配が行われるといった具合です。
  1 つの例として有用になるのが、データセンター間において公正にタスクを割り振り、各データセンターでは設定するラックに対してタスクを分割する場合です。
  配置設定を複数指定する場合は`--placement-pref`フラグを複数回指定します。
  その場合は指定準が重要になります。
  配置設定は、スケジュール決定が行われる際に指定順により適用されます。
@z

@x
  The following example sets up a service with multiple placement preferences.
  Tasks are spread first over the various datacenters, and then over racks
  (as indicated by the respective labels):
@y
  以下の例は、配置設定を複数指定したサービスを起動します。
  タスクは初めに各データセンターに割り振られ、次にラックに対して割り振られます（それぞれラベルによって示されています）。
@z

@x
  ```console
  $ docker service create \
    --replicas 9 \
    --name redis_2 \
    --placement-pref 'spread=node.labels.datacenter' \
    --placement-pref 'spread=node.labels.rack' \
    redis:3.0.6
  ```
@y
  ```console
  $ docker service create \
    --replicas 9 \
    --name redis_2 \
    --placement-pref 'spread=node.labels.datacenter' \
    --placement-pref 'spread=node.labels.rack' \
    redis:3.0.6
  ```
@z

@x
  When updating a service with `docker service update`, `--placement-pref-add`
  appends a new placement preference after all existing placement preferences.
  `--placement-pref-rm` removes an existing placement preference that matches the
  argument.
@y
  `docker service update`によってサービスを更新する際に`--placement-pref-add`を利用すると、既存の配置設定に新たな配置設定を追加することができます。
  また`--placement-pref-rm`は、引数に合致する既存の配置設定を削除します。
@z

@x
  ### Specify memory requirements and constraints for a service (--reserve-memory and --limit-memory)
@y
  {: #specify-memory-requirements-and-constraints-for-a-service---reserve-memory-and---limit-memory }
  ### サービスに対するメモリ要求と制約の指定（--reserve-memory、--limit-memory）
@z

@x
  If your service needs a minimum amount of memory in order to run correctly,
  you can use `--reserve-memory` to specify that the service should only be
  scheduled on a node with this much memory available to reserve. If no node is
  available that meets the criteria, the task is not scheduled, but remains in a
  pending state.
@y
  適正にサービスを実行するのに特定のメモリ容量を最低でも必要とする場合は`--reserve-memory`を用います。
  これを用いると、サービスがその分のメモリ量を確保できるノードにしかノード配分を行いません。
  この基準を満たすノードが 1 つもなかった場合、タスクはスケジューリングされず、ペンディング状態のままとなります。
@z

@x
  The following example requires that 4GB of memory be available and reservable
  on a given node before scheduling the service to run on that node.
@y
  以下の例は、4 GB のメモリ容量を利用でき、しかも確保可能であるノードを選んでから、その上にサービス実行するようなスケジューリングが行われます。
@z

@x
  ```console
  $ docker service create --reserve-memory=4GB --name=too-big nginx:alpine
  ```
@y
  ```console
  $ docker service create --reserve-memory=4GB --name=too-big nginx:alpine
  ```
@z

@x
  The managers won't schedule a set of containers on a single node whose combined
  reservations exceed the memory available on that node.
@y
  1 つのノードに対してメモリ容量の確保が複数求められる場合に、その合計がそのノードでの利用可能容量を超える場合は、マネージャーノードはコンテナーのスケジューリングを行いません。
@z

@x
  After a task is scheduled and running, `--reserve-memory` does not enforce a
  memory limit. Use `--limit-memory` to ensure that a task uses no more than a
  given amount of memory on a node. This example limits the amount of memory used
  by the task to 4GB. The task will be scheduled even if each of your nodes has
  only 2GB of memory, because `--limit-memory` is an upper limit.
@y
  タスクがスケジュールされ実行された後は、`--reserve-memory`はメモリ利用を制限しません。
  ノード上において、指定容量以上のメモリをタスクが利用しないようにするには`--limit-memory`を用います。
  以下の例では、タスクが利用できる容量を 4 GB に制限します。
  この場合に、ノードがたとえば 2 GB しかメモリを持っていなくても、タスクはスケジューリングされます。
  `--limit-memory`は上限を制限するだけのものであるからです。
@z

@x
  ```console
  $ docker service create --limit-memory=4GB --name=too-big nginx:alpine
  ```
@y
  ```console
  $ docker service create --limit-memory=4GB --name=too-big nginx:alpine
  ```
@z

@x
  Using `--reserve-memory` and `--limit-memory` does not guarantee that Docker
  will not use more memory on your host than you want. For instance, you could
  create many services, the sum of whose memory usage could exhaust the available
  memory.
@y
  `--reserve-memory`および`--limit-memory`を利用するにあたって、ホスト上のメモリ容量を超えた指定が行われても、ホスト容量内に抑えるような動作保証はありません。
  サービスはいくらでも生成可能であり、それが利用するメモリの総量は、いくらでも利用可能メモリを消費していきます。
@z

@x
  You can prevent this scenario from exhausting the available memory by taking
  into account other (non-containerized) software running on the host as well. If
  `--reserve-memory` is greater than or equal to `--limit-memory`, Docker won't
  schedule a service on a host that doesn't have enough memory. `--limit-memory`
  will limit the service's memory to stay within that limit, so if every service
  has a memory-reservation and limit set, Docker services will be less likely to
  saturate the host. Other non-service containers or applications running directly
  on the Docker host could still exhaust memory.
@y
  利用可能なメモリが際限なく消費されてしまうこの状況は、ホスト上に動作する別の（コンテナー化アプリ以外の）ソフトウェアに対しても考慮することが必要です。
  `--reserve-memory`の値が`--limit-memory`の値よりも大きいか等しい場合、十分なメモリを有していないホストへのサービスのスケジューリングは行われません。
  `--limit-memory`はサービスのメモリ使用量をその制限以内に収めます。
  したがってサービスのすべてにおいてメモリ予約やメモリ制限を設けていれば、Docker サービスがホストのメモリを消費し尽くすことを抑えられます。
  ただしサービス以外のコンテナーやアプリケーションが Docker ホスト上で直接実行されている場合は、メモリを浪費する可能性は残ります。
@z

@x
  There is a downside to this approach. Reserving memory also means that you may
  not make optimum use of the memory available on the node. Consider a service
  that under normal circumstances uses 100MB of memory, but depending on load can
  "peak" at 500MB. Reserving 500MB for that service (to guarantee can have 500MB
  for those "peaks") results in 400MB of memory being wasted most of the time.
@y
  ただしこの方法には欠点があります。
  メモリ予約をするということは、そのノードにおいて利用可能なメモリを的確に利用しないことにもつながりかねません。
  たとえば今、あるサービスが通常は 100 MB のメモリを利用するものとして、負荷次第ではピーク時に 500 MB まで利用するものがあったとします。
  このサービスのメモリ予約量を 500 MB とする（そのピーク時の 500 MB を確保する）ことは、つまりほとんどのタイミングにおいて 400 MB を利用することなく無駄使いすることになります。
@z

@x
  In short, you can take a more conservative or more flexible approach:
@y
  そこでもっと手堅く柔軟な方法をとることができます。
@z

@x
  - **Conservative**: reserve 500MB, and limit to 500MB. Basically you're now
    treating the service containers as VMs, and you may be losing a big advantage
    containers, which is greater density of services per host.
@y
  - **手堅い方法** ＝ 500 MB を予約した上で上限を 500 MB とします。
    ただしそもそもがサービスコンテナーを VM として利用することになるため、本来ならホストにおいて高密度にサービス処理が行われるはずなのに、その最大の利点を失うことになります。
@z

@x
  - **Flexible**: limit to 500MB in the assumption that if the service requires
    more than 500MB, it is malfunctioning. Reserve something between the 100MB
    "normal" requirement and the 500MB "peak" requirement". This assumes that when
    this service is at "peak", other services or non-container workloads probably
    won't be.
@y
  - **柔軟な方法** ＝ サービスが 500 MB 以上を必要とすることがわかっていて、利用制限を 500 MB にしてしまうと破綻します。
    「通常」時が 100 MB で「ピーク」時が 500 MB であるならば、その間の値を予約します。
    ただしサービスが「ピーク」時にあるときには、別のサービスまたはコンテナー以外の処理はピークに達しないことが前提です。
@z

@x
  The approach you take depends heavily on the memory-usage patterns of your
  workloads. You should test under normal and peak conditions before settling
  on an approach.
@y
  採用すべき手法は、何よりもメモリ利用状況がどのようなものであるかによって変わります。
  手法を定めるためには、通常時、ピーク時の状況を十分にテストすることが必要です。
@z

@x
  On Linux, you can also limit a service's overall memory footprint on a given
  host at the level of the host operating system, using `cgroups` or other
  relevant operating system tools.
@y
  Linux においては、指定するホスト上においてサービスによるメモリーフットプリント（memory footprint）総量を制限することもできます。
  これはオペレーティングシステムのレベルにおいて、`cgroups`かあるいはこれに相当するシステムツールを利用して行います。
@z

@x
  ### Specify maximum replicas per node (--replicas-max-per-node)
@y
  {: #specify-maximum-replicas-per-node---replicas-max-per-node }
  ### ノードごとの最大レプリカ数の指定（--replicas-max-per-node）
@z

@x
  Use the `--replicas-max-per-node` flag to set the maximum number of replica tasks that can run on a node.
  The following command creates a nginx service with 2 replica tasks but only one replica task per node.
@y
  `--replicas-max-per-node`フラグを使えば、ノード上において実行するレプリカの最大数を指定できます。
  以下のコマンドは 2 つのレプリカからなる nginx サービスを生成しますが、各ノードには 1 つのレプリカしか割り振らないようにします。
@z

@x
  One example where this can be useful is to balance tasks over a set of data centers together with `--placement-pref`
  and let `--replicas-max-per-node` setting make sure that replicas are not migrated to another datacenter during
  maintenance or datacenter failure.
@y
  これが有用となる例としては`--placement-pref`との併用により、複数のデータセンター間においてタスクをバランスよく割り振ることが考えられます。
  `--replicas-max-per-node`を設定することによって、1 つのデータセンターのメンテナンスや障害が発生しても、レプリカをそこに割り振らないようにできます。
@z

@x
  The example below illustrates this:
@y
  以下の例はこれを実現するものです。
@z

@x
  ```console
  $ docker service create \
    --name nginx \
    --replicas 2 \
    --replicas-max-per-node 1 \
    --placement-pref 'spread=node.labels.datacenter' \
    nginx
  ```
@y
  ```console
  $ docker service create \
    --name nginx \
    --replicas 2 \
    --replicas-max-per-node 1 \
    --placement-pref 'spread=node.labels.datacenter' \
    nginx
  ```
@z

@x
  ### Attach a service to an existing network (--network)
@y
  {: #attach-a-service-to-an-existing-network---network }
  ### 既存ネットワークへのサービスの割り当て（--network）
@z

@x
  You can use overlay networks to connect one or more services within the swarm.
@y
  Swarm 内においてはオーバーレイネットワークを使って、複数のサービスを接続することができます。
@z

@x
  First, create an overlay network on a manager node the docker network create
  command:
@y
  まずはマネージャーノード上において、`docker network create`コマンドを使ってオーバーレイネットワークを生成します。
@z

@x
  ```console
  $ docker network create --driver overlay my-network

  etjpu59cykrptrgw0z0hk5snf
  ```
@y
  ```console
  $ docker network create --driver overlay my-network

  etjpu59cykrptrgw0z0hk5snf
  ```
@z

@x
  After you create an overlay network in swarm mode, all manager nodes have
  access to the network.
@y
  Swarm モード内にオーバーレイネットワークを生成した後は、すべてのマネージャーノードがネットワークにアクセスできるようになります。
@z

@x
  When you create a service and pass the `--network` flag to attach the service to
  the overlay network:
@y
  サービスを生成する際には`--network`フラグを使って、サービスをオーバーレイネットワークに接続します。
@z

@x
  ```console
  $ docker service create \
    --replicas 3 \
    --network my-network \
    --name my-web \
    nginx

  716thylsndqma81j6kkkb5aus
  ```
@y
  ```console
  $ docker service create \
    --replicas 3 \
    --network my-network \
    --name my-web \
    nginx

  716thylsndqma81j6kkkb5aus
  ```
@z

@x
  The swarm extends my-network to each node running the service.
@y
  Swarm においては、サービスを実行している各ノードに向けて my-network が拡散されます。
@z

@x
  Containers on the same network can access each other using
  [service discovery](https://docs.docker.com/network/overlay/#container-discovery).
@y
  同一のネットワーク上にあるコンテナーであれば、[サービス検出](__HOSTURL__/network/overlay/#container-discovery) 機能を使って互いにアクセスすることができます。
@z

@x
  Long form syntax of `--network` allows to specify list of aliases and driver options:
  `--network name=my-network,alias=web1,driver-opt=field1=value1`
@y
  `--network`フラグにおいて長い文法を用いると、エイリアスやドライバーオプションをリストにより指定できます。
  たとえば`--network name=my-network,alias=web1,driver-opt=field1=value1`とします。
@z

@x
  ### Publish service ports externally to the swarm (-p, --publish)
@y
  {: #publish-service-ports-externally-to-the-swarm--p---publish }
  ### Swarm 外部へのサービスポートの公開（-p、--publish）
@z

@x
  You can publish service ports to make them available externally to the swarm
  using the `--publish` flag. The `--publish` flag can take two different styles
  of arguments. The short version is positional, and allows you to specify the
  published port and target port separated by a colon (`:`).
@y
  サービスポートを公開するには`--publish`フラグを用います。
  これにより Swarm の外部からサービスへのアクセスが可能になります。
  `--publish`フラグでは、引数に関して 2 通りの文法があります。
  短い文法では引数の位置に意味があり、公開ポートとターゲットポートをコロン（`:`）で区切って指定します。
@z

@x
  ```console
  $ docker service create --name my_web --replicas 3 --publish 8080:80 nginx
  ```
@y
  ```console
  $ docker service create --name my_web --replicas 3 --publish 8080:80 nginx
  ```
@z

@x
  There is also a long format, which is easier to read and allows you to specify
  more options. The long format is preferred. You cannot specify the service's
  mode when using the short format. Here is an example of using the long format
  for the same service as above:
@y
  長い文法による指定もあり、この方がわかりやすく、また多くのオプションを指定できます。
  推奨されているのは長い文法の利用です。
  なお短い文法を使った場合には、サービスモードを指定することはできません。
  上のコマンドと同一のことを、長い文法を使って実行したのが以下の例です。
@z

@x
  ```console
  $ docker service create --name my_web --replicas 3 --publish published=8080,target=80 nginx
  ```
@y
  ```console
  $ docker service create --name my_web --replicas 3 --publish published=8080,target=80 nginx
  ```
@z

@x
  The options you can specify are:
@y
  オプションとして指定できるものは以下のとおりです。
@z

@x
  <table>
  <thead>
  <tr>
    <th>Option</th>
    <th>Short syntax</th>
    <th>Long syntax</th>
    <th>Description</th>
  </tr>
  </thead>
@y
  <table>
  <thead>
  <tr>
    <th>オプション</th>
    <th>短い文法</th>
    <th>長い文法</th>
    <th>内容説明</th>
  </tr>
  </thead>
@z

@x
  <tr>
    <td>published and target port</td>
    <td><tt>--publish 8080:80</tt></td>
    <td><tt>--publish published=8080,target=80</tt></td>
    <td><p>
      The target port within the container and the port to map it to on the
      nodes, using the routing mesh (<tt>ingress</tt>) or host-level networking.
      More options are available, later in this table. The key-value syntax is
      preferred, because it is somewhat self-documenting.
    </p></td>
  </tr>
@y
  <tr>
    <td>公開ポートとターゲットポート</td>
    <td><tt>--publish 8080:80</tt></td>
    <td><tt>--publish published=8080,target=80</tt></td>
    <td><p>
      コンテナー内のターゲット（target）ポートとノード内でそこにマッピングされるポート。
      ここにはルーティングメッシュ（<tt>ingress</tt>）またはホストレベルのネットワークが用いられます。
      これ以外のオプションも利用可能であり本表以降に示します。
      キーバリュー形式の文法は説明的であり、これが推奨されます。
    </p></td>
  </tr>
@z

@x
  <tr>
    <td>mode</td>
    <td>Not possible to set using short syntax.</td>
    <td><tt>--publish published=8080,target=80,mode=host</tt></td>
    <td><p>
      The mode to use for binding the port, either <tt>ingress</tt> or <tt>host</tt>.
      Defaults to <tt>ingress</tt> to use the routing mesh.
    </p></td>
  </tr>
@y
  <tr>
    <td>モード</td>
    <td>短い文法では設定不可</td>
    <td><tt>--publish published=8080,target=80,mode=host</tt></td>
    <td><p>
      ポートをバインドする際に用いるモード。
      <tt>ingress</tt> または <tt>host</tt> のいずれか。
      デフォルトは <tt>ingress</tt> でありルーティングメッシュを利用します。
    </p></td>
  </tr>
@z

@x
  <tr>
    <td>protocol</td>
    <td><tt>--publish 8080:80/tcp</tt></td>
    <td><tt>--publish published=8080,target=80,protocol=tcp</tt></td>
    <td><p>
      The protocol to use, <tt>tcp</tt> , <tt>udp</tt>, or <tt>sctp</tt>. Defaults to
      <tt>tcp</tt>. To bind a port for both protocols, specify the <tt>-p</tt> or
      <tt>--publish</tt> flag twice.
    </p></td>
  </tr>
  </table>
@y
  <tr>
    <td>プロトコル</td>
    <td><tt>--publish 8080:80/tcp</tt></td>
    <td><tt>--publish published=8080,target=80,protocol=tcp</tt></td>
    <td><p>
      利用プロトコル。
      <tt>tcp</tt>、<tt>udp</tt>、<tt>sctp</tt> のいずれか。
      デフォルトは <tt>tcp</tt>。
      2 つのプロトコルにポートをバインドする場合は <tt>-p</tt> または <tt>--publish</tt> フラグを 2 つ指定します。
    </p></td>
  </tr>
  </table>
@z

@x
  When you publish a service port using `ingress` mode, the swarm routing mesh
  makes the service accessible at the published port on every node regardless if
  there is a task for the service running on the node. If you use `host` mode,
  the port is only bound on nodes where the service is running, and a given port
  on a node can only be bound once. You can only set the publication mode using
  the long syntax. For more information refer to
  [Use swarm mode routing mesh](https://docs.docker.com/engine/swarm/ingress/).
@y
  `ingress`モードを利用してサービスポートを公開する場合、Swarm のルーティングメッシュが機能するため、ノード上にサービスタスクが起動しているかどうかに関係なく、サービスから全ノードへのアクセスは公開ポートを通じて可能になります。
  `host`モードを利用する場合は、サービスが実行されているノードに対してのみポートがバインドされます。
  また 1 つのノード上において指定されるポートのみが 1 度だけバインドされます。
  公開モードは長い文法を使った場合にの設定可能です。
  詳しくは [Swarm モードにおけるルーティングメッシュの利用](__HOSTURL__/engine/swarm/ingress/) を参照してください。
@z

@x
  ### Provide credential specs for managed service accounts (Windows only)
@y
  {: #provide-credential-specs-for-managed-service-accounts-windows-only }
  ### 管理サービスアカウントに対する資格情報スペックの提供（Windows のみ）
@z

@x
  This option is only used for services using Windows containers. The
  `--credential-spec` must be in the format `file://<filename>` or
  `registry://<value-name>`.
@y
  このオプションは Windows コンテナーを利用するサービスに対してのみ利用可能です。
  `--credential-spec`オプションは`file://<filename>`あるいは`registry://<value-name>`という書式でなければなりません。
@z

@x
  When using the `file://<filename>` format, the referenced file must be
  present in the `CredentialSpecs` subdirectory in the docker data directory,
  which defaults to `C:\ProgramData\Docker\` on Windows. For example,
  specifying `file://spec.json` loads `C:\ProgramData\Docker\CredentialSpecs\spec.json`.
@y
  書式として`file://<filename>`を用いた場合、参照するファイルは Docker データディレクトリ配下のサブディレクトリ`CredentialSpecs`に存在している必要があります。
  データディレクトリはデフォルトでは`C:\ProgramData\Docker\`です。
  たとえば`file://spec.json`と指定した場合、`C:\ProgramData\Docker\CredentialSpecs\spec.json`を読み込むことになります。
@z

@x
  When using the `registry://<value-name>` format, the credential spec is
  read from the Windows registry on the daemon's host. The specified
  registry value must be located in:
@y
  書式として`registry://<value-name>`を用いた場合、資格情報スペック（credential spec）はデーモンホストの Windows レジストリから読み込まれます。
  指定するレジストリ値は、以下に存在していなければなりません。
@z

@x
      HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers\CredentialSpecs
@y
      HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers\CredentialSpecs
@z

@x
  ### Create services using templates
@y
  {: #create-services-using-templates }
  ### テンプレートを使ったサービスの生成
@z

@x
  You can use templates for some flags of `service create`, using the syntax
  provided by the Go's [text/template](http://golang.org/pkg/text/template/) package.
@y
  `service create`コマンドにおけるフラグの中には、テンプレートを利用できるものがあります。
  その際には Go 言語の [text/template](http://golang.org/pkg/text/template/) パッケージによって提供される文法を利用します。
@z

@x
  The supported flags are the following :
@y
  サポートされるフラグは以下です。
@z

@x
  - `--hostname`
  - `--mount`
  - `--env`
@y
  - `--hostname`
  - `--mount`
  - `--env`
@z

@x
  Valid placeholders for the Go template are listed below:
@y
  Go 言語テンプレートによる記述書式は以下のとおりです。
@z

@x
  <table>
    <tr>
      <th>Placeholder</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><tt>.Service.ID</tt></td>
      <td>Service ID</td>
    </tr>
    <tr>
      <td><tt>.Service.Name</tt></td>
      <td>Service name</td>
    </tr>
    <tr>
      <td><tt>.Service.Labels</tt></td>
      <td>Service labels</td>
    </tr>
    <tr>
      <td><tt>.Node.ID</tt></td>
      <td>Node ID</td>
    </tr>
    <tr>
      <td><tt>.Node.Hostname</tt></td>
      <td>Node Hostname</td>
    </tr>
    <tr>
      <td><tt>.Task.ID</tt></td>
      <td>Task ID</td>
    </tr>
    <tr>
      <td><tt>.Task.Name</tt></td>
      <td>Task name</td>
    </tr>
    <tr>
      <td><tt>.Task.Slot</tt></td>
      <td>Task slot</td>
    </tr>
  </table>
@y
  <table>
    <tr>
      <th>プレースホルダー</th>
      <th>内容説明</th>
    </tr>
    <tr>
      <td><tt>.Service.ID</tt></td>
      <td>サービス ID</td>
    </tr>
    <tr>
      <td><tt>.Service.Name</tt></td>
      <td>サービス名</td>
    </tr>
    <tr>
      <td><tt>.Service.Labels</tt></td>
      <td>サービスラベル</td>
    </tr>
    <tr>
      <td><tt>.Node.ID</tt></td>
      <td>ノード ID</td>
    </tr>
    <tr>
      <td><tt>.Node.Hostname</tt></td>
      <td>ノードのホスト名</td>
    </tr>
    <tr>
      <td><tt>.Task.ID</tt></td>
      <td>タスク ID</td>
    </tr>
    <tr>
      <td><tt>.Task.Name</tt></td>
      <td>タスク名</td>
    </tr>
    <tr>
      <td><tt>.Task.Slot</tt></td>
      <td>タスクスロット</td>
    </tr>
  </table>
@z

@x
  #### Template example
@y
  {: #template-example }
  #### テンプレート例
@z

@x
  In this example, we are going to set the template of the created containers based on the
  service's name, the node's ID and hostname where it sits.
@y
  以下の例では、コンテナーのサービス名、ノード ID、コンテナーが配置されるホスト名を、テンプレートにより指定してこのコンテナーを生成します。
@z

@x
  ```console
  $ docker service create \
      --name hosttempl \
      --hostname="{{.Node.Hostname}}-{{.Node.ID}}-{{.Service.Name}}"\
      busybox top

  va8ew30grofhjoychbr6iot8c

  $ docker service ps va8ew30grofhjoychbr6iot8c

  ID            NAME         IMAGE                                                                                   NODE          DESIRED STATE  CURRENT STATE               ERROR  PORTS
  wo41w8hg8qan  hosttempl.1  busybox:latest@sha256:29f5d56d12684887bdfa50dcd29fc31eea4aaf4ad3bec43daf19026a7ce69912  2e7a8a9c4da2  Running        Running about a minute ago

  $ docker inspect --format="{{.Config.Hostname}}" 2e7a8a9c4da2-wo41w8hg8qanxwjwsg4kxpprj-hosttempl

  x3ti0erg11rjpg64m75kej2mz-hosttempl
  ```
@y
  ```console
  $ docker service create \
      --name hosttempl \
      --hostname="{{.Node.Hostname}}-{{.Node.ID}}-{{.Service.Name}}"\
      busybox top

  va8ew30grofhjoychbr6iot8c

  $ docker service ps va8ew30grofhjoychbr6iot8c

  ID            NAME         IMAGE                                                                                   NODE          DESIRED STATE  CURRENT STATE               ERROR  PORTS
  wo41w8hg8qan  hosttempl.1  busybox:latest@sha256:29f5d56d12684887bdfa50dcd29fc31eea4aaf4ad3bec43daf19026a7ce69912  2e7a8a9c4da2  Running        Running about a minute ago

  $ docker inspect --format="{{.Config.Hostname}}" 2e7a8a9c4da2-wo41w8hg8qanxwjwsg4kxpprj-hosttempl

  x3ti0erg11rjpg64m75kej2mz-hosttempl
  ```
@z

@x
  ### Specify isolation mode (Windows)
@y
  {: #specify-isolation-mode-windows }
  ### 分離モードの設定 (Windows)
@z

@x
  By default, tasks scheduled on Windows nodes are run using the default isolation mode
  configured for this particular node. To force a specific isolation mode, you can use
  the `--isolation` flag:
@y
  Windows ノードにスケジュールされたタスクは、このノード専用に設定されたデフォルトの分離モード（isolation mode）を使って実行されます。
  特定の分離モードを指定するには`--isolation`フラグを利用します。
@z

@x
  ```console
  $ docker service create --name myservice --isolation=process microsoft/nanoserver
  ```
@y
  ```console
  $ docker service create --name myservice --isolation=process microsoft/nanoserver
  ```
@z

@x
  Supported isolation modes on Windows are:
@y
  Windows 上の分離モードとしてサポートされるのは以下です。
@z

@x
  - `default`: use default settings specified on the node running the task
  - `process`: use process isolation (Windows server only)
  - `hyperv`: use Hyper-V isolation
@y
  - `default`: タスクが実行されるノードに固有となるデフォルトモード。
  - `process`: プロセス分離モードを利用します（Windows サーバーのみ）。
  - `hyperv`: Hyper-V 分離モードを利用します。
@z

@x
  ### Create services requesting Generic Resources
@y
  {: #create-services-requesting-generic-resources }
  ### ジェネリックリソースを利用するサービスの生成
@z

@x
  You can narrow the kind of nodes your task can land on through the using the
  `--generic-resource` flag (if the nodes advertise these resources):
@y
  `--generic-resource`フラグを利用すると、タスクが到達できるノードの種類を限定することができます（ノードがそのジェネリックリソース（generic resources）を公開している場合）。
@z

@x
  ```console
  $ docker service create \
      --name cuda \
      --generic-resource "NVIDIA-GPU=2" \
      --generic-resource "SSD=1" \
      nvidia/cuda
  ```
@y
  ```console
  $ docker service create \
      --name cuda \
      --generic-resource "NVIDIA-GPU=2" \
      --generic-resource "SSD=1" \
      nvidia/cuda
  ```
@z

@x
  ### Running as a job
@y
  {: #running-as-a-job }
  ### ジョブとしての実行
@z

@x
  Jobs are a special kind of service designed to run an operation to completion
  and then stop, as opposed to running long-running daemons. When a Task
  belonging to a job exits successfully (return value 0), the Task is marked as
  "Completed", and is not run again.
@y
  デーモンといえば長時間実行されるものですが、これとは違ってジョブというものは、操作を完了したらその後に停止するように設計されている特別なサービスのことです。
  ジョブに属しているタスクが正常終了する（戻り値 0 を返す）と、そのタスクは「Completed」（完了）とマークがつけられ、再度実行されることはありません。
@z

@x
  Jobs are started by using one of two modes, `replicated-job` or `global-job`
@y
  ジョブは 2 つのモード、つまり`replicated-job`または`global-job`を使って起動されます。
@z

@x
  ```console
  $ docker service create --name myjob \
                          --mode replicated-job \
                          bash "true"
  ```
@y
  ```console
  $ docker service create --name myjob \
                          --mode replicated-job \
                          bash "true"
  ```
@z

@x
  This command will run one Task, which will, using the `bash` image, execute the
  command `true`, which will return 0 and then exit.
@y
  上のコマンドは 1 つのタスクを実行します。
  これは`bash`イメージを用いてコマンド`true`を実行し、戻り値 0 を返して終了します。
@z

@x
  Though Jobs are ultimately a different kind of service, they a couple of
  caveats compared to other services:
@y
  ジョブは極めて特殊なサービスであるため、通常のサービスに比べて以下のような注意点があります。
@z

@x
  - None of the update or rollback configuration options are valid.  Jobs can be
    updated, but cannot be rolled out or rolled back, making these configuration
    options moot.
  - Jobs are never restarted on reaching the `Complete` state. This means that
    for jobs, setting `--restart-condition` to `any` is the same as setting it to
    `on-failure`.
@y
  - 更新設定やロールバック設定を行うオプションは、どれも無効になります。
    ジョブそのものは更新可能ですが、ロールアウトやロールバックができないため、そのようなオプションは設定できません。
  - ジョブが「Complete」（完了）状態に達した後は再起動できません。
    これはつまりジョブにおいて`--restart-condition`を`any`に設定することは`on-failure`を設定することと同じになります。
@z

@x
  Jobs are available in both replicated and global modes.
@y
  ジョブはレプリカされた（replicated）モード、およびグローバルモードのいずれでも利用できます。
@z

@x
  #### Replicated Jobs
@y
  {: #replicated-jobs }
  #### レプリカされたモード
@z

@x
  A replicated job is like a replicated service. Setting the `--replicas` flag
  will specify total number of iterations of a job to execute.
@y
  レプリカされた（replicated）ジョブとは、レプリカされたサービスに似ています。
  `--replicas`フラグでは、ジョブを実行したい繰り返し数を指定します。
@z

@x
  By default, all replicas of a replicated job will launch at once. To control
  the total number of replicas that are executing simultaneously at any one time,
  the `--max-concurrent` flag can be used:
@y
  レプリカされたジョブの各レプリカは、デフォルトでそれぞれ 1 回だけ実行されます。
  同タイミングでレプリカを複数実行したい場合は、その数を`--max-concurrent`フラグに指定します。
@z

@x
  ```console
  $ docker service create \
      --name mythrottledjob \
      --mode replicated-job \
      --replicas 10 \
      --max-concurrent 2 \
      bash "true"
  ```
@y
  ```console
  $ docker service create \
      --name mythrottledjob \
      --mode replicated-job \
      --replicas 10 \
      --max-concurrent 2 \
      bash "true"
  ```
@z

@x
  The above command will execute 10 Tasks in total, but only 2 of them will be
  run at any given time.
@y
  上のコマンドでは合計で 10 個のタスクが実行されます。
  ただしどのタイミングにおいても、同時に実行されるのは 2 つだけです。
@z

@x
  #### Global Jobs
@y
  {: #global-jobs }
  #### グローバルジョブ
@z

@x
  Global jobs are like global services, in that a Task is executed once on each node
  matching placement constraints. Global jobs are represented by the mode `global-job`.
@y
  グローバルジョブはグローバルサービスに似ています。
  配置制約（placement constraints）に合致するノード上において、タスクが 1 度だけ実行されます。
  グローバルジョブは、`global-job`モードによって表現されます。
@z

@x
  Note that after a Global job is created, any new Nodes added to the cluster
  will have a Task from that job started on them. The Global Job does not as a
  whole have a "done" state, except insofar as every Node meeting the job's
  constraints has a Completed task.
@y
  なおグローバルジョブが生成された後に、新たにクラスターにノードが追加されると、このジョブに対応するタスクが起動される点に注意してください。
  グローバルジョブは「done」（完了）という状態になることはありません。
  ただし、ジョブの制約を満たすすべてのノードが、完了タスクを有する状態はありえます。
@z

@x
deprecated: false
min_api_version: "1.24"
experimental: false
experimentalcli: false
kubernetes: false
swarm: true
@y
deprecated: false
min_api_version: "1.24"
experimental: false
experimentalcli: false
kubernetes: false
swarm: true
@z
