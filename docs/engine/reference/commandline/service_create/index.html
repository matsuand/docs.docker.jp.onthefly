<!DOCTYPE html>
<!-- Page generated 2022-04-25 09:39:05 +0900-->
<html lang="ja"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>docker service create | Docker ドキュメント</title>
  <meta name="description" content="docker service create: 指定されたパラメーターに従ってサービスを生成します。

&gt; **メモ**
&gt;
&gt; これはクラスター管理コマンドです。
&gt; したがって Swarm 上のマネージャーノードにおいて実行する必要があります。
&gt; マネージャーノードやワーカーノードについては、[Swarm モード](https://matsuand.github.io/docs.docker.jp.onthefly/engine/swarm/) を参照してください。" />
  <meta name="keywords" content="docker, docker open source, docker platform, distributed applications, microservices, containers, docker containers, docker software, docker virtualization">
  <link rel="canonical" href="https://localhost:4000{{ site.baseurl }}/engine/reference/commandline/service_create/" />

  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
  <link rel="apple-touch-icon" type="image/x-icon" href="/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
  <meta name="msapplication-TileImage" content="/docs.docker.jp.onthefly/favicons/docs@2x.ico">
  <meta property="og:image" content="/docs.docker.jp.onthefly/favicons/docs@2x.ico"/>
  <meta name="theme-color" content="#2496ed" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- hide elements that are only shown without JavaScript enabled -->
  <script>document.documentElement.classList.add('js')</script>
  <style>html.js .no-js { display: none !important; }</style><script defer src="/docs.docker.jp.onthefly/js/theme-switcher.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/anchorlinks.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/jquery.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/bootstrap.min.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/docs.js"></script><script defer src="/docs.docker.jp.onthefly/js/search.js"></script><link rel="preload" as="font" href="https://fonts.gstatic.com/s/opensans/v18/mem8YaGs126MiZpBA-UFVZ0bf8pkAg.woff2" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/geomanist/hinted-Geomanist-Book.woff2"    type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/geomanist/hinted-Geomanist-Regular.woff2" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/glyphicons-halflings-regular.woff2"       type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/fontawesome-webfont.woff2?v=4.7.0"        type="font/woff2" crossorigin="anonymous">

  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/font-awesome.min.css">
  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/bootstrap.min.css">
  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/style.css" id="pagestyle">

  <!-- SEO stuff -->
  <meta name="twitter:title" itemprop="title name" content="docker service create"/>
  <meta name="twitter:description" property="og:description" itemprop="description" content="docker service create: 指定されたパラメーターに従ってサービスを生成します。

&gt; **メモ**
&gt;
&gt; これはクラスター管理コマンドです。
&gt; したがって Swarm 上のマネージャーノードにおいて実行する必要があります。
&gt; マネージャーノードやワーカーノードについては、[Swarm モード](https://matsuand.github.io/docs.docker.jp.onthefly/engine/swarm/) を参照してください。" />
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:domain" content="matsuand.github.io"/>
  <meta name="twitter:site" content="@docker_docs"/>
  <meta name="twitter:url" content="https://twitter.com/docker_docs"/>
  <meta name="twitter:image:src" content="/docs.docker.jp.onthefly/images/docs@2x.png"/>
  <meta name="twitter:image:alt" content="Docker ドキュメント"/>
  <meta property="og:title" content="docker service create" />
  <meta property="og:description" content="docker service create: 指定されたパラメーターに従ってサービスを生成します。

&gt; **メモ**
&gt;
&gt; これはクラスター管理コマンドです。
&gt; したがって Swarm 上のマネージャーノードにおいて実行する必要があります。
&gt; マネージャーノードやワーカーノードについては、[Swarm モード](https://matsuand.github.io/docs.docker.jp.onthefly/engine/swarm/) を参照してください。" />
  <meta property="og:type" content="website"/>
  <meta property="og:updated_time" itemprop="dateUpdated" content="2022-04-25T09:39:05+09:00"/>
  <meta property="og:image" itemprop="image primaryImageOfPage" content="/docs.docker.jp.onthefly/images/docs@2x.png"/>
  <meta property="og:locale" content="ja_JP" />
  <meta property="og:url" content="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/commandline/service_create/" />
  <meta property="og:site_name" content="Docker ドキュメント" />
  <meta property="article:published_time" itemprop="datePublished" content="2022-04-25T09:39:05+09:00"/>
  <script type="application/ld+json">{"@context":"https://schema.org","@type":"WebPage","headline":"docker service create","description":"docker service create: 指定されたパラメーターに従ってサービスを生成します。\n\n> **メモ**\n>\n> これはクラスター管理コマンドです。\n> したがって Swarm 上のマネージャーノードにおいて実行する必要があります。\n> マネージャーノードやワーカーノードについては、[Swarm モード](https://matsuand.github.io/docs.docker.jp.onthefly/engine/swarm/) を参照してください。","url":"https://docs.docker.com/engine/reference/commandline/service_create/"}</script>
  <!-- END SEO STUFF -->
</head>
<body class="colums">
    <header>
        <nav class="nav-secondary navbar navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header">
            <a href="/docs.docker.jp.onthefly/">
                <img class="logo" src="/docs.docker.jp.onthefly/images/docker-docs-logo.svg" alt="Docker Docs" title="Docker Docs" width="160" height="28" />
            </a>
        </div>
        <div class="navbar-collapse" aria-expanded="false" style="height: 1px;">
            <div class="logo-mobile">
    <a href="/docs.docker.jp.onthefly/">
        <img src="/docs.docker.jp.onthefly/images/docker-icon.svg" alt="Docker Docs" title="Docker Docs" width="30" height="30" />
    </a>
</div>
<div class="search-form" id="search-div">
    <form class="search-form form-inline" id="searchForm" action="/docs.docker.jp.onthefly/search/" method="get">
        <label for="st-search-input" class="sr-only">検索</label>
        <input class="search-field form-control ds-input" id="st-search-input" name="q" placeholder="文書内検索" type="search" autocomplete="off" spellcheck="false" dir="auto" style="position: relative; vertical-align: top;">
        <div id="autocompleteResults"></div>
        <!-- <button type="submit" class="search-submit btn btn-default">検索</button> -->
    </form>
</div>
<div class="sidebar-toggle">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
    </button>
</div>
<div class="nav-container hidden-sm hidden-xs">
    <div>
        <ul class="nav navbar-nav"><li><a href="/docs.docker.jp.onthefly/" id="home">ホーム</a></li><li><a href="/docs.docker.jp.onthefly/get-started/overview/" id="guides">ガイド</a></li><li><a href="/docs.docker.jp.onthefly/desktop/" id="manuals">マニュアル</a></li><li><a href="/docs.docker.jp.onthefly/reference/" id="reference">リファレンス</a></li><li><a href="/docs.docker.jp.onthefly/samples/" id="samples">サンプル</a></li></ul>
    </div>
    <div class="ctrl-right">
        <a href="javascript:void(0)" id="menu-toggle" aria-label="現在ページのメニュートグル"><i class="fa fa-indent" aria-hidden="true"></i></a>
    </div>
</div>
<div class="row hidden-sm hidden-xs">
    <nav aria-label="breadcrumb">
        <ol class="breadcrumb">
            <li><a href="/docs.docker.jp.onthefly/" title="Docker docs homepage"><i class="fa fa-home"></i></a></li>
            <li><a href="/docs.docker.jp.onthefly/reference/">リファレンス</a></li><li><a>コマンドラインインターフェイス</a></li><li><a href="/docs.docker.jp.onthefly/engine/reference/run/">Docker CLI (docker)</a></li><li><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service/">docker service</a></li><li><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service_create/">docker service create</a></li></ol>
    </nav>
</div></div>
    </div>
</nav>

    </header>
    <div class="wrapper right-open">
        <div class="container-fluid">
            <div class="row">
                <div class="col-body">
                    <main class="col-content content">
                        <section class="section"><h1>docker service create</h1><p><em class="reading-time">読む時間の目安: 20 分</em></p><!--
This page is automatically generated from Docker's source code. If you want to
suggest a change to the text that appears here, open a ticket or pull request
in the source repository on GitHub:

https://github.com/docker/cli
-->
<!-- Make sure atom is using hard tabs -->

<h2 id="description">説明</h2>

<p>新たなサービスを生成します。</p>

<p><a href="/docs.docker.jp.onthefly/engine/api/v1.24/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" data-placement="right" title="1.24 API リファレンスを開く (別ウィンドウ)">API 1.24 以上</span></a> 
このコマンドを利用するには、クライアントとデーモンの API はともに、最低でも
<a href="/docs.docker.jp.onthefly/engine/api/v1.24/" target="_blank" rel="noopener" class="_">1.24</a>
である必要があります。
クライアント上において<code class="highlighter-rouge">docker version</code>コマンドを実行して、クライアントとデーモンの API バージョンを確認してください。</p>

<p><span class="badge badge-info" data-toggle="tooltip" data-placement="right" title="このコマンドは Swarm オーケストレーターにおいて動作します。">Swarm</span> このコマンドは Swarm オーケストレーターにおいて動作します。</p>

<h2 id="usage">利用方法</h2>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="o">[</span>オプション] IMAGE <span class="o">[</span>COMMAND] <span class="o">[</span>ARG...]
</code></pre></div></div>

<h2 id="extended-description">追加説明</h2>

<p>指定されたパラメーターに従ってサービスを生成します。</p>

<blockquote>
  <p><strong>メモ</strong></p>

  <p>これはクラスター管理コマンドです。
したがって Swarm 上のマネージャーノードにおいて実行する必要があります。
マネージャーノードやワーカーノードについては、<a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/swarm/">Swarm モード</a> を参照してください。</p>
</blockquote>

<p>本コマンドの利用例については、以下に示す <a href="#examples">利用例の節</a> を参照してください。</p>

<h2 id="options">オプション</h2>

<table>
<thead>
  <tr>
    <td>名前／省略形</td>
    <td>デフォルト</td>
    <td>説明</td>
  </tr>
</thead>
<tbody>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--cap-add</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.41/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.41 以上</span></a><br />Linux ケーパビリティーを追加します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--cap-drop</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.41/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.41 以上</span></a><br />Linux ケーパビリティーを削除します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--config</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.30/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.30 以上</span></a><br />サービスに対して適用する設定を指定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--constraint</code></td>
    <td></td>
    <td>制約（constraint）を指定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--container-label</code></td>
    <td></td>
    <td>コンテナーラベルを指定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--credential-spec</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.29/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.29 以上</span></a><br />管理サービスアカウントに対する資格情報スペック（Credential spec）。（Windows のみ）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--detach</code> , <code class="highlighter-rouge">-d</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.29/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.29 以上</span></a><br />サービスの終了を待たずに即座に戻ります。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--dns</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />カスタム DNS サーバーを設定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--dns-option</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />DNS オプションを設定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--dns-search</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />カスタム DNS 検索ドメインを設定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--endpoint-mode</code></td>
    <td><code class="highlighter-rouge">vip</code></td>
    <td>Endpoint モードを設定します。(vip または dnsrr)</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--entrypoint</code></td>
    <td></td>
    <td>イメージのデフォルト ENTRYPOINT をオーバーライドします。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--env</code> , <code class="highlighter-rouge">-e</code></td>
    <td></td>
    <td>環境変数を設定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--env-file</code></td>
    <td></td>
    <td>環境変数ファイルを読み込みます。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--generic-resource</code></td>
    <td></td>
    <td>ユーザー定義リソースを設定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--group</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />コンテナーに対して必要な補助ユーザーグループを設定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--health-cmd</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />ヘルスチェックを実行するコマンド。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--health-interval</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />ヘルスチェックの実行間隔。(ms|s|m|h)</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--health-retries</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />不健康（unhealthy）であると報告するのに必要な連続失敗回数。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--health-start-period</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.29/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.29 以上</span></a><br />ヘルスチェックのリトライを数え始める前の、コンテナー初期化を行う開始時間。(ms|s|m|h)</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--health-timeout</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />1 つのチェック処理実行に許容する最大時間。(ms|s|m|h) （デフォルトは 0s）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--host</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />1 つまたは複数のカスタムホスト－IP 間マッピングを設定します。(host:ip)</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--hostname</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />コンテナーホスト名。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--init</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.37/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.37 以上</span></a><br />各サービスコンテナー内部にて、シグナル送信と子プロセス管理を行う初期化処理を実行します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--isolation</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.35/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.35 以上</span></a><br />サービスの分離技術（isolation technology）モード。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--label</code> , <code class="highlighter-rouge">-l</code></td>
    <td></td>
    <td>サービスラベル。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--limit-cpu</code></td>
    <td></td>
    <td>CPU 数を制限します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--limit-memory</code></td>
    <td></td>
    <td>メモリ容量を制限します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--limit-pids</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.41/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.41 以上</span></a><span class="badge badge-info" data-toggle="tooltip" title="This option works for the Swarm orchestrator.">Swarm</span><br />プロセスの最大数を制限します（デフォルトは 0 ＝ 無制限）。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--log-driver</code></td>
    <td></td>
    <td>サービスにおけるログドライバー。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--log-opt</code></td>
    <td></td>
    <td>ログドライバーオプション。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--max-concurrent</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.41/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.41 以上</span></a><br />同時に実行するジョブタスク数（デフォルトは --replicas に等しい）。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--mode</code></td>
    <td><code class="highlighter-rouge">replicated</code></td>
    <td>サービスモード（replicated、global、replicated-job、global-job）。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--mount</code></td>
    <td></td>
    <td>ファイルシステムマウントをサービスにアタッチします。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--name</code></td>
    <td></td>
    <td>サービス名。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--network</code></td>
    <td></td>
    <td>ネットワークアタッチ。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--no-healthcheck</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />コンテナー固有の HEALTHCHECK を無効にします。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--no-resolve-image</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.30/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.30 以上</span></a><br />レジストリに対してイメージダイジェスト値や対応プラットフォームを確認しません。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--placement-pref</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.28/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.28 以上</span></a><br />配置設定（placement preference）を追加します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--publish</code> , <code class="highlighter-rouge">-p</code></td>
    <td></td>
    <td>ノードのポートとしてポートを公開します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--quiet</code> , <code class="highlighter-rouge">-q</code></td>
    <td></td>
    <td>経過出力を省略します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--read-only</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.28/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.28 以上</span></a><br />コンテナーのルートファイルシステムを読み取り専用としてマウントします。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--replicas</code></td>
    <td></td>
    <td>タスク数。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--replicas-max-per-node</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.40/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.40 以上</span></a><br />ノード当たりの最大タスク数。(デフォルトは 0、つまり無制限)</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--reserve-cpu</code></td>
    <td></td>
    <td>CPU の予約数。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--reserve-memory</code></td>
    <td></td>
    <td>メモリの予約容量。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--restart-condition</code></td>
    <td></td>
    <td>条件を満たした際に再起動します。("none"|"on-failure"|"any") (デフォルトは "any")</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--restart-delay</code></td>
    <td></td>
    <td>再起動実施の遅延時間（ns|us|ms|s|m|h）。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--restart-max-attempts</code></td>
    <td></td>
    <td>再起動の最大リトライ回数。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--restart-window</code></td>
    <td></td>
    <td>再起動ポリシーの評価に利用されるウィンドウ（ns|us|ms|s|m|h）。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--rollback-delay</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.28/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.28 以上</span></a><br />タスクロールバック時の遅延時間（ns|us|ms|s|m|h）。（デフォルトは 0s）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--rollback-failure-action</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.28/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.28 以上</span></a><br />ロールバック失敗時の処理（「pause」|「continue」）。（デフォルトは「pause」）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--rollback-max-failure-ratio</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.28/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.28 以上</span></a><br />ロールバック時に許容される失敗率（デフォルトは 0）。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--rollback-monitor</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.28/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.28 以上</span></a><br />各タスクのロールバックが失敗しないかを監視する時間間隔（ns|us|ms|s|m|h）。（デフォルトは 5s）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--rollback-order</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.29/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.29 以上</span></a><br />ロールバック順。 (「start-first」|「stop-first」) (デフォルトは「stop-first」)</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--rollback-parallelism</code></td>
    <td><code class="highlighter-rouge">1</code></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.28/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.28 以上</span></a><br />同時にロールバックする最大タスク数（0 は全タスク同時）。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--secret</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />サービスに公開する Secret ファイル。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--stop-grace-period</code></td>
    <td></td>
    <td>強制的にコンテナーを kill する際の待機時間（ns|us|ms|s|m|h）。（デフォルトは 10s）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--stop-signal</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.28/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.28 以上</span></a><br />コンテナーを停止するためのシグナル。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--sysctl</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.40/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.40 以上</span></a><br />sysctl オプション。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--tty</code> , <code class="highlighter-rouge">-t</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />擬似 TTY を割り当てます。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--ulimit</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.41/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.41 以上</span></a><br />ulimit オプション。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--update-delay</code></td>
    <td></td>
    <td>更新間の遅延時間（ns|us|ms|s|m|h）。（デフォルトは 0s）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--update-failure-action</code></td>
    <td></td>
    <td>更新失敗時のアクション（「pause」|「continue」|「rollback」）。（デフォルトは「pause」）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--update-max-failure-ratio</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />更新時に許容される失敗率。（デフォルトは 0）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--update-monitor</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.25 以上</span></a><br />各タスクの更新が失敗しないかを監視する時間間隔（ns|us|ms|s|m|h）。（デフォルトは 5s）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--update-order</code></td>
    <td></td>
    <td><a href="/docs.docker.jp.onthefly/engine/api/v1.29/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle="1.24 API リファレンスを開きます。(別ウィンドウ)">API 1.29 以上</span></a><br />更新順（「start-first」|「stop-first」）。（デフォルトは「stop-first」）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--update-parallelism</code></td>
    <td><code class="highlighter-rouge">1</code></td>
    <td>同時に更新する最大タスク数（0 は全タスク同時）。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--user</code> , <code class="highlighter-rouge">-u</code></td>
    <td></td>
    <td>ユーザー名または UID。（記述書式: &lt;name|uid&gt;[:&lt;group|gid&gt;]）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--with-registry-auth</code></td>
    <td></td>
    <td>レジストリ認証情報の詳細を Swarm エージェントに送信します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="highlighter-rouge">--workdir</code> , <code class="highlighter-rouge">-w</code></td>
    <td></td>
    <td>コンテナー内部のワーキングディレクトリ。</td>
  </tr>
 <!-- end for option -->
</tbody>
</table>
<p><!-- end if options --></p>

<h2 id="examples">利用例</h2>

<h3 id="create-a-service">サービスの生成</h3>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span> redis redis:3.0.6
<span class="go">
dmu1ept4cxcfe8k8lhtux3ro3

</span><span class="gp">$</span> docker service create <span class="nt">--mode</span> global <span class="nt">--name</span> redis2 redis:3.0.6
<span class="go">
a8q9dasaafudfs8q8w32udass

</span><span class="gp">$</span> docker service <span class="nb">ls</span>
<span class="go">
ID            NAME    MODE        REPLICAS  IMAGE
dmu1ept4cxcf  redis   replicated  1/1       redis:3.0.6
a8q9dasaafud  redis2  global      1/1       redis:3.0.6
</span></code></pre></div></div>

<h4 id="create-a-service-using-an-image-on-a-private-registry">プライベートリポジトリ上のイメージを利用したサービス生成</h4>

<p>利用するイメージが、ログインを必要とするプライベートリポジトリ上にある場合は、ログインを済ませた後に、<code class="highlighter-rouge">docker service create</code>に<code class="highlighter-rouge">--with-registry-auth</code>フラグをつけて実行します。
プライベートリポジトリ<code class="highlighter-rouge">registry.example.com</code>にイメージがあるとすると、以下のようなコマンドを実行します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker login registry.example.com
<span class="go">
</span><span class="gp">$</span> docker service  create <span class="se">\</span>
  <span class="nt">--with-registry-auth</span> <span class="se">\</span>
  <span class="nt">--name</span> my_service <span class="se">\</span>
  registry.example.com/acme/my_image:latest
</code></pre></div></div>

<p>このコマンド実行によってローカルクライアントにあるログイントークンが、サービスがデプロイされている Swarm ノードに送信されます。
その際には暗号化された WAL ログが利用されます。
この情報に基づいて各ノードからのレジストリへのログインが可能となり、イメージのプルが行われます。</p>

<h3 id="create-a-service-with-5-replica-tasks---replicas">レプリカタスク 5 を指定したサービス生成 (--replicas)</h3>

<p><code class="highlighter-rouge">--replicas</code>フラグを使って、複製化されているサービスに対してのレプリカタスク数を設定します。
以下のコマンドはレプリカタスク数<code class="highlighter-rouge">5</code>の<code class="highlighter-rouge">redis</code>サービスを生成します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span> redis <span class="nt">--replicas</span><span class="o">=</span>5 redis:3.0.6
<span class="go">
4cdgfyky7ozwh3htjfw0d12qv
</span></code></pre></div></div>

<p>上のコマンドでは、サービスに対して <strong>期待する</strong> タスク数を設定しています。
コマンドからの応答がすぐに返ってきても、実際にサービスがスケーリングするには多少の時間を要します。
<code class="highlighter-rouge">REPLICAS</code>欄には、サービスにおけるレプリカタスクの <strong>実際の数</strong> と <strong>期待する数</strong> がともに示されます。</p>

<p>以下の例では、期待するレプリカ数が<code class="highlighter-rouge">5</code>と示されていますが、<code class="highlighter-rouge">RUNNING</code>（実行中）タスク数は<code class="highlighter-rouge">3</code>となっています。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service <span class="nb">ls</span>
<span class="go">
ID            NAME   MODE        REPLICAS  IMAGE
4cdgfyky7ozw  redis  replicated  3/5       redis:3.0.7
</span></code></pre></div></div>

<p>すべてのタスクが生成され実行されると、実際のタスク数と期待されているタスク数が一致します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service <span class="nb">ls</span>
<span class="go">
ID            NAME   MODE        REPLICAS  IMAGE
4cdgfyky7ozw  redis  replicated  5/5       redis:3.0.7
</span></code></pre></div></div>

<h3 id="create-a-service-with-secrets">Secret を使ったサービス生成</h3>

<p><code class="highlighter-rouge">--secret</code>フラグの指定により、コンテナーに対して <a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/commandline/secret_create/">Secret</a>（機密情報）へのアクセスを許可します。</p>

<p>以下では Secret を指定してサービスを生成します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span> redis <span class="nt">--secret</span> secret.json redis:3.0.6
<span class="go">
4cdgfyky7ozwh3htjfw0d12qv
</span></code></pre></div></div>

<p>以下では Secret、ターゲット、ユーザーおよびグループ ID、モードを指定してサービスを生成します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span> redis <span class="se">\</span>
    <span class="nt">--secret</span> <span class="nb">source</span><span class="o">=</span>ssh-key,target<span class="o">=</span>ssh <span class="se">\</span>
    <span class="nt">--secret</span> <span class="nb">source</span><span class="o">=</span>app-key,target<span class="o">=</span>app,uid<span class="o">=</span>1000,gid<span class="o">=</span>1001,mode<span class="o">=</span>0400 <span class="se">\</span>
    redis:3.0.6
<span class="go">
4cdgfyky7ozwh3htjfw0d12qv
</span></code></pre></div></div>

<p>サービスから複数の Secret へのアクセスを許可するには、<code class="highlighter-rouge">--secret</code>フラグを複数指定します。</p>

<p>ターゲットの指定がない場合、Secret はコンテナー内の<code class="highlighter-rouge">/run/secrets</code>に置かれます。
ターゲット指定がなければ、Secret 名がコンテナー内のインメモリファイルとして用いられます。
ターゲットが指定されれば、それがファイル名として用いられます。
上のコマンド例においては、指定されている Secret ターゲットのそれぞれに対応して、<code class="highlighter-rouge">/run/secrets/ssh</code>と<code class="highlighter-rouge">/run/secrets/app</code>という 2 つのファイルが生成されます。</p>

<h3 id="create-a-service-with-configs">Config を使ったサービス生成</h3>

<p><code class="highlighter-rouge">--config</code>フラグの指定により、コンテナーに対して <a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/commandline/config_create/">Config</a>（設定情報）へのアクセスを許可します</p>

<p>以下では Config を使ってサービスを生成します。
Config は<code class="highlighter-rouge">redis-config</code>にマウントされます。
その所有ユーザーはコンテナー内部においてこのコマンドを実行したユーザーです（たいていは<code class="highlighter-rouge">root</code>です）。
そしてファイルモードを<code class="highlighter-rouge">0444</code>、つまり全読み込み可とします。
<code class="highlighter-rouge">uid</code>と<code class="highlighter-rouge">gid</code>は、数値あるいは名称での指定ができます。
名称を利用する場合、指定するグループまたはユーザー名は、あらかじめコンテナー内において存在していなければなりません。
<code class="highlighter-rouge">mod</code>は<code class="highlighter-rouge">0755</code>などのように、4 桁からなる数字で指定します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span><span class="o">=</span>redis <span class="nt">--config</span> redis-conf redis:3.0.6
</code></pre></div></div>

<p>以下では Config を使ってサービスを生成し、ターゲットとファイルモードを指定します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span> redis <span class="se">\</span>
  <span class="nt">--config</span> <span class="nb">source</span><span class="o">=</span>redis-conf,target<span class="o">=</span>/etc/redis/redis.conf,mode<span class="o">=</span>0400 redis:3.0.6
</code></pre></div></div>

<p>サービスから複数の Config へのアクセスを許可するには、<code class="highlighter-rouge">--config</code>フラグを複数指定します。</p>

<p>ターゲットが指定されなかった場合、Config はコンテナー内の<code class="highlighter-rouge">/</code>に置かれます。
ターゲット指定がない場合、Config 名がコンテナー内のファイル名として用いられます。
ターゲット指定がある場合、それがファイル名に用いられます。</p>

<h3 id="create-a-service-with-a-rolling-update-policy">ローリングアップデートポリシーを使ったサービス生成</h3>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--replicas</span> 10 <span class="se">\</span>
  <span class="nt">--name</span> redis <span class="se">\</span>
  <span class="nt">--update-delay</span> 10s <span class="se">\</span>
  <span class="nt">--update-parallelism</span> 2 <span class="se">\</span>
  redis:3.0.6
</code></pre></div></div>

<p>この後に <a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/commandline/service_update/">service update</a> を実行すると、スケジューラーは一度に最大で 2 つのタスクのアップデートを行い、<code class="highlighter-rouge">10s</code>間隔でアップデートを行います。
詳しくは <a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/swarm/swarm-tutorial/rolling-update/">ローリングアップデートのチュートリアル</a> を参照してください。</p>

<h3 id="set-environment-variables--e---env">環境変数の設定（-e、--env）</h3>

<p>これはサービス内のタスクすべてに対して環境変数を設定します。
たとえば以下のとおりです。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--name</span> redis_2 <span class="se">\</span>
  <span class="nt">--replicas</span> 5 <span class="se">\</span>
  <span class="nt">--env</span> <span class="nv">MYVAR</span><span class="o">=</span>foo <span class="se">\</span>
  redis:3.0.6
</code></pre></div></div>

<p>サービスから複数の Config へのアクセスを許可するには、<code class="highlighter-rouge">--config</code>フラグを複数指定します。
複数の環境変数を指定するには、<code class="highlighter-rouge">--env</code>フラグを複数用いて、個々においてキーバリューのペアを指定します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--name</span> redis_2 <span class="se">\</span>
  <span class="nt">--replicas</span> 5 <span class="se">\</span>
  <span class="nt">--env</span> <span class="nv">MYVAR</span><span class="o">=</span>foo <span class="se">\</span>
  <span class="nt">--env</span> <span class="nv">MYVAR2</span><span class="o">=</span>bar <span class="se">\</span>
  redis:3.0.6
</code></pre></div></div>

<h3 id="create-a-service-with-specific-hostname---hostname">ホスト名を指定したサービス生成 (--hostname)</h3>

<p>このオプションはサービスコンテナーのホスト名に、指定文字列を設定します。
たとえば以下のとおりです。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span> redis <span class="nt">--hostname</span> myredis redis:3.0.6
</code></pre></div></div>

<h3 id="set-metadata-on-a-service--l---label">サービスへのメタデータの設定（-l、--label）</h3>

<p>ラベルは<code class="highlighter-rouge">key=value</code>ペアであり、サービスに対してのメタデータとして適用されます。
サービスに 2 つのラベルをつけるには以下のようにします。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--name</span> redis_2 <span class="se">\</span>
  <span class="nt">--label</span> com.example.foo<span class="o">=</span><span class="s2">"bar"</span>
<span class="go">  --label bar=baz \
  redis:3.0.6
</span></code></pre></div></div>

<p>ラベルに関する詳細は <a href="https://matsuand.github.io/docs.docker.jp.onthefly/config/labels-custom-metadata/">カスタムメタデータの適用</a> を参照してください。</p>

<h3 id="add-bind-mounts-volumes-or-memory-filesystems">バインドマウント、ボリューム、メモリファイルシステムの追加</h3>

<p>Docker では三種類のマウントをサポートします。
これを利用してコンテナーはファイルやディレクトリに対する読み書きを実現します。
ファイルやディレクトリは、ホストオペレーティングシステム上であっても、あるいはメモリ上のファイルシステムであってもかまいません。
その種類とは <strong>データボリューム</strong>（単にボリュームと呼ぶことがあります）、<strong>バインドマウント</strong>、<strong>tmpfs</strong> であり、<strong>名前つきパイプ</strong> もあります。</p>

<p><strong>バインドマウント</strong> は、このマウントを行ったコンテナーから、ホスト上のファイルやディレクトリを利用できるようにします。
バインドマウントは読み込み専用か読み書き可能かを選べます。
たとえばホスト上の<code class="highlighter-rouge">/etc/resolv.conf</code>をバインドマウントすれば、ホストの DNS 情報を共有することができます。
あるいはコンテナーから、ホストの<code class="highlighter-rouge">/var/log/myContainerLogs</code>ディレクトリに書き込むことができます。
バインドマウントの利用にあたって、ホストとコンテナーの間にパーミッションやアクセス制御などの詳細な部分に差異があったとすると、移植性の問題が発生する場合があります。</p>

<p><strong>名前つきボリューム</strong>（named volume）は、コンテナー内において必要となる永続的なデータを、コンテナー生成に用いるイメージやホストマシンから切り離すためのメカニズムのことです。
名前つきボリュームは Docker によって生成され管理されます。
そこで名前つきボリュームは、コンテナーが利用されていない状態でも存続できます。
名前つきボリューム内のデータは、コンテナーとホストマシンとの間、複数コンテナー間でも共有が可能です。
Docker はボリュームの生成、管理、マウントを行うために <strong>ボリュームドライバー</strong> を利用します。
ボリュームは Docker コマンドを使って、バックアップや復元を行うことができます。</p>

<p><strong>tmpfs</strong> マウントは、コンテナー内部において一時的なデータを利用するための tmpfs です。</p>

<p><strong>npipe</strong> マウントは、ホストからコンテナーに向けて名前つきパイプをマウントします。</p>

<p>たとえば、軽量なウェブサーバーを起動させるイメージがあるとします。
これをベースイメージとして利用したり、ウェブサイトの HTML ファイルをコピーして別イメージにパッケージしたりすることも行うでしょう。
ウェブサイト内容が変更するたびに、新たなイメージとして更新することが必要となり、ウェブサイトを提供するコンテナーすべて再デプロイする必要に迫られます。
そんなやり方ではなく、ウェブサイト内容は名前つきボリューム内に保存するのが適切です。
そうすればウェブサーバーを構成するコンテナーの起動時に、その名前つきボリュームを割り当てて利用することができます。
ウェブサイトの更新時には、単に名前つきボリュームを更新するだけで済みます。</p>

<p>名前つきボリュームについての詳細は <a href="https://matsuand.github.io/docs.docker.jp.onthefly/storage/volumes/">データボリューム</a> を参照してください。</p>

<p>以下の表は、サービス内のバインドマウントまたは名前つきボリュームに適用されるオプションを説明するものです。</p>

<table>
  <tr>
    <th>オプション</th>
    <th>必須</th>
    <th>内容説明</th>
  </tr>
  <tr>
    <td><b>type</b></td>
    <td></td>
    <td>
      <p>マウントのタイプを示します。<tt>volume</tt>、<tt>bind</tt>、<tt>tmpfs</tt>、<tt>npipe</tt> のいずれかです。type が指定されなかった場合のデフォルトは <tt>volume</tt> です。</p>
      <ul>
        <li><tt>volume</tt> は <a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/commandline/volume_create/">管理ボリューム</a>（managed volume）をコンテナーにマウントします。</li>
        <li><tt>bind</tt> は、ホスト上のディレクトリまたはファイルをコンテナーにバインドマウントします。</li>
        <li><tt>tmpfs</tt> はコンテナー内に tmpfs をマウントします。</li>
        <li><tt>npipe</tt> は、ホストからコンテナーに向けて名前つきパイプをマウントします（Windows コンテナーのみ）。</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td><b>src</b> または <b>source</b></td>
    <td><tt>type=bind</tt> または <tt>type=npipe</tt> の場合</td>
    <td>
      <ul>
        <li>
         <tt>type=volume</tt>: <tt>src</tt> という記述によりボリューム名を指定することもできます（たとえば <tt>src=my-volume</tt>）。
          名前つきボリュームが存在しなかった場合は自動的に生成されます。
          <tt>src</tt> が指定されなかった場合、ボリュームに対してランダムな名前が割り当てられます。
          この名前はホスト上において必ずユニークなものとなります。
          ただしクラスター内においてはユニークにならないことがあります。
          ランダムに命名されたボリュームは、コンテナーと同一ライフサイクルとなります。
          つまり <i>container</i> が削除される（<tt>service update</tt> の実行時や、サービスのスケール変更あるいは再配置時）と同時に削除されます。
        </li>
        <li>
          <tt>type=bind</tt>: <tt>src</tt> は必須であり、バインドマウントするファイルまたはディレクトリへの絶対パスを指定します。（たとえば <tt>src=/path/on/host/</tt>）ファイルやディレクトリが存在しなかった場合にはエラーが発生します。
        </li>
        <li>
          <tt>type=tmpfs</tt>: <tt>src</tt> はサポートされません。
        </li>
      </ul>
    </td>
  </tr>
  <tr>
    <td><p><b>dst</b> または <b>destination</b> または <b>target</b></p></td>
    <td>必須</td>
    <td>
      <p>コンテナー内のマウントパス。たとえば <tt>/some/path/in/container/</tt>。
      コンテナーのファイルシステム内にそのパスが存在しなかった場合、Engine がその指定に従ってディレクトリを生成し、その後にボリュームやバインドマウントがマウントされます。</p>
    </td>
  </tr>
  <tr>
    <td><p><b>readonly</b> または <b>ro</b></p></td>
    <td></td>
    <td>
      <p>マウントの際に <tt>readonly</tt> オプションが指定されていなければ、Engine は <tt>read-write</tt> としてバインドマウントまたはボリュームをマウントします。
      なお現状の Linux 実装においては <tt>readonly</tt> によりバインドマウントを行っても、そのサブマウントまでは <tt>readonly</tt> になりません。</p>
      <ul>
        <li><tt>true</tt> または <tt>1</tt> または値なしの場合、バインドマウントまたはボリュームをread-only としてマウントします。</li>
        <li><tt>false</tt> または <tt>0</tt> は、バインドマウントまたはボリュームを read-write としてマウントします。</li>
      </ul>
    </td>
  </tr>
</table>

<h4 id="options-for-bind-mounts">バインドマウントのオプション</h4>

<p>以下のオプションはバインドマウント（<code class="highlighter-rouge">type=bind</code>）の場合にのみ利用可能です。</p>

<table>
  <tr>
    <th>オプション</th>
    <th>内容説明</th>
  </tr>
  <tr>
    <td><b>bind-propagation</b></td>
    <td>
      <p><a href="#bind-propagation">バインドプロパゲーション</a> の節を参照してください。</p>
    </td>
  </tr>
  <tr>
    <td><b>consistency</b></td>
    <td>
      <p>マウントにおける一貫性の要求状況。以下のいずれかです。</p>
      <ul>
       <li><tt>default</tt> は <tt>consistent</tt> と同じです。</li>
       <li><tt>consistent</tt> は完全な一貫性を表します。コンテナーランタイムとホストは、いかなる時点においても同一のマウント参照を維持します。</li>
       <li><tt>cached</tt> は、ホストから見たマウントの信頼性を維持します。ホスト上において発生した更新は、コンテナー内で参照できるようになるまでに時間を要します。</li>
       <li><tt>delegated</tt> は、コンテナーランタイムから見たマウントの信頼性を維持します。コンテナー上において発生した更新は、ホスト内で参照できるようになるまでに時間を要します。</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td><b>bind-nonrecursive</b></td>
    <td>
      デフォルトにおいてサブマウントも、再帰的にバインドマウントされます。しかしこの動作は、<tt>readonly</tt> を使ってバインドマウントが行われた際には混乱の元となります。その場合のサブマウントは read-only にならないからです。
      <tt>bind-nonrecursive</tt> を設定すれば、再帰的なバインドマウントを無効にできます。<br />
      <br />
      設定値は以下のとおりです。<br />
      <br />
      <ul>
        <li><tt>true</tt> または <tt>1</tt> は、再帰的なバインドマウントを無効にします。</li>
        <li><tt>false</tt> または <tt>0</tt>、また設定がない場合にはこれがデフォルトになりますが、再帰的なバインドマウントを有効にします。</li>
      </ul>
    </td>
  </tr>
</table>

<h5 id="bind-propagation">バインドプロパゲーション</h5>

<p>バインドプロパゲーションとは、指定されたバインドマウントや名前つきボリュームによって生成されるマウントが、そのレプリカに対して情報伝達（propagate）をするかどうかを表わします。
ここで<code class="highlighter-rouge">/mnt</code>というマウントポイントを考えます。
これが<code class="highlighter-rouge">/tmp</code>にマウントされているとします。
これに対するプロパゲーションの設定は、<code class="highlighter-rouge">/tmp/a</code>上のマウントが<code class="highlighter-rouge">/mnt/a</code>として利用可能かどうかを制御するものです。
プロパゲーションの各設定においては、再帰的に対応するマウントポイントが存在します。
再帰的という点でいうと、仮に<code class="highlighter-rouge">/tmp/a</code>が<code class="highlighter-rouge">/foo</code>としてマウントされていたとします。
このときプロパゲーション設定は<code class="highlighter-rouge">/mnt/a</code>や<code class="highlighter-rouge">/tmp/a</code>が存在するかどうかを定めるものです。</p>

<p>オプション<code class="highlighter-rouge">bind-propagation</code>は、バインドマウントとボリュームマウントのいずれにおいても、デフォルトは<code class="highlighter-rouge">rprivate</code>と設定されていますが、変更可能であるのはバインドマウントにおいてのみです。
つまり名前つきボリュームではバインドプロパゲーションはサポートされていません。</p>

<ul>
  <li><strong><code class="highlighter-rouge">shared</code></strong>＝ マウント元に対するサブマウントは、マウント先にも公開されます。
                マウント先に対するサブマウントも、マウント元に対して公開されます。</li>
  <li><strong><code class="highlighter-rouge">slave</code></strong>＝ shared マウントに類似。
               ただし一方向のみ。
               マウント元がサブマウントを公開するなら、マウント先でもこれを見ることができますが、マウント先がサブマウントを公開しても、マウント元からは見ることができません。</li>
  <li><strong><code class="highlighter-rouge">private</code></strong>＝ マウントはプライベートなものになります。
                 マウント元におけるサブマウントは、マウント先に公開されません。
                 またマウント先のサブマウントも、マウント元には公開されません。</li>
  <li><strong><code class="highlighter-rouge">rshared</code></strong>＝ shared と同様。
                 ただしプロパゲーションは、元々のマウントポイントまたはレプリカマウントポイントにネストされたマウントポイントとの間にも伝達されます。</li>
  <li><strong><code class="highlighter-rouge">rslave</code></strong>＝ slave と同様。
                <code class="highlighter-rouge">slave</code> と同じく、プロパゲーションは、元々のマウントポイントまたはレプリカマウントポイントにネストされたマウントポイントとの間にも情報伝達されます。</li>
  <li><strong><code class="highlighter-rouge">rprivate</code></strong>＝ デフォルト。
                  <code class="highlighter-rouge">private</code>と同様。
                  つまり元々のマウントポイントまたはレプリカマウントポイント内のサブマウントは、どの方向にも情報伝達されません。</li>
</ul>

<p>バインドプロパゲーションの詳細については <a href="https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt">Linux カーネルの shared subtree に関するドキュメント</a> を参照してください。</p>

<h4 id="options-for-named-volumes">名前つきボリュームのオプション</h4>

<p>以下のオプションは名前つきボリューム（<code class="highlighter-rouge">type=volume</code>）の場合にのみ利用可能です。</p>

<table>
  <tr>
    <th>オプション</th>
    <th>内容説明</th>
  </tr>
  <tr>
    <td><b>volume-driver</b></td>
    <td>
      <p>ボリュームに対して利用するボリュームドライバープラグイン名。
      デフォルトは <tt>"local"</tt>。
      これが指定されている場合、ボリュームが存在しない場合にこのローカルボリュームドライバーを使ってボリュームが生成されます。</p>
    </td>
  </tr>
  <tr>
    <td><b>volume-label</b></td>
    <td>
      ボリュームの生成時に適用される 1 つまたは複数のカスタムメタデータ（"labels"）。
      たとえば <tt>volume-label=mylabel=hello-world,my-other-label=hello-mars</tt> など。
      ラベルに関する詳細は <a href="https://matsuand.github.io/docs.docker.jp.onthefly/config/labels-custom-metadata/">カスタムメタデータの適用</a> を参照してください。
    </td>
  </tr>
  <tr>
    <td><b>volume-nocopy</b></td>
    <td>
      空のボリュームをコンテナーに割り当てた際に、コンテナー内のマウントパス（<tt>dst</tt>）にすでにファイルやディレクトリが存在していた場合は、デフォルトで Engine がそのファイルやディレクトリをボリューム内にコピーし、ホストからのアクセスを可能とします。
      この <tt>volume-nocopy</tt> を設定すると、コンテナー内のファイルシステムからボリュームへのファイルコピーが無効化され、空のボリュームがマウントされます。<br />
      <br />
      設定値は以下のとおりです。<br />
      <br />
      <ul>
        <li><tt>true</tt> または <tt>1</tt>、また設定がない場合にはこれがデフォルトになりますが、コピーを無効にします。</li>
        <li><tt>false</tt> または <tt>0</tt> はコピーを有効にします。</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td><b>volume-opt</b></td>
    <td>
      指定するボリュームドライバーに固有のオプション。
      このオプションはボリューム生成時にドライバーに受け渡されます。
      オプションはキーバリューのペアをカンマで区切ったリストとして指定します。
      たとえば <tt>volume-opt=some-option=some-value,volume-opt=some-other-option=some-other-value</tt> です。
      指定するドライバーにおいて利用可能なオプションについては、各ドライバーのドキュメントを参照してください。
    </td>
  </tr>
</table>

<h4 id="options-for-tmpfs">tmpfs のオプション</h4>

<p>以下のオプションは tmpfs マウント（<code class="highlighter-rouge">type=tmpfs</code>）の場合にのみ利用可能です。</p>

<table>
  <tr>
    <th>オプション</th>
    <th>内容説明</th>
  </tr>
  <tr>
    <td><b>tmpfs-size</b></td>
    <td>tmpfs マウントの容量をバイト単位で指定します。Linux におけるデフォルトは無制限です。</td>
  </tr>
  <tr>
    <td><b>tmpfs-mode</b></td>
    <td>8 進数表記による tmpfs のファイルモード。（たとえば <tt>"700"</tt> や <tt>"0700"</tt> など。）
    Linux におけるデフォルトは <tt>"1777"</tt>。</td>
  </tr>
</table>

<h4 id="differences-between---mount-and---volume">「--mount」と「--volume」の違い</h4>

<p><code class="highlighter-rouge">--mount</code>フラグは、<code class="highlighter-rouge">docker run</code>における<code class="highlighter-rouge">-v</code>または<code class="highlighter-rouge">--volume</code>フラグと、ほとんど同じオプションがサポートされています。
ただし以下のように重要な違いがあります。</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">--mount</code>フラグではボリュームドライバーの指定が可能であり、<strong>各ボリュームごとに</strong> ボリュームドライバーオプションの指定ができます。
これはボリュームを生成しなくてもできることです。
それに比べて<code class="highlighter-rouge">docker run</code>では、<code class="highlighter-rouge">--volume-driver</code>フラグを使って、全ボリュームに共通するボリュームドライバーを指定します。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">--mount</code>フラグでは、ボリュームに対してカスタムメタデータ（「labels」）を指定することができます。
これはボリューム生成前に設定されます。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">type=bind</code>指定とともに<code class="highlighter-rouge">--mount</code>フラグを用いる場合、ホストパスはホスト上に <strong>存在している</strong> パスでなければなりません。
パスは自動的に生成されないため、パスが存在していないとサービスはエラー終了します。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">--mount</code>フラグでは、<code class="highlighter-rouge">Z</code>フラグまたは<code class="highlighter-rouge">z</code>フラグを使ったボリュームのラベル変更はできません。
それらのフラグは<code class="highlighter-rouge">selinux</code>のラベルづけに利用されています。</p>
  </li>
</ul>

<h4 id="create-a-service-using-a-named-volume">名前つきボリュームを用いたサービス生成</h4>

<p>以下の例は、名前つきボリュームを利用するサービスを生成します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--name</span> my-service <span class="se">\</span>
  <span class="nt">--replicas</span> 3 <span class="se">\</span>
  <span class="nt">--mount</span> <span class="nb">type</span><span class="o">=</span>volume,source<span class="o">=</span>my-volume,destination<span class="o">=</span>/path/in/container,volume-label<span class="o">=</span><span class="s2">"color=red"</span>,volume-label<span class="o">=</span><span class="s2">"shape=round"</span> <span class="se">\</span>
  nginx:alpine
</code></pre></div></div>

<p>サービスの各レプリカにおいては、タスクがデプロイされた場所のデフォルト（「local」）ボリュームドライバーから、Engine が「my-volume」という名のボリュームを要求します。
ボリュームが存在しなかった場合、Engine は新たなボリュームを生成して、そのラベルとして「color」と「shape」を設定します。</p>

<p>タスクが起動すると、ボリュームはコンテナー内の<code class="highlighter-rouge">/path/in/container/</code>にマウントされます。</p>

<p>注意する点として、デフォルトの（「local」）ボリュームドライバーのスコープは、あくまでローカルであるということです。
これはつまり、タスクがどこにデプロイされているかに依存します。
「my-volume」という名前のボリュームを <strong>新たに</strong> 生成するか、同一サービス内の別タスクとの間で同じ「my-volume」を共有するかは状況次第です。
複数のコンテナーが 1 つの共有ボリュームに書き込みを行うとすると、コンテナー上で動作するソフトウェアが同一箇所への書き込みを並行処理するように設計されていないと、データ破壊を引き起こす可能性があります。
さらにコンテナーというものは Swarm オーケストレーターによって再スケジュールされ、別のノードに再配置されることがあるので、このことにも留意する必要があります。</p>

<h4 id="create-a-service-that-uses-an-anonymous-volume">匿名ボリュームを使ったサービス生成</h4>

<p>以下の例では 3 つのレプリカを持つサービスを生成し、<code class="highlighter-rouge">/path/in/container</code>にマウントされた匿名ボリュームを利用します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--name</span> my-service <span class="se">\</span>
  <span class="nt">--replicas</span> 3 <span class="se">\</span>
  <span class="nt">--mount</span> <span class="nb">type</span><span class="o">=</span>volume,destination<span class="o">=</span>/path/in/container <span class="se">\</span>
  nginx:alpine
</code></pre></div></div>

<p>上のコマンドにおいては、ボリュームに対する名前（<code class="highlighter-rouge">source</code>）が指定されていないため、新たなボリュームが各タスクにて生成されます。
これは各タスクがそれぞれ独自のボリュームを確実に持つものとなるため、タスク間においてボリュームの共有は行われません。
匿名ボリュームは、これを利用するタスクが終了すると削除されます。</p>

<h4 id="create-a-service-that-uses-a-bind-mounted-host-directory">ホストのディレクトリにバインドマウントされたサービスの生成</h4>

<p>以下の例は、サービスを起動するコンテナーにおいて、ホストのディレクトリ<code class="highlighter-rouge">/path/in/container</code>をバインドマウントするものです。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--name</span> my-service <span class="se">\</span>
  <span class="nt">--mount</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bind</span>,source<span class="o">=</span>/path/on/host,destination<span class="o">=</span>/path/in/container <span class="se">\</span>
  nginx:alpine
</code></pre></div></div>

<h3 id="set-service-mode---mode">サービスモードの設定（--mode）</h3>

<p>サービスモードは、サービスが <strong>レプリカされた</strong>（replicated）ものか <strong>グローバルな</strong> ものかを決定します。
レプリカされたサービスは、指定に従って複数のタスクとして実行されます。
一方グローバルなサービスは、Swarm 内においてアクティブな各ノード上で実行されます。</p>

<p>以下のコマンドはグローバルサービスを生成します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
 <span class="nt">--name</span> redis_2 <span class="se">\</span>
 <span class="nt">--mode</span> global <span class="se">\</span>
 redis:3.0.6
</code></pre></div></div>

<h3 id="specify-service-constraints---constraint">サービス制約の指定（--constraint）</h3>

<p>スケジューリングされるタスクに対しては制約表現（constraint expressions）を定義することができ、これにより一連のノードへの制限を課すことができます。
制約表現は <strong>合致する</strong>（<code class="highlighter-rouge">==</code>）か、あるいは <strong>除外する</strong>（<code class="highlighter-rouge">!=</code>）というルールにより表現されます。
制約が複数ある場合は、すべての表現に合致する（AND 条件による）ノードに適用されます。
制約は以下のように、ノードまたは Docker Engine ラベルに適用されます。</p>

<table>
  <thead>
    <tr>
      <th>ノード属性</th>
      <th>該当項目</th>
      <th>例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">node.id</code></td>
      <td>ノード ID</td>
      <td><code class="highlighter-rouge">node.id==2ivku8v2gvtg4</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">node.hostname</code></td>
      <td>ノードホスト名</td>
      <td><code class="highlighter-rouge">node.hostname!=node-2</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">node.role</code></td>
      <td>ノードのロール（<code class="highlighter-rouge">manager</code>/<code class="highlighter-rouge">worker</code>）</td>
      <td><code class="highlighter-rouge">node.role==manager</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">node.platform.os</code></td>
      <td>ノードのオペレーティングシステム</td>
      <td><code class="highlighter-rouge">node.platform.os==windows</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">node.platform.arch</code></td>
      <td>ノードのアーキテクチャー</td>
      <td><code class="highlighter-rouge">node.platform.arch==x86_64</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">node.labels</code></td>
      <td>ユーザー定義のノードラベル</td>
      <td><code class="highlighter-rouge">node.labels.security==high</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">engine.labels</code></td>
      <td>Docker Engine のラベル</td>
      <td><code class="highlighter-rouge">engine.labels.operatingsystem==ubuntu-14.04</code></td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">engine.labels</code>は、オペレーティングシステムやドライバーなどのような Docker Engine ラベルに適用されます。
Swarm 管理者は操作をしやすくする目的で、<a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/commandline/node_update/"><code class="highlighter-rouge">docker node update</code></a> コマンドを使って<code class="highlighter-rouge">node.labels</code>を追加します。</p>

<p>たとえば以下の例では、redis サービスのタスクへの制約を設定するものであり、ノードのタイプラベルが queue であるものを対象とします。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--name</span> redis_2 <span class="se">\</span>
  <span class="nt">--constraint</span> node.platform.os<span class="o">==</span>linux <span class="se">\</span>
  <span class="nt">--constraint</span> node.labels.type<span class="o">==</span>queue <span class="se">\</span>
  redis:3.0.6
</code></pre></div></div>

<p>サービスへの制約がクラスター内のどのノードにも合致しなかった場合、対象となるノードが見つからなかったというメッセージが出力されます。
ただし対象となるノードが出現した場合には、スケジューラーが調整ループを起動させてサービスをデプロイします。</p>

<p>以下の例では、制約を満たすノードが見つからなかったために、サービスが意図する状態にならなかったことを表しています。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--name</span> web <span class="se">\</span>
  <span class="nt">--constraint</span> node.labels.region<span class="o">==</span>east <span class="se">\</span>
  nginx:alpine
<span class="go">
lx1wrhhpmbbu0wuk0ybws30bc
overall progress: 0 out of 1 tasks
1/1: no suitable node (scheduling constraints not satisfied on 5 nodes)

</span><span class="gp">$</span> docker service <span class="nb">ls</span>
<span class="go">ID                  NAME     MODE         REPLICAS   IMAGE               PORTS
b6lww17hrr4e        web      replicated   0/1        nginx:alpine
</span></code></pre></div></div>

<p>この後にクラスター内の 1 つのノードに対して<code class="highlighter-rouge">region=east</code>というラベルを追加すると、サービス調整が始まり、期待される数だけのレプリカがデプロイされます。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker node update <span class="nt">--label-add</span> <span class="nv">region</span><span class="o">=</span>east yswe2dm4c5fdgtsrli1e8ya5l
<span class="go">yswe2dm4c5fdgtsrli1e8ya5l

</span><span class="gp">$</span> docker service <span class="nb">ls</span>
<span class="go">ID                  NAME     MODE         REPLICAS   IMAGE               PORTS
b6lww17hrr4e        web      replicated   1/1        nginx:alpine
</span></code></pre></div></div>

<h3 id="specify-service-placement-preferences---placement-pref">サービスの配置設定の指定（--placement-pref）</h3>

<p>さまざまなカテゴリーのノードに対して、タスクを均等に割り振るようにサービスを設定することができます。
1 つの例として有用になるのが、データセンターや利用可能なゾーンが複数にわたっていて、そこにバランスよくタスクを割り振る場合です。
以下の例はこれを示しています。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--replicas</span> 9 <span class="se">\</span>
  <span class="nt">--name</span> redis_2 <span class="se">\</span>
  <span class="nt">--placement-pref</span> <span class="nv">spread</span><span class="o">=</span>node.labels.datacenter <span class="se">\</span>
  redis:3.0.6
</code></pre></div></div>

<p>ここでは<code class="highlighter-rouge">--placement-pref</code>に<code class="highlighter-rouge">spread</code>ストラテジー（現時点においては唯一サポートされているストラテジー）を用いて、<code class="highlighter-rouge">datacenter</code>ノードラベルを持つノードにわたって均等にタスクを広げて（spread して）います。
この例では、全ノードにおいてノードラベル<code class="highlighter-rouge">datacenter</code>が与えられているものとしています。
もし Swarm 内のノードにおいて三種類のラベル値が存在していたとすると、各値が与えられているノードに 3 分の 1 ずつのタスクが割り振られることになります。
たとえ 1 つの値を持つノードの数が他よりも多くても、この割り振りは変わりません。
たとえばノードの状態が以下であるとします。</p>

<ul>
  <li><code class="highlighter-rouge">node.labels.datacenter=east</code>を持つノードが 3 つ。</li>
  <li><code class="highlighter-rouge">node.labels.datacenter=south</code>を持つノードが 2 つ。</li>
  <li><code class="highlighter-rouge">node.labels.datacenter=west</code>を持つノードが 1 つ。</li>
</ul>

<p>上では<code class="highlighter-rouge">datacenter</code>ラベルを持つノードへの spread を行っており、サービスには 9 個のレプリカを設定しています。
したがって各 datacenter へは 3 つのレプリカが配置されるはずです。
ところでラベル値<code class="highlighter-rouge">east</code>を持つノードは 3 つでした。
したがってその各ノードへは、この値に対して割り振られる 3 つのレプリカの 1 つがそれぞれに割り振られます。
またラベル値<code class="highlighter-rouge">south</code>を持つノードは 2 つです。
この値に対して割り振られる 3 つのレプリカは、そのノード間で分配されます。
つまり 1 つのノードが 2 つのレプリカを受け持つこととなり、残る 1 つのノードがレプリカ 1 つだけを受け持ちます。
最後にラベル値<code class="highlighter-rouge">west</code>を持つノードでは、<code class="highlighter-rouge">west</code>に割り当てられる 3 つのレプリカすべてを 1 つのノードが持つことになります。</p>

<p>1 つのカテゴリー（たとえば<code class="highlighter-rouge">node.labels.datacenter=south</code>）を持つノードが、制約やリソース制限によって本来受け持つべきタスクを扱えない場合、余ったタスクは、可能であれば別のノードに割り当てられることになります。</p>

<p>配置設定（placement preferences）においては、Engine ラベルとノードラベルの両方をサポートします。
上の例ではノードラベルを用いていましたが、この例では<code class="highlighter-rouge">node.labels.datacenter</code>としてラベルを参照したからです。
Engine ラベルの値に基づいて spread を行うのであれば、<code class="highlighter-rouge">--placement-pref spread=engine.labels.&lt;labelname&gt;</code> とします。</p>

<p>サービスにおける配置設定は複数追加することができます。
これを行うと設定が階層化されます。
つまりタスクに対して 1 つのカテゴリーにより分配が行われ、さらに別のカテゴリーを通じて分配が行われるといった具合です。
1 つの例として有用になるのが、データセンター間において公正にタスクを割り振り、各データセンターでは設定するラックに対してタスクを分割する場合です。
配置設定を複数指定する場合は<code class="highlighter-rouge">--placement-pref</code>フラグを複数回指定します。
その場合は指定準が重要になります。
配置設定は、スケジュール決定が行われる際に指定順により適用されます。</p>

<p>以下の例は、配置設定を複数指定したサービスを起動します。
タスクは初めに各データセンターに割り振られ、次にラックに対して割り振られます（それぞれラベルによって示されています）。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--replicas</span> 9 <span class="se">\</span>
  <span class="nt">--name</span> redis_2 <span class="se">\</span>
  <span class="nt">--placement-pref</span> <span class="s1">'spread=node.labels.datacenter'</span> <span class="se">\</span>
  <span class="nt">--placement-pref</span> <span class="s1">'spread=node.labels.rack'</span> <span class="se">\</span>
  redis:3.0.6
</code></pre></div></div>

<p><code class="highlighter-rouge">docker service update</code>によってサービスを更新する際に<code class="highlighter-rouge">--placement-pref-add</code>を利用すると、既存の配置設定に新たな配置設定を追加することができます。
また<code class="highlighter-rouge">--placement-pref-rm</code>は、引数に合致する既存の配置設定を削除します。</p>

<h3 id="specify-memory-requirements-and-constraints-for-a-service---reserve-memory-and---limit-memory">サービスに対するメモリ要求と制約の指定（--reserve-memory、--limit-memory）</h3>

<p>適正にサービスを実行するのに特定のメモリ容量を最低でも必要とする場合は<code class="highlighter-rouge">--reserve-memory</code>を用います。
これを用いると、サービスがその分のメモリ量を確保できるノードにしかノード配分を行いません。
この基準を満たすノードが 1 つもなかった場合、タスクはスケジューリングされず、ペンディング状態のままとなります。</p>

<p>以下の例は、4 GB のメモリ容量を利用でき、しかも確保可能であるノードを選んでから、その上にサービス実行するようなスケジューリングが行われます。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--reserve-memory</span><span class="o">=</span>4GB <span class="nt">--name</span><span class="o">=</span>too-big nginx:alpine
</code></pre></div></div>

<p>1 つのノードに対してメモリ容量の確保が複数求められる場合に、その合計がそのノードでの利用可能容量を超える場合は、マネージャーノードはコンテナーのスケジューリングを行いません。</p>

<p>タスクがスケジュールされ実行された後は、<code class="highlighter-rouge">--reserve-memory</code>はメモリ利用を制限しません。
ノード上において、指定容量以上のメモリをタスクが利用しないようにするには<code class="highlighter-rouge">--limit-memory</code>を用います。
以下の例では、タスクが利用できる容量を 4 GB に制限します。
この場合に、ノードがたとえば 2 GB しかメモリを持っていなくても、タスクはスケジューリングされます。
<code class="highlighter-rouge">--limit-memory</code>は上限を制限するだけのものであるからです。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--limit-memory</span><span class="o">=</span>4GB <span class="nt">--name</span><span class="o">=</span>too-big nginx:alpine
</code></pre></div></div>

<p><code class="highlighter-rouge">--reserve-memory</code>および<code class="highlighter-rouge">--limit-memory</code>を利用するにあたって、ホスト上のメモリ容量を超えた指定が行われても、ホスト容量内に抑えるような動作保証はありません。
サービスはいくらでも生成可能であり、それが利用するメモリの総量は、いくらでも利用可能メモリを消費していきます。</p>

<p>利用可能なメモリが際限なく消費されてしまうこの状況は、ホスト上に動作する別の（コンテナー化アプリ以外の）ソフトウェアに対しても考慮することが必要です。
<code class="highlighter-rouge">--reserve-memory</code>の値が<code class="highlighter-rouge">--limit-memory</code>の値よりも大きいか等しい場合、十分なメモリを有していないホストへのサービスのスケジューリングは行われません。
<code class="highlighter-rouge">--limit-memory</code>はサービスのメモリ使用量をその制限以内に収めます。
したがってサービスのすべてにおいてメモリ予約やメモリ制限を設けていれば、Docker サービスがホストのメモリを消費し尽くすことを抑えられます。
ただしサービス以外のコンテナーやアプリケーションが Docker ホスト上で直接実行されている場合は、メモリを浪費する可能性は残ります。</p>

<p>ただしこの方法には欠点があります。
メモリ予約をするということは、そのノードにおいて利用可能なメモリを的確に利用しないことにもつながりかねません。
たとえば今、あるサービスが通常は 100 MB のメモリを利用するものとして、負荷次第ではピーク時に 500 MB まで利用するものがあったとします。
このサービスのメモリ予約量を 500 MB とする（そのピーク時の 500 MB を確保する）ことは、つまりほとんどのタイミングにおいて 400 MB を利用することなく無駄使いすることになります。</p>

<p>そこでもっと手堅く柔軟な方法をとることができます。</p>

<ul>
  <li>
    <p><strong>手堅い方法</strong> ＝ 500 MB を予約した上で上限を 500 MB とします。
ただしそもそもがサービスコンテナーを VM として利用することになるため、本来ならホストにおいて高密度にサービス処理が行われるはずなのに、その最大の利点を失うことになります。</p>
  </li>
  <li>
    <p><strong>柔軟な方法</strong> ＝ サービスが 500 MB 以上を必要とすることがわかっていて、利用制限を 500 MB にしてしまうと破綻します。
「通常」時が 100 MB で「ピーク」時が 500 MB であるならば、その間の値を予約します。
ただしサービスが「ピーク」時にあるときには、別のサービスまたはコンテナー以外の処理はピークに達しないことが前提です。</p>
  </li>
</ul>

<p>採用すべき手法は、何よりもメモリ利用状況がどのようなものであるかによって変わります。
手法を定めるためには、通常時、ピーク時の状況を十分にテストすることが必要です。</p>

<p>Linux においては、指定するホスト上においてサービスによるメモリーフットプリント（memory footprint）総量を制限することもできます。
これはオペレーティングシステムのレベルにおいて、<code class="highlighter-rouge">cgroups</code>かあるいはこれに相当するシステムツールを利用して行います。</p>

<h3 id="specify-maximum-replicas-per-node---replicas-max-per-node">ノードごとの最大レプリカ数の指定（--replicas-max-per-node）</h3>

<p><code class="highlighter-rouge">--replicas-max-per-node</code>フラグを使えば、ノード上において実行するレプリカの最大数を指定できます。
以下のコマンドは 2 つのレプリカからなる nginx サービスを生成しますが、各ノードには 1 つのレプリカしか割り振らないようにします。</p>

<p>これが有用となる例としては<code class="highlighter-rouge">--placement-pref</code>との併用により、複数のデータセンター間においてタスクをバランスよく割り振ることが考えられます。
<code class="highlighter-rouge">--replicas-max-per-node</code>を設定することによって、1 つのデータセンターのメンテナンスや障害が発生しても、レプリカをそこに割り振らないようにできます。</p>

<p>以下の例はこれを実現するものです。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--name</span> nginx <span class="se">\</span>
  <span class="nt">--replicas</span> 2 <span class="se">\</span>
  <span class="nt">--replicas-max-per-node</span> 1 <span class="se">\</span>
  <span class="nt">--placement-pref</span> <span class="s1">'spread=node.labels.datacenter'</span> <span class="se">\</span>
  nginx
</code></pre></div></div>

<h3 id="attach-a-service-to-an-existing-network---network">既存ネットワークへのサービスの割り当て（--network）</h3>

<p>Swarm 内においてはオーバーレイネットワークを使って、複数のサービスを接続することができます。</p>

<p>まずはマネージャーノード上において、<code class="highlighter-rouge">docker network create</code>コマンドを使ってオーバーレイネットワークを生成します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker network create <span class="nt">--driver</span> overlay my-network
<span class="go">
etjpu59cykrptrgw0z0hk5snf
</span></code></pre></div></div>

<p>Swarm モード内にオーバーレイネットワークを生成した後は、すべてのマネージャーノードがネットワークにアクセスできるようになります。</p>

<p>サービスを生成する際には<code class="highlighter-rouge">--network</code>フラグを使って、サービスをオーバーレイネットワークに接続します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
  <span class="nt">--replicas</span> 3 <span class="se">\</span>
  <span class="nt">--network</span> my-network <span class="se">\</span>
  <span class="nt">--name</span> my-web <span class="se">\</span>
  nginx
<span class="go">
716thylsndqma81j6kkkb5aus
</span></code></pre></div></div>

<p>Swarm においては、サービスを実行している各ノードに向けて my-network が拡散されます。</p>

<p>同一のネットワーク上にあるコンテナーであれば、<a href="https://matsuand.github.io/docs.docker.jp.onthefly/network/overlay/#container-discovery">サービス検出</a> 機能を使って互いにアクセスすることができます。</p>

<p><code class="highlighter-rouge">--network</code>フラグにおいて長い文法を用いると、エイリアスやドライバーオプションをリストにより指定できます。
たとえば<code class="highlighter-rouge">--network name=my-network,alias=web1,driver-opt=field1=value1</code>とします。</p>

<h3 id="publish-service-ports-externally-to-the-swarm--p---publish">Swarm 外部へのサービスポートの公開（-p、--publish）</h3>

<p>サービスポートを公開するには<code class="highlighter-rouge">--publish</code>フラグを用います。
これにより Swarm の外部からサービスへのアクセスが可能になります。
<code class="highlighter-rouge">--publish</code>フラグでは、引数に関して 2 通りの文法があります。
短い文法では引数の位置に意味があり、公開ポートとターゲットポートをコロン（<code class="highlighter-rouge">:</code>）で区切って指定します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span> my_web <span class="nt">--replicas</span> 3 <span class="nt">--publish</span> 8080:80 nginx
</code></pre></div></div>

<p>長い文法による指定もあり、この方がわかりやすく、また多くのオプションを指定できます。
推奨されているのは長い文法の利用です。
なお短い文法を使った場合には、サービスモードを指定することはできません。
上のコマンドと同一のことを、長い文法を使って実行したのが以下の例です。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span> my_web <span class="nt">--replicas</span> 3 <span class="nt">--publish</span> <span class="nv">published</span><span class="o">=</span>8080,target<span class="o">=</span>80 nginx
</code></pre></div></div>

<p>オプションとして指定できるものは以下のとおりです。</p>

<table>
<thead>
<tr>
  <th>オプション</th>
  <th>短い文法</th>
  <th>長い文法</th>
  <th>内容説明</th>
</tr>
</thead>
<tr>
  <td>公開ポートとターゲットポート</td>
  <td><tt>--publish 8080:80</tt></td>
  <td><tt>--publish published=8080,target=80</tt></td>
  <td><p>
    コンテナー内のターゲット（target）ポートとノード内でそこにマッピングされるポート。
    ここにはルーティングメッシュ（<tt>ingress</tt>）またはホストレベルのネットワークが用いられます。
    これ以外のオプションも利用可能であり本表以降に示します。
    キーバリュー形式の文法は説明的であり、これが推奨されます。
  </p></td>
</tr>
<tr>
  <td>モード</td>
  <td>短い文法では設定不可</td>
  <td><tt>--publish published=8080,target=80,mode=host</tt></td>
  <td><p>
    ポートをバインドする際に用いるモード。
    <tt>ingress</tt> または <tt>host</tt> のいずれか。
    デフォルトは <tt>ingress</tt> でありルーティングメッシュを利用します。
  </p></td>
</tr>
<tr>
  <td>プロトコル</td>
  <td><tt>--publish 8080:80/tcp</tt></td>
  <td><tt>--publish published=8080,target=80,protocol=tcp</tt></td>
  <td><p>
    利用プロトコル。
    <tt>tcp</tt>、<tt>udp</tt>、<tt>sctp</tt> のいずれか。
    デフォルトは <tt>tcp</tt>。
    2 つのプロトコルにポートをバインドする場合は <tt>-p</tt> または <tt>--publish</tt> フラグを 2 つ指定します。
  </p></td>
</tr>
</table>

<p><code class="highlighter-rouge">ingress</code>モードを利用してサービスポートを公開する場合、Swarm のルーティングメッシュが機能するため、ノード上にサービスタスクが起動しているかどうかに関係なく、サービスから全ノードへのアクセスは公開ポートを通じて可能になります。
<code class="highlighter-rouge">host</code>モードを利用する場合は、サービスが実行されているノードに対してのみポートがバインドされます。
また 1 つのノード上において指定されるポートのみが 1 度だけバインドされます。
公開モードは長い文法を使った場合にの設定可能です。
詳しくは <a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/swarm/ingress/">Swarm モードにおけるルーティングメッシュの利用</a> を参照してください。</p>

<h3 id="provide-credential-specs-for-managed-service-accounts-windows-only">管理サービスアカウントに対する資格情報スペックの提供（Windows のみ）</h3>

<p>このオプションは Windows コンテナーを利用するサービスに対してのみ利用可能です。
<code class="highlighter-rouge">--credential-spec</code>オプションは<code class="highlighter-rouge">file://&lt;filename&gt;</code>あるいは<code class="highlighter-rouge">registry://&lt;value-name&gt;</code>という書式でなければなりません。</p>

<p>書式として<code class="highlighter-rouge">file://&lt;filename&gt;</code>を用いた場合、参照するファイルは Docker データディレクトリ配下のサブディレクトリ<code class="highlighter-rouge">CredentialSpecs</code>に存在している必要があります。
データディレクトリはデフォルトでは<code class="highlighter-rouge">C:\ProgramData\Docker\</code>です。
たとえば<code class="highlighter-rouge">file://spec.json</code>と指定した場合、<code class="highlighter-rouge">C:\ProgramData\Docker\CredentialSpecs\spec.json</code>を読み込むことになります。</p>

<p>書式として<code class="highlighter-rouge">registry://&lt;value-name&gt;</code>を用いた場合、資格情報スペック（credential spec）はデーモンホストの Windows レジストリから読み込まれます。
指定するレジストリ値は、以下に存在していなければなりません。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers\CredentialSpecs
</code></pre></div></div>

<h3 id="create-services-using-templates">テンプレートを使ったサービスの生成</h3>

<p><code class="highlighter-rouge">service create</code>コマンドにおけるフラグの中には、テンプレートを利用できるものがあります。
その際には Go 言語の <a href="https://golang.org/pkg/text/template/">text/template</a> パッケージによって提供される文法を利用します。</p>

<p>サポートされるフラグは以下です。</p>

<ul>
  <li><code class="highlighter-rouge">--hostname</code></li>
  <li><code class="highlighter-rouge">--mount</code></li>
  <li><code class="highlighter-rouge">--env</code></li>
</ul>

<p>Go 言語テンプレートによる記述書式は以下のとおりです。</p>

<table>
  <tr>
    <th>プレースホルダー</th>
    <th>内容説明</th>
  </tr>
  <tr>
    <td><tt>.Service.ID</tt></td>
    <td>サービス ID</td>
  </tr>
  <tr>
    <td><tt>.Service.Name</tt></td>
    <td>サービス名</td>
  </tr>
  <tr>
    <td><tt>.Service.Labels</tt></td>
    <td>サービスラベル</td>
  </tr>
  <tr>
    <td><tt>.Node.ID</tt></td>
    <td>ノード ID</td>
  </tr>
  <tr>
    <td><tt>.Node.Hostname</tt></td>
    <td>ノードのホスト名</td>
  </tr>
  <tr>
    <td><tt>.Task.ID</tt></td>
    <td>タスク ID</td>
  </tr>
  <tr>
    <td><tt>.Task.Name</tt></td>
    <td>タスク名</td>
  </tr>
  <tr>
    <td><tt>.Task.Slot</tt></td>
    <td>タスクスロット</td>
  </tr>
</table>

<h4 id="template-example">テンプレート例</h4>

<p>以下の例では、コンテナーのサービス名、ノード ID、コンテナーが配置されるホスト名を、テンプレートにより指定してこのコンテナーを生成します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
    <span class="nt">--name</span> hosttempl <span class="se">\</span>
    <span class="nt">--hostname</span><span class="o">=</span><span class="s2">"{{.Node.Hostname}}-{{.Node.ID}}-{{.Service.Name}}"</span><span class="se">\</span>
    busybox top
<span class="go">
va8ew30grofhjoychbr6iot8c

</span><span class="gp">$</span> docker service ps va8ew30grofhjoychbr6iot8c
<span class="go">
ID            NAME         IMAGE                                                                                   NODE          DESIRED STATE  CURRENT STATE               ERROR  PORTS
wo41w8hg8qan  hosttempl.1  busybox:latest@sha256:29f5d56d12684887bdfa50dcd29fc31eea4aaf4ad3bec43daf19026a7ce69912  2e7a8a9c4da2  Running        Running about a minute ago

</span><span class="gp">$</span> docker inspect <span class="nt">--format</span><span class="o">=</span><span class="s2">"{{.Config.Hostname}}"</span> 2e7a8a9c4da2-wo41w8hg8qanxwjwsg4kxpprj-hosttempl
<span class="go">
x3ti0erg11rjpg64m75kej2mz-hosttempl
</span></code></pre></div></div>

<h3 id="specify-isolation-mode-windows">分離モードの設定 (Windows)</h3>

<p>Windows ノードにスケジュールされたタスクは、このノード専用に設定されたデフォルトの分離モード（isolation mode）を使って実行されます。
特定の分離モードを指定するには<code class="highlighter-rouge">--isolation</code>フラグを利用します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span> myservice <span class="nt">--isolation</span><span class="o">=</span>process microsoft/nanoserver
</code></pre></div></div>

<p>Windows 上の分離モードとしてサポートされるのは以下です。</p>
<ul>
  <li><code class="highlighter-rouge">default</code>: タスクが実行されるノードに固有となるデフォルトモード。</li>
  <li><code class="highlighter-rouge">process</code>: プロセス分離モードを利用します（Windows サーバーのみ）。</li>
  <li><code class="highlighter-rouge">hyperv</code>: Hyper-V 分離モードを利用します。</li>
</ul>

<h3 id="create-services-requesting-generic-resources">ジェネリックリソースを利用するサービスの生成</h3>

<p><code class="highlighter-rouge">--generic-resource</code>フラグを利用すると、タスクが到達できるノードの種類を限定することができます（ノードがそのジェネリックリソース（generic resources）を公開している場合）。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
    <span class="nt">--name</span> cuda <span class="se">\</span>
    <span class="nt">--generic-resource</span> <span class="s2">"NVIDIA-GPU=2"</span> <span class="se">\</span>
    <span class="nt">--generic-resource</span> <span class="s2">"SSD=1"</span> <span class="se">\</span>
    nvidia/cuda
</code></pre></div></div>

<h3 id="running-as-a-job">ジョブとしての実行</h3>

<p>デーモンといえば長時間実行されるものですが、これとは違ってジョブというものは、操作を完了したらその後に停止するように設計されている特別なサービスのことです。
ジョブに属しているタスクが正常終了する（戻り値 0 を返す）と、そのタスクは「Completed」（完了）とマークがつけられ、再度実行されることはありません。</p>

<p>ジョブは 2 つのモード、つまり<code class="highlighter-rouge">replicated-job</code>または<code class="highlighter-rouge">global-job</code>を使って起動されます。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="nt">--name</span> myjob <span class="se">\</span>
                        <span class="nt">--mode</span> replicated-job <span class="se">\</span>
                        bash <span class="s2">"true"</span>
</code></pre></div></div>

<p>上のコマンドは 1 つのタスクを実行します。
これは<code class="highlighter-rouge">bash</code>イメージを用いてコマンド<code class="highlighter-rouge">true</code>を実行し、戻り値 0 を返して終了します。</p>

<p>ジョブは極めて特殊なサービスであるため、通常のサービスに比べて以下のような注意点があります。</p>

<ul>
  <li>更新設定やロールバック設定を行うオプションは、どれも無効になります。
ジョブそのものは更新可能ですが、ロールアウトやロールバックができないため、そのようなオプションは設定できません。</li>
  <li>ジョブが「Complete」（完了）状態に達した後は再起動できません。
これはつまりジョブにおいて<code class="highlighter-rouge">--restart-condition</code>を<code class="highlighter-rouge">any</code>に設定することは<code class="highlighter-rouge">on-failure</code>を設定することと同じになります。</li>
</ul>

<p>ジョブはレプリカされた（replicated）モード、およびグローバルモードのいずれでも利用できます。</p>

<h4 id="replicated-jobs">レプリカされたモード</h4>

<p>レプリカされた（replicated）ジョブとは、レプリカされたサービスに似ています。
<code class="highlighter-rouge">--replicas</code>フラグでは、ジョブを実行したい繰り返し数を指定します。</p>

<p>レプリカされたジョブの各レプリカは、デフォルトでそれぞれ 1 回だけ実行されます。
同タイミングでレプリカを複数実行したい場合は、その数を<code class="highlighter-rouge">--max-concurrent</code>フラグに指定します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker service create <span class="se">\</span>
    <span class="nt">--name</span> mythrottledjob <span class="se">\</span>
    <span class="nt">--mode</span> replicated-job <span class="se">\</span>
    <span class="nt">--replicas</span> 10 <span class="se">\</span>
    <span class="nt">--max-concurrent</span> 2 <span class="se">\</span>
    bash <span class="s2">"true"</span>
</code></pre></div></div>

<p>上のコマンドでは合計で 10 個のタスクが実行されます。
ただしどのタイミングにおいても、同時に実行されるのは 2 つだけです。</p>

<h4 id="global-jobs">グローバルジョブ</h4>

<p>グローバルジョブはグローバルサービスに似ています。
配置制約（placement constraints）に合致するノード上において、タスクが 1 度だけ実行されます。
グローバルジョブは、<code class="highlighter-rouge">global-job</code>モードによって表現されます。</p>

<p>なおグローバルジョブが生成された後に、新たにクラスターにノードが追加されると、このジョブに対応するタスクが起動される点に注意してください。
グローバルジョブは「done」（完了）という状態になることはありません。
ただし、ジョブの制約を満たすすべてのノードが、完了タスクを有する状態はありえます。</p>

<h2 id="parent-command">上位コマンド</h2>

<table>
  <thead>
    <tr>
      <th>コマンド</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service/">docker service</a></td>
      <td>サービスを管理します。</td>
    </tr>
  </tbody>
</table>

<h2 id="related-commands">関連コマンド</h2>

<table>
<thead>
  <tr>
    <td>コマンド</td>
    <td>説明</td>
  </tr>
</thead>
<tbody>

  
  <tr>
    <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service_create/">docker service create</a></td>
    <td>新たなサービスを生成します。</td>
  </tr>

  
  <tr>
    <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service_inspect/">docker service inspect</a></td>
    <td>サービスの詳細情報を表示します。</td>
  </tr>

  
  <tr>
    <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service_logs/">docker service logs</a></td>
    <td>サービスまたはタスクのログを取得します。</td>
  </tr>

  
  <tr>
    <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service_ls/">docker service ls</a></td>
    <td>サービス一覧を表示します。</td>
  </tr>

  
  <tr>
    <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service_ps/">docker service ps</a></td>
    <td>1 つまたは複数サービスのタスクを一覧表示します。</td>
  </tr>

  
  <tr>
    <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service_rm/">docker service rm</a></td>
    <td>1 つまたは複数のサービスを削除します。</td>
  </tr>

  
  <tr>
    <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service_rollback/">docker service rollback</a></td>
    <td>サービス設定に対しての変更を元に戻します。</td>
  </tr>

  
  <tr>
    <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service_scale/">docker service scale</a></td>
    <td>1 つまたは複数のレプリカサービスをスケール変更します。</td>
  </tr>

  
  <tr>
    <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/service_update/">docker service update</a></td>
    <td>サービスを更新します。</td>
  </tr>

</tbody>
</table>

<div class="ratings-div"><div id="pd_rating_holder_8453675"></div></div></section>
                    </main>
                    <nav class="col-nav">
                        <div id="sidebar-nav" class="sidebar hidden-sm hidden-xs">
                            <div id="navbar" class="nav-sidebar">
                                <ul class="nav hidden-md hidden-lg"></ul>
                                <ul class="nav" id="jsTOCLeftNav"></ul>
                            </div>
                        </div>
                    </nav>
                    <div class="col-toc">
                        <div class="sidebar hidden-xs hidden-sm">
                            <div class="toc-nav">
                                <div class="feedback-links">
                                    <ul><li><a href="https://github.com/matsuand/docs.docker.jp.onthefly/edit/master/src/engine/reference/commandline/service_create.ch"><i class="fa fa-pencil-square-o" aria-hidden="true"></i> 本ページの編集</a></li><li><a href="https://github.com/matsuand/docs.docker.jp.onthefly/issues/new?body=File: [engine/reference/commandline/service_create.ch](https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/commandline/service_create/)" class="nomunge"><i class="fa fa-check" aria-hidden="true"></i> 変更リクエスト</a></li>
                                        <li><div class="toggle-mode">
  <div class="icon">
      <i class="fa fa-sun-o" aria-hidden="true"></i>
  </div>
  <div class="toggle-switch">
      <label class="switch">
          <input type="checkbox" id="switch-style">
          <span class="slider round"></span>
      </label>
  </div>
  <div class="icon">
      <i class="fa fa-moon-o" aria-hidden="true"></i>
  </div>
</div>
</li>
                                    </ul>
                                </div><div id="side-toc-title">本ページ内:</div>
<ul id="my_toc" class="inline_toc">
  <li><a href="#description" class="nomunge">説明</a></li>
  <li><a href="#usage" class="nomunge">利用方法</a></li>
  <li><a href="#extended-description" class="nomunge">追加説明</a></li>
  <li><a href="#options" class="nomunge">オプション</a></li>
  <li><a href="#examples" class="nomunge">利用例</a>
    <ul>
      <li><a href="#create-a-service" class="nomunge">サービスの生成</a></li>
      <li><a href="#create-a-service-with-5-replica-tasks---replicas" class="nomunge">レプリカタスク 5 を指定したサービス生成 (--replicas)</a></li>
      <li><a href="#create-a-service-with-secrets" class="nomunge">Secret を使ったサービス生成</a></li>
      <li><a href="#create-a-service-with-configs" class="nomunge">Config を使ったサービス生成</a></li>
      <li><a href="#create-a-service-with-a-rolling-update-policy" class="nomunge">ローリングアップデートポリシーを使ったサービス生成</a></li>
      <li><a href="#set-environment-variables--e---env" class="nomunge">環境変数の設定（-e、--env）</a></li>
      <li><a href="#create-a-service-with-specific-hostname---hostname" class="nomunge">ホスト名を指定したサービス生成 (--hostname)</a></li>
      <li><a href="#set-metadata-on-a-service--l---label" class="nomunge">サービスへのメタデータの設定（-l、--label）</a></li>
      <li><a href="#add-bind-mounts-volumes-or-memory-filesystems" class="nomunge">バインドマウント、ボリューム、メモリファイルシステムの追加</a></li>
      <li><a href="#set-service-mode---mode" class="nomunge">サービスモードの設定（--mode）</a></li>
      <li><a href="#specify-service-constraints---constraint" class="nomunge">サービス制約の指定（--constraint）</a></li>
      <li><a href="#specify-service-placement-preferences---placement-pref" class="nomunge">サービスの配置設定の指定（--placement-pref）</a></li>
      <li><a href="#specify-memory-requirements-and-constraints-for-a-service---reserve-memory-and---limit-memory" class="nomunge">サービスに対するメモリ要求と制約の指定（--reserve-memory、--limit-memory）</a></li>
      <li><a href="#specify-maximum-replicas-per-node---replicas-max-per-node" class="nomunge">ノードごとの最大レプリカ数の指定（--replicas-max-per-node）</a></li>
      <li><a href="#attach-a-service-to-an-existing-network---network" class="nomunge">既存ネットワークへのサービスの割り当て（--network）</a></li>
      <li><a href="#publish-service-ports-externally-to-the-swarm--p---publish" class="nomunge">Swarm 外部へのサービスポートの公開（-p、--publish）</a></li>
      <li><a href="#provide-credential-specs-for-managed-service-accounts-windows-only" class="nomunge">管理サービスアカウントに対する資格情報スペックの提供（Windows のみ）</a></li>
      <li><a href="#create-services-using-templates" class="nomunge">テンプレートを使ったサービスの生成</a></li>
      <li><a href="#specify-isolation-mode-windows" class="nomunge">分離モードの設定 (Windows)</a></li>
      <li><a href="#create-services-requesting-generic-resources" class="nomunge">ジェネリックリソースを利用するサービスの生成</a></li>
      <li><a href="#running-as-a-job" class="nomunge">ジョブとしての実行</a></li>
    </ul>
  </li>
  <li><a href="#parent-command" class="nomunge">上位コマンド</a></li>
  <li><a href="#related-commands" class="nomunge">関連コマンド</a></li>
</ul>

</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer class="footer">
          
    <div class="container">
        <div class="top_footer">
            <div class="row">
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products" target="_blank" rel="noopener">製品ラインアップ</a></b></li>
                        <li><a href="https://www.docker.com/products/personal" target="_blank" rel="noopener">Docker Personal</a></li>
                        <li><a href="https://www.docker.com/products/pro" target="_blank" rel="noopener">Docker Pro</a></li>
                        <li><a href="https://www.docker.com/products/team" target="_blank" rel="noopener">Docker Team</a></li>
                        <li><a href="https://www.docker.com/products/business" target="_blank" rel="noopener">Docker Business</a></li>
                        <li><a href="https://www.docker.com/products" target="_blank" rel="noopener">サブスクリプション比較</a></li>
                        <li><b><a href="https://www.docker.com/" target="_blank" rel="noopener">機能</a></b></li>
                        <li><a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker Desktop</a></li>
                        <li><a href="https://www.docker.com/products/docker-hub" target="_blank" rel="noopener">Docker Hub</a></li>
                        <li><a href="https://www.docker.com/products/secure-software-supply-chain" target="_blank" rel="noopener">セキュアなソフトウェアサプライチェーン</a></li>
                        <li><a href="https://www.docker.com/products/container-runtime" target="_blank" rel="noopener">コンテナーランタイム</a></li>
                        <li><a href="https://www.docker.com/products/developer-tools" target="_blank" rel="noopener">開発ツール</a></li>
                        <li><a href="https://www.docker.com/partners" target="_blank" rel="noopener">信頼できるコンテント</a></li>
                        <li><a href="https://www.docker.com/roadmap" target="_blank" rel="noopener">Docker 製品ロードマップ</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">開発者</a></b></li>
                        <li><a href="https://www.docker.com/use-cases" target="_blank" rel="noopener">利用例</a></li>
                        <li><a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">はじめよう</a></li>
                        <li><a href="https://www.docker.com/blog/" target="_blank" rel="noopener">ブログ</a></li>
                        <li><a href="https://www.docker.com/docker-community" target="_blank" rel="noopener">コミュニティー</a></li>
                        <li><a href="https://www.docker.com/open-source" target="_blank" rel="noopener">オープンソース</a></li>
                        <li><a href="https://www.docker.com/community/get-involved/developer-preview" target="_blank" rel="noopener">プレビュープログラム</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">価格体系</a></b></li>
                        <li><a href="https://www.docker.com/pricing/faq" target="_blank" rel="noopener">FAQ</a></li>
                        <li><a href="https://www.docker.com/partners/programs" target="_blank" rel="noopener">Docker 認定公開者向けプログラム</a></li>
                        <li><a href="https://www.docker.com/partners" target="_blank" rel="noopener">パートナー</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/company" target="_blank" rel="noopener">会社概要</a></b></li>
                        <li><a href="https://www.docker.com/what-container" target="_blank" rel="noopener">コンテナーって何？</a></li>
                        <li><a href="https://www.docker.com/why-docker" target="_blank" rel="noopener">なぜ Docker？</a></li>
                        <li><a href="https://www.docker.com/events" target="_blank" rel="noopener">仮想イベント</a></li>
                        <li><a href="https://www.docker.com/swag" target="_blank" rel="noopener">Swag ストア
                        </a></li>
                        <li><a href="https://www.docker.com/company/newsroom" target="_blank" rel="noopener">ニュースルーム</a></li>
                        <li><a href="https://www.docker.com/careers" target="_blank" rel="noopener">採用情報</a></li>
                        <li><a href="https://www.docker.com/company/contact" target="_blank" rel="noopener">連絡先</a></li>
                        <li><a href="https://www.docker.com/customers" target="_blank" rel="noopener">顧客</a></li>
                        <li><a href="https://www.docker.com/newsletter-subscription" target="_blank" rel="noopener">ニュースレター</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-nav">
                <nav class="footer_sub_nav">
                    <ul class="menu">
                        <li><a href="https://www.docker.com/legal/docker-terms-service" target="_blank" rel="noopener">サービス契約</a></li>
                        <li><a href="https://status.docker.com/" target="_blank" rel="noopener">ステータス</a></li>
                        <li><a href="https://www.docker.com/legal" target="_blank" rel="noopener">法的情報</a></li>
                    </ul>
                </nav>
            </div>
        </div>
        <div class="bottom_footer">
            <div class="footer-copyright col-xs-12 col-md-8">
                <p class="copyright">
                    Copyright &copy; 2013-2021 Docker Inc. All rights reserved. </p>
            </div>
            <div class="footer_social_nav">
                <ul class="nav-social">
                    <li class="fa fa-twitter"><a href="https://twitter.com/docker">Twitter</a></li>
                    <li class="fa fa-youtube"><a href="https://www.youtube.com/user/dockerrun">Youtube</a></li>
                    <li class="fa fa-github"><a href="https://github.com/docker">GitHub</a></li>
                    <li class="fa fa-linkedin"><a href="https://www.linkedin.com/company/docker">Linkedin</a></li>
                    <li class="fa fa-facebook"><a href="https://www.facebook.com/docker.run">Facebook</a></li>
                    <li class="fa fa-slideshare"><a href="https://www.slideshare.net/docker">Slideshare</a></li>
                    <li class="fa fa-reddit"><a href="https://www.reddit.com/r/docker">Reddit</a></li>
                </ul>
            </div>
        </div>
    </div>

    </footer>
    <script>const pageURL = "/engine/reference/commandline/service_create/";</script></body>
</html>
