<!-- Page generated 2020-10-24 20:20:55 +0900-->
<!DOCTYPE html>
<html lang="ja"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>docker build | Docker ドキュメント</title>
  <meta name="description" content="docker build: `docker build` コマンドは Dockerfile と「ビルドコンテキスト」から Docker イメージをビルドします。 ビルドコンテキストとは、指定された `PATH` や `URL` に存在している一連のファイルのことです。 ビルド処理においては、コンテキスト内のどのファイルでも参照できます。 たとえばビルドにおいて [**COPY**](../builder.md#copy) 命令を使っている場合に、コンテキスト内のファイルを参照することができます。 `URL` パラメーターは 3 種類のリソースを参照します。 Git リポジトリ、パッケージングされた tarball コンテキスト、プレーンなテキストファイル、の 3 つです。 {: #git-repositories..." />
  <meta name="keywords" content="docker, docker open source, docker platform, distributed applications, microservices, containers, docker containers, docker software, docker virtualization">
  <link rel="canonical" href="https://localhost:4000{{ site.baseurl }}/engine/reference/commandline/build/" />

  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
  <link rel="apple-touch-icon" type="image/x-icon" href="/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
  <meta name="msapplication-TileImage" content="/docs.docker.jp.onthefly/favicons/docs@2x.ico">
  <meta property="og:image" content="/docs.docker.jp.onthefly/favicons/docs@2x.ico"/>
  <meta name="theme-color" content="#2496ed" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0"><script defer src="/docs.docker.jp.onthefly/js/theme-switcher.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/anchorlinks.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/jquery.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/bootstrap.min.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/docs.js"></script><script defer src="/docs.docker.jp.onthefly/js/search.js"></script><link rel="preload" as="font" href="https://fonts.gstatic.com/s/opensans/v18/mem8YaGs126MiZpBA-UFVZ0bf8pkAg.woff2" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/geomanist/hinted-Geomanist-Book.woff2"    type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/geomanist/hinted-Geomanist-Regular.woff2" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/glyphicons-halflings-regular.woff2"       type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/fontawesome-webfont.woff2?v=4.7.0"        type="font/woff2" crossorigin="anonymous">

  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/font-awesome.min.css">
  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/bootstrap.min.css">
  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/style.css" id="pagestyle">

  <!-- SEO stuff -->
  <meta name="twitter:title" itemprop="title name" content="docker build"/>
  <meta name="twitter:description" property="og:description" itemprop="description" content="docker build: `docker build` コマンドは Dockerfile と「ビルドコンテキスト」から Docker イメージをビルドします。 ビルドコンテキストとは、指定された `PATH` や `URL` に存在している一連のファイルのことです。 ビルド処理においては、コンテキスト内のどのファイルでも参照できます。 たとえばビルドにおいて [**COPY**](../builder.md#copy) 命令を使っている場合に、コンテキスト内のファイルを参照することができます。 `URL` パラメーターは 3 種類のリソースを参照します。 Git リポジトリ、パッケージングされた tarball コンテキスト、プレーンなテキストファイル、の 3 つです。 {: #git-repositories..." />
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:domain" content="matsuand.github.io"/>
  <meta name="twitter:site" content="@docker_docs"/>
  <meta name="twitter:url" content="https://twitter.com/docker_docs"/>
  <meta name="twitter:image:src" content="/docs.docker.jp.onthefly/images/docs@2x.png"/>
  <meta name="twitter:image:alt" content="Docker ドキュメント"/>
  <meta property="og:title" content="docker build" />
  <meta property="og:description" content="docker build: `docker build` コマンドは Dockerfile と「ビルドコンテキスト」から Docker イメージをビルドします。 ビルドコンテキストとは、指定された `PATH` や `URL` に存在している一連のファイルのことです。 ビルド処理においては、コンテキスト内のどのファイルでも参照できます。 たとえばビルドにおいて [**COPY**](../builder.md#copy) 命令を使っている場合に、コンテキスト内のファイルを参照することができます。 `URL` パラメーターは 3 種類のリソースを参照します。 Git リポジトリ、パッケージングされた tarball コンテキスト、プレーンなテキストファイル、の 3 つです。 {: #git-repositories..." />
  <meta property="og:type" content="website"/>
  <meta property="og:updated_time" itemprop="dateUpdated" content="2020-10-24T20:20:55+09:00"/>
  <meta property="og:image" itemprop="image primaryImageOfPage" content="/docs.docker.jp.onthefly/images/docs@2x.png"/>
  <meta property="og:locale" content="ja_JP" />
  <meta property="og:url" content="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/commandline/build/" />
  <meta property="og:site_name" content="Docker ドキュメント" />
  <meta property="article:published_time" itemprop="datePublished" content="2020-10-24T20:20:55+09:00"/>
  <script type="application/ld+json">{"@context":"http://schema.org","@type":"WebPage","headline":"docker build","description":"docker build: `docker build` コマンドは Dockerfile と「ビルドコンテキスト」から Docker イメージをビルドします。 ビルドコンテキストとは、指定された `PATH` や `URL` に存在している一連のファイルのことです。 ビルド処理においては、コンテキスト内のどのファイルでも参照できます。 たとえばビルドにおいて [**COPY**](../builder.md#copy) 命令を使っている場合に、コンテキスト内のファイルを参照することができます。 `URL` パラメーターは 3 種類のリソースを参照します。 Git リポジトリ、パッケージングされた tarball コンテキスト、プレーンなテキストファイル、の 3 つです。 {: #git-repositories...","url":"https://docs.docker.com/engine/reference/commandline/build/"}</script>
  <!-- END SEO STUFF -->
</head>
<body class="colums">
    <header>
        <nav class="nav-secondary navbar navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header">
            <a href="/docs.docker.jp.onthefly/">
                <img class="logo" src="/docs.docker.jp.onthefly/images/docker-docs-logo.svg" alt="Docker Docs" title="Docker Docs" width="160" height="28" />
            </a>
        </div>
        <div class="navbar-collapse" aria-expanded="false" style="height: 1px;">
            <div class="logo-mobile">
    <a href="/docs.docker.jp.onthefly/">
        <img src="/docs.docker.jp.onthefly/images/docker-icon.svg" alt="Docker Docs" title="Docker Docs" width="30" height="30" />
    </a>
</div>
<div class="search-form" id="search-div">
    <form class="search-form form-inline" id="searchForm" action="/docs.docker.jp.onthefly/search/" method="get">
        <label for="st-search-input" class="sr-only">検索</label>
        <input class="search-field form-control ds-input" id="st-search-input" name="q" placeholder="文書内検索" type="search" autocomplete="off" spellcheck="false" dir="auto" style="position: relative; vertical-align: top;">
        <div id="autocompleteResults"></div>
        <!-- <button type="submit" class="search-submit btn btn-default">検索</button> -->
    </form>
</div>
<div class="sidebar-toggle">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
    </button>
</div>
<div class="nav-container hidden-sm hidden-xs">
    <div id="tabs">
        <ul class="tabs jsTOCHorizontal"><li><a href="/docs.docker.jp.onthefly/" id="home">ホーム</a></li><li><a href="/docs.docker.jp.onthefly/get-started/overview/" id="guides">ガイド</a></li><li><a href="/docs.docker.jp.onthefly/engine/" id="manuals">製品マニュアル</a></li><li><a href="/docs.docker.jp.onthefly/reference/" id="reference">リファレンス</a></li><li><a href="/docs.docker.jp.onthefly/samples/" id="samples">サンプル</a></li></ul>
    </div>
    <div class="ctrl-right">
        <a href="javascript:void(0)" id="menu-toggle" aria-label="現在ページのメニュートグル"><i class="fa fa-indent" aria-hidden="true"></i></a>
    </div>
</div>

        </div>
    </div>
</nav>

    </header>
    <div class="wrapper right-open">
        <div class="container-fluid">
            <div class="row">
                <div class="col-body">
                    <main class="col-content content">
                        <section class="section"><h1>docker build</h1><p><em class="reading-time">読む時間の目安: 15 分</em></p><!--
This page is automatically generated from Docker's source code. If you want to
suggest a change to the text that appears here, open a ticket or pull request
in the source repository on GitHub:

https://github.com/docker/cli
-->
<!-- Make sure atom is using hard tabs -->

<h2 id="description">説明</h2>

<p>Dockerfile からイメージをビルドします。</p>

<h2 id="usage">利用方法</h2>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker build [オプション] PATH | URL | -
</span></code></pre></div></div>

<h2 id="extended-description">追加説明</h2>

<p><code class="language-plaintext highlighter-rouge">docker build</code> コマンドは Dockerfile と「ビルドコンテキスト」から Docker イメージをビルドします。
ビルドコンテキストとは、指定された <code class="language-plaintext highlighter-rouge">PATH</code> や <code class="language-plaintext highlighter-rouge">URL</code> に存在している一連のファイルのことです。
ビルド処理においては、コンテキスト内のどのファイルでも参照できます。
たとえばビルドにおいて <a href="/engine/reference/builder/#copy"><strong>COPY</strong></a> 命令を使っている場合に、コンテキスト内のファイルを参照することができます。</p>

<p><code class="language-plaintext highlighter-rouge">URL</code> パラメーターは 3 種類のリソースを参照します。
Git リポジトリ、パッケージングされた tarball コンテキスト、プレーンなテキストファイル、の 3 つです。</p>

<h3 id="git-repositories">Git リポジトリ</h3>

<p><code class="language-plaintext highlighter-rouge">URL</code> パラメーターが Git リポジトリの場所を示している場合、そのリポジトリがビルドコンテキストとして扱われます。
システムはリポジトリとサブモジュールを再帰的にフェッチします。
コミット履歴は保持されません。
リポジトリは初めに、ローカルホスト内の一時的なディレクトリにプルされます。
これが正常処理されると、ディレクトリ内容がコンテキストとして Docker デーモンに送信されます。
ローカルにコピーが存在しているなら、プライベートリポジトリにもアクセス可能になります。
その際にはローカルにあるユーザー認証情報、VPN 情報などが用いられます。</p>

<blockquote>
  <p><strong>メモ</strong></p>

  <p><code class="language-plaintext highlighter-rouge">URL</code> パラメーターが部分的なものであった場合、システムは <code class="language-plaintext highlighter-rouge">git clone --recursive</code> コマンドを実行して、そのリポジトリやサブモジュールを再帰的にクローンします。</p>
</blockquote>

<p>Git URL では、コンテキスト設定にあたって URL の部分指定が可能です。
部分指定にはコロン（<code class="language-plaintext highlighter-rouge">:</code>）を使って区切ります。
コロンより前の 1 つめの項目として Git がチェックアウトを行う URL を指定します。
これはブランチ、タグ、リモートリファレンスのいずれでも可能です。
2 つめの項目には、そのリポジトリ内のサブディレクトリを指定します。
このサブディレクトリがビルドコンテキストとして用いられることになります。</p>

<p>たとえば <code class="language-plaintext highlighter-rouge">container</code> ブランチ内の <code class="language-plaintext highlighter-rouge">docker</code> というディレクトリを利用するには、以下のように実行します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build https://github.com/docker/rootfs.git#container:docker
</code></pre></div></div>

<p>以下に示す表は、ビルドコンテキストとして有効なサフィックス指定の例です。</p>

<table>
  <thead>
    <tr>
      <th>ビルド時のサフィックス指定例</th>
      <th>利用されるコミット</th>
      <th>利用されるビルドコンテキスト</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">myrepo.git</code></td>
      <td><code class="language-plaintext highlighter-rouge">refs/heads/master</code></td>
      <td><code class="language-plaintext highlighter-rouge">/</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">myrepo.git#mytag</code></td>
      <td><code class="language-plaintext highlighter-rouge">refs/tags/mytag</code></td>
      <td><code class="language-plaintext highlighter-rouge">/</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">myrepo.git#mybranch</code></td>
      <td><code class="language-plaintext highlighter-rouge">refs/heads/mybranch</code></td>
      <td><code class="language-plaintext highlighter-rouge">/</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">myrepo.git#pull/42/head</code></td>
      <td><code class="language-plaintext highlighter-rouge">refs/pull/42/head</code></td>
      <td><code class="language-plaintext highlighter-rouge">/</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">myrepo.git#:myfolder</code></td>
      <td><code class="language-plaintext highlighter-rouge">refs/heads/master</code></td>
      <td><code class="language-plaintext highlighter-rouge">/myfolder</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">myrepo.git#master:myfolder</code></td>
      <td><code class="language-plaintext highlighter-rouge">refs/heads/master</code></td>
      <td><code class="language-plaintext highlighter-rouge">/myfolder</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">myrepo.git#mytag:myfolder</code></td>
      <td><code class="language-plaintext highlighter-rouge">refs/tags/mytag</code></td>
      <td><code class="language-plaintext highlighter-rouge">/myfolder</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">myrepo.git#mybranch:myfolder</code></td>
      <td><code class="language-plaintext highlighter-rouge">refs/heads/mybranch</code></td>
      <td><code class="language-plaintext highlighter-rouge">/myfolder</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>メモ</strong></p>

  <p>ビルダーとして BuildKit を利用している（<code class="language-plaintext highlighter-rouge">DOCKER_BUILDKIT=1</code>）場合は、ビルドコンテキスト（上の例では<code class="language-plaintext highlighter-rouge">myfolder</code>）を指定することはできません。
この機能へのサポートは <a href="https://github.com/moby/buildkit/issues/1684">buildkit#1684</a> において行われています。</p>
</blockquote>

<h3 id="tarball-contexts">Tarball コンテキスト</h3>

<p>URL にリモートの tarball を指定した場合、URL がそのままデーモンに送信されます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build http://server/context.tar.gz
</code></pre></div></div>

<p>ダウンロード処理は、Docker デーモンが稼動しているホスト上で実行されます。
このホストは、build コマンドが実行されたホストと同じである必要はありません。
Docker デーモンは <code class="language-plaintext highlighter-rouge">context.tar.gz</code> を取得して、これをビルドコンテキストとして利用します。
tarball コンテキストは UNIX <code class="language-plaintext highlighter-rouge">tar</code> フォーマット標準に適合した tar アーカイブである必要があります。
これを ‘xz’、’bzip2’、’gzip’ により圧縮したフォーマットも受け付けます。
‘identity’（圧縮なし）のフォーマットも利用できます。</p>

<h3 id="text-files">テキストファイル</h3>

<p>コンテキストを指定するのではなく、1 つの Dockerfile を指定することができます。
つまりそのファイル内容を、<code class="language-plaintext highlighter-rouge">STDIN</code> を介してパイプ入力します。
<code class="language-plaintext highlighter-rouge">Dockerfile</code> を <code class="language-plaintext highlighter-rouge">STDIN</code> からパイプ入力するには、以下のようにします。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build - &lt; Dockerfile
</code></pre></div></div>

<p>Windows における Powershell 上では以下のようにします。</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">Get-Content</span><span class="w"> </span><span class="nx">Dockerfile</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">docker</span><span class="w"> </span><span class="nx">build</span><span class="w"> </span><span class="nf">-</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">STDIN</code> を利用するか、<code class="language-plaintext highlighter-rouge">URL</code> によりプレーンテキストファイルを指定した場合、<code class="language-plaintext highlighter-rouge">Dockerfile</code> というファイルにその内容を書き入れます。
この場合 <code class="language-plaintext highlighter-rouge">-f</code> や <code class="language-plaintext highlighter-rouge">--file</code> オプションは無視されます。
この状況では、コンテキストは存在しないものとなります。</p>

<p><code class="language-plaintext highlighter-rouge">docker build</code> コマンドが <code class="language-plaintext highlighter-rouge">Dockerfile</code> を探しにいく場所は、デフォルトではビルドコンテキストのルートディレクトリです。
<code class="language-plaintext highlighter-rouge">-f</code> や <code class="language-plaintext highlighter-rouge">--file</code> オプションを使うと、別のファイルを利用するように指定できます。
これは同一のファイル群を使って、ビルドを何度か行う場合に便利です。
パスはビルドコンテキスト内のファイルを表わしていなければなりません。
相対パスが指定された場合は、コンテキストのルートからの相対パスと解釈されます。</p>

<p>ほとんどの場合、Dockerfile は空のディレクトリに置くのがベストです。
Dockerfile のビルドに必要となるファイルのみを、後からそのディレクトリに追加します。
ビルド性能を向上させるため、不要なファイルやディレクトリを指定する <code class="language-plaintext highlighter-rouge">.dockerignore</code> を、そのディレクトリに加えることもあります。
そのファイルの生成に関しては <a href="/engine/reference/builder/#dockerignore-file">.dockerignore ファイル</a> を参照してください。</p>

<p>Docker クライアントがデーモンとの接続を失った場合、ビルドはキャンセルされます。
これはたとえば Docker クライアント上において <code class="language-plaintext highlighter-rouge">CTRL-c</code> により処理中断した場合や、Docker クライアントが何か別の理由により異常終了した場合に発生します。
ビルドがキャンセルされる直前の動作中に、プル処理を初期化していた場合、そのプル処理も同じくキャンセルされます。</p>

<p>本コマンドの利用例については、以下に示す <a href="#examples">利用例の節</a> を参照してください。</p>

<h2 id="options">オプション</h2>

<table>
<thead>
  <tr>
    <td>名前／省略形</td>
    <td>デフォルト</td>
    <td>説明</td>
  </tr>
</thead>
<tbody>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--add-host</code></td>
    <td></td>
    <td>ホスト－IP マッピングのカスタム設定を追加します。(ホスト名:ip)</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--build-arg</code></td>
    <td></td>
    <td>ビルド時の変数を設定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--cache-from</code></td>
    <td></td>
    <td>キャッシュから取得すべきイメージ。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--cgroup-parent</code></td>
    <td></td>
    <td>任意に指定するコンテナーの親 cgroup。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--compress</code></td>
    <td></td>
    <td>ビルドコンテキストを gzip を使って圧縮します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--cpu-period</code></td>
    <td></td>
    <td>CPU の CFS（Completely Fair Scheduler）間隔を制限します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--cpu-quota</code></td>
    <td></td>
    <td>CPU の CFS（Completely Fair Scheduler）クォータを制限します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--cpu-shares , -c</code></td>
    <td></td>
    <td>CPU 配分。（相対的な重みづけ）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--cpuset-cpus</code></td>
    <td></td>
    <td>利用を許容する CPU 数。（0-3、0,1）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--cpuset-mems</code></td>
    <td></td>
    <td>利用を許容するメモリ数。（0-3、0,1）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--disable-content-trust</code></td>
    <td><code class="language-plaintext highlighter-rouge">true</code></td>
    <td>イメージの検証を省略します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--file , -f</code></td>
    <td></td>
    <td>Dockerfile 名。（デフォルトは ‘PATH/Dockerfile’）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--force-rm</code></td>
    <td></td>
    <td>中間コンテナーを常に削除します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--iidfile</code></td>
    <td></td>
    <td>イメージ ID をファイルに出力します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--isolation</code></td>
    <td></td>
    <td>コンテナーの分離技術（isolation technology）方式。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--label</code></td>
    <td></td>
    <td>イメージに対してメタデータを設定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--memory , -m</code></td>
    <td></td>
    <td>メモリ上限。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--memory-swap</code></td>
    <td></td>
    <td>メモリとスワップの総量を制限します。’-1’ 設定時はスワップ無制限。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--network</code></td>
    <td></td>
    <td><a href="/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle=" API リファレンスを開きます。(別ウィンドウ)">API 1.25+</span></a><br />ビルド時の RUN 命令に対してネットワークモードを設定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--no-cache</code></td>
    <td></td>
    <td>イメージビルド時にキャッシュを利用しません。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--output , -o</code></td>
    <td></td>
    <td><a href="/engine/api/v1.40/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle=" API リファレンスを開きます。(別ウィンドウ)">API 1.40+</span></a><br />出力先。（フォーマット: type=local,dest=path）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--platform</code></td>
    <td></td>
    <td><a href="/engine/api/v1.38/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle=" API リファレンスを開きます。(別ウィンドウ)">API 1.38+</span></a><br />サーバーがマルチプラットフォームに対応している場合に、プラットフォームを指定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--progress</code></td>
    <td><code class="language-plaintext highlighter-rouge">auto</code></td>
    <td>処理経過の出力タイプを設定します（auto、plain、tty）。コンテナー出力には plain が用いられます。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--pull</code></td>
    <td></td>
    <td>常に最新イメージのプルを試みます。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--quiet , -q</code></td>
    <td></td>
    <td>ビルド出力を省略し、処理成功時にはイメージ ID を表示します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--rm</code></td>
    <td><code class="language-plaintext highlighter-rouge">true</code></td>
    <td>ビルド成功後に中間コンテナーを削除します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--secret</code></td>
    <td></td>
    <td><a href="/engine/api/v1.39/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle=" API リファレンスを開きます。(別ウィンドウ)">API 1.39+</span></a><br />ビルド時に公開する Secret ファイル（BuildKit 有効時のみ)。 id=mysecret,src=/local/secret</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--security-opt</code></td>
    <td></td>
    <td>セキュリティオプション。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--shm-size</code></td>
    <td></td>
    <td>/dev/shm のサイズ。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--squash</code></td>
    <td></td>
    <td><a href="/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener" class="_"><span class="badge badge-warning" data-toggle="tooltip" title="デーモンの試験的オプションを確認します。(別ウィンドウ)">試験的 (デーモン)</span></a><a href="/engine/api/v1.25/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle=" API リファレンスを開きます。(別ウィンドウ)">API 1.25+</span></a><br />ビルドしたレイヤーを単一の新レイヤーに押し込みます（squash します）。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--ssh</code></td>
    <td></td>
    <td><a href="/engine/api/v1.39/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle=" API リファレンスを開きます。(別ウィンドウ)">API 1.39+</span></a><br />ビルド時に公開する SSH エージェントソケットまたは SSH 鍵（BuildKit 有効時のみ）。（フォーマット: default|&lt;id&gt;[=&lt;socket&gt;|&lt;key&gt;[,&lt;key&gt;]]）</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--stream</code></td>
    <td></td>
    <td><a href="/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener" class="_"><span class="badge badge-warning" data-toggle="tooltip" title="デーモンの試験的オプションを確認します。(別ウィンドウ)">試験的 (デーモン)</span></a><a href="/engine/api/v1.31/" target="_blank" rel="noopener" class="_"><span class="badge badge-info" data-toggle="tooltip" ttitle=" API リファレンスを開きます。(別ウィンドウ)">API 1.31+</span></a><br />ビルドコンテキストをやり取りするためにサーバーにアタッチするストリーム。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--tag , -t</code></td>
    <td></td>
    <td>書式 ‘name:tag’ により名前および任意のタグを指定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--target</code></td>
    <td></td>
    <td>ビルド対象とするビルドステージを指定します。</td>
  </tr>

  
  
  
  
  
  
  
  
  <tr>
    <td><code class="language-plaintext highlighter-rouge">--ulimit</code></td>
    <td></td>
    <td>ulimit オプション。</td>
  </tr>
 <!-- end for option -->
</tbody>
</table>
<p><!-- end if options --></p>

<h2 id="examples">利用例</h2>

<h3 id="build-with-path">PATH を使ったビルド</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nb">.</span>

Uploading context 10240 bytes
Step 1/3 : FROM busybox
Pulling repository busybox
 <span class="nt">---</span><span class="o">&gt;</span> e9aa60c60128MB/2.284 MB <span class="o">(</span>100%<span class="o">)</span> endpoint: https://cdn-registry-1.docker.io/v1/
Step 2/3 : RUN <span class="nb">ls</span> <span class="nt">-lh</span> /
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>9c9e81692ae9
total 24
drwxr-xr-x    2 root     root        4.0K Mar 12  2013 bin
drwxr-xr-x    5 root     root        4.0K Oct 19 00:19 dev
drwxr-xr-x    2 root     root        4.0K Oct 19 00:19 etc
drwxr-xr-x    2 root     root        4.0K Nov 15 23:34 lib
lrwxrwxrwx    1 root     root           3 Mar 12  2013 lib64 -&gt; lib
dr-xr-xr-x  116 root     root           0 Nov 15 23:34 proc
lrwxrwxrwx    1 root     root           3 Mar 12  2013 sbin -&gt; bin
dr-xr-xr-x   13 root     root           0 Nov 15 23:34 sys
drwxr-xr-x    2 root     root        4.0K Mar 12  2013 tmp
drwxr-xr-x    2 root     root        4.0K Nov 15 23:34 usr
 <span class="nt">---</span><span class="o">&gt;</span> b35f4035db3f
Step 3/3 : CMD <span class="nb">echo </span>Hello world
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>02071fceb21b
 <span class="nt">---</span><span class="o">&gt;</span> f52f38b7823e
Successfully built f52f38b7823e
Removing intermediate container 9c9e81692ae9
Removing intermediate container 02071fceb21b
</code></pre></div></div>

<p>上の例では<code class="language-plaintext highlighter-rouge">PATH</code>に<code class="language-plaintext highlighter-rouge">.</code>を指定しています。
そこでローカルディレクトリ内のファイルが<code class="language-plaintext highlighter-rouge">tar</code>によってまとめられて Docker デーモンに送られます。
<code class="language-plaintext highlighter-rouge">PAHT</code>は、Docker デーモン上でビルドが行われる際の「コンテキスト」として、対象とするファイルを探し出す場所を意味します。
デーモンというものは、リモートマシン上でも起動可能であることを思い出してください。
クライアント側（<code class="language-plaintext highlighter-rouge">docker build</code>を実行するマシン）において Dockerfile に何かが起こったとしても、それを検知することはできません。
つまり<code class="language-plaintext highlighter-rouge">PATH</code>上のファイルは <strong>すべて</strong> 送信されます。
ただし Dockerfile 内の <a href="/engine/reference/builder/#add"><strong>ADD</strong></a> が扱うファイルは別です。</p>

<p>コンテキストがローカルマシンから Docker デーモンに送信される様子は、<code class="language-plaintext highlighter-rouge">docker</code>クライアントにおいて「Sending build context」（ビルドコンテキストを送信中）というメッセージからわかります。</p>

<p>ビルド処理を終えたときに中間コンテナーを残しておきたい場合は<code class="language-plaintext highlighter-rouge">--rm=false</code>を用います。
これを用いてもビルドキャッシュには影響しません。</p>

<h3 id="build-with-url">URL を使ったビルド</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build github.com/creack/docker-firefox
</code></pre></div></div>

<p>上では GitHub リポジトリをクローンして、クラウドリポジトリをコンテキストとします。
リポジトリのルートにある Dockerfile が、処理における Dockerfile として用いられます。
スキーム指定<code class="language-plaintext highlighter-rouge">git://</code>や<code class="language-plaintext highlighter-rouge">git@</code>を使って、どのような Git リポジトリでも指定することができます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-f</span> ctx/Dockerfile http://server/ctx.tar.gz

Downloading context: http://server/ctx.tar.gz <span class="o">[===================&gt;]</span>    240 B/240 B
Step 1/3 : FROM busybox
 <span class="nt">---</span><span class="o">&gt;</span> 8c2e06607696
Step 2/3 : ADD ctx/container.cfg /
 <span class="nt">---</span><span class="o">&gt;</span> e7829950cee3
Removing intermediate container b35224abf821
Step 3/3 : CMD /bin/ls
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>fbc63d321d73
 <span class="nt">---</span><span class="o">&gt;</span> 3286931702ad
Removing intermediate container fbc63d321d73
Successfully built 377c409b35e4
</code></pre></div></div>

<p>上では URL<code class="language-plaintext highlighter-rouge">http://server/ctx.tar.gz</code>を Docker デーモンに送っています。
こうすると、指定された tarball をダウンロードし、伸張（解凍）が行われます。
パラメーター<code class="language-plaintext highlighter-rouge">-f ctx/Dockerfile</code>は、イメージをビルドする際に利用する<code class="language-plaintext highlighter-rouge">Dockerfile</code>を<code class="language-plaintext highlighter-rouge">ctx.tar.gz</code>内部のパスとして指定しています。
その<code class="language-plaintext highlighter-rouge">Dockerfile</code>内に<code class="language-plaintext highlighter-rouge">ADD</code>コマンドがあって、それがローカルパスを参照しているものであれば、それはすべて<code class="language-plaintext highlighter-rouge">ctx.tar.gz</code>内ファイルのルートからの相対パスでなければなりません。
上の例において tarball は<code class="language-plaintext highlighter-rouge">ctx/</code>というディレクトリを含むものとしています。
したがって<code class="language-plaintext highlighter-rouge">ADD ctx/container.cfg /</code>という命令であれば、期待どおりに動作します。</p>

<h3 id="build-with--">- を使ったビルド</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build - &lt; Dockerfile
</code></pre></div></div>

<p>上の例ではコンテキストを利用せず、Dockerfile を<code class="language-plaintext highlighter-rouge">STDIN</code>から読み込みます。
コンテキストがないわけですから、ローカルディレクトリ内から Docker デーモンに送信されるものは何もないということです。
コンテキストがないため、Dockerfile 内の<code class="language-plaintext highlighter-rouge">ADD</code>は、リモート URL を参照しているものだけが正しく動作します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build - &lt; context.tar.gz
</code></pre></div></div>

<p>上の例は、圧縮されたコンテキストを<code class="language-plaintext highlighter-rouge">STDIN</code>から読み込んでイメージをビルドします。
サポートされるフォーマットは bzip2、gzip、xz です。</p>

<h3 id="use-a-dockerignore-file">.dockerignore ファイルの利用</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nb">.</span>

Uploading context 18.829 MB
Uploading context
Step 1/2 : FROM busybox
 <span class="nt">---</span><span class="o">&gt;</span> 769b9341d937
Step 2/2 : CMD <span class="nb">echo </span>Hello world
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 99cc1ad10469
Successfully built 99cc1ad10469
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">".git"</span> <span class="o">&gt;</span> .dockerignore
<span class="nv">$ </span>docker build <span class="nb">.</span>
Uploading context  6.76 MB
Uploading context
Step 1/2 : FROM busybox
 <span class="nt">---</span><span class="o">&gt;</span> 769b9341d937
Step 2/2 : CMD <span class="nb">echo </span>Hello world
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 99cc1ad10469
Successfully built 99cc1ad10469
</code></pre></div></div>

<p>上の例では<code class="language-plaintext highlighter-rouge">.dockerignore</code>ファイルを利用して、コンテキストから<code class="language-plaintext highlighter-rouge">.git</code>ディレクトリを除外しています。
その効果は、アップロードされたコンテキストの変更後のサイズからわかります。
Dockerfile リファレンスにおいて、<a href="/engine/reference/builder/#dockerignore-file">.dockerignore ファイルの生成</a> を詳しく説明しています。</p>

<p><a href="/engine/reference/builder/#buildkit">BuildKit バックエンド</a> を利用すると、<code class="language-plaintext highlighter-rouge">docker build</code>コマンドは Dockerfile 名に関連づいた<code class="language-plaintext highlighter-rouge">.dockerignore</code>ファイルを検索するようになります。
たとえば<code class="language-plaintext highlighter-rouge">docker build -f myapp.Dockerfile .</code>を実行した場合、最初に検索される ignore ファイルは<code class="language-plaintext highlighter-rouge">myapp.Dockerfile.dockerignore</code>というファイルです。
そういったファイルがみつからなかったら、次に<code class="language-plaintext highlighter-rouge">.dockerignore</code>ファイルがあればこれが利用されます。
<code class="language-plaintext highlighter-rouge">.dockerignore</code>と関連づいて Dockerfile が利用できるのは便利なことです。
たとえばプロジェクト内に複数の Dockerfile があって、それぞれに異なる ignore ファイルの設定が必要な場合です。</p>

<h3 id="tag-an-image--t">イメージへのタグづけ (-t)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> vieux/apache:2.0 <span class="nb">.</span>
</code></pre></div></div>

<p>上のコマンドは前の例と同じようなビルドを行います。
ただし結果となるイメージにタグをつけます。
リポジトリ名が<code class="language-plaintext highlighter-rouge">vieux/apache</code>であり、タグ名が<code class="language-plaintext highlighter-rouge">2.0</code>です。
詳しくは <a href="/engine/reference/commandline/tag/">適正なタグ</a> を参照してください。</p>

<p>1 つのイメージに対しては複数のタグをつけることができます。
たとえば最新のビルドイメージに対して<code class="language-plaintext highlighter-rouge">latest</code>というタグをつけ、特定のバージョンを指し示すために別のタグをつけるといった具合です。
例として 2 つのイメージを対象にして<code class="language-plaintext highlighter-rouge">whenry/fedora-jboss:latest</code>と<code class="language-plaintext highlighter-rouge">whenry/fedora-jboss:v2.1</code>のように設定するには、以下を実行します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> whenry/fedora-jboss:latest <span class="nt">-t</span> whenry/fedora-jboss:v2.1 <span class="nb">.</span>
</code></pre></div></div>

<h3 id="specify-a-dockerfile--f">Dockerfile の指定 (-f)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-f</span> Dockerfile.debug <span class="nb">.</span>
</code></pre></div></div>

<p>上では、ビルドの命令を行うファイルとして<code class="language-plaintext highlighter-rouge">Dockerfile</code>ではなく<code class="language-plaintext highlighter-rouge">Dockerfile.debug</code>を指定しています。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl example.com/remote/Dockerfile | docker build <span class="nt">-f</span> - <span class="nb">.</span>
</code></pre></div></div>

<p>上のコマンドはカレントディレクトリをビルドコンテキストとし、Dockerfile を標準入力から読み込みます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-f</span> dockerfiles/Dockerfile.debug <span class="nt">-t</span> myapp_debug <span class="nb">.</span>
<span class="nv">$ </span>docker build <span class="nt">-f</span> dockerfiles/Dockerfile.prod  <span class="nt">-t</span> myapp_prod <span class="nb">.</span>
</code></pre></div></div>

<p>上の 2 つのコマンドは（ピリオド<code class="language-plaintext highlighter-rouge">.</code>が指定されているので）カレントディレクトリをビルドコンテキストとして 2 回のビルドを行います。
1 度めはデバッグバージョンの<code class="language-plaintext highlighter-rouge">Dockerfile</code>を使い、2 度めは本番環境バージョンを使います。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> /home/me/myapp/some/dir/really/deep
<span class="nv">$ </span>docker build <span class="nt">-f</span> /home/me/myapp/dockerfiles/debug /home/me/myapp
<span class="nv">$ </span>docker build <span class="nt">-f</span> ../../../../dockerfiles/debug /home/me/myapp
</code></pre></div></div>

<p>この 2 つの<code class="language-plaintext highlighter-rouge">docker build</code>コマンドは、まったく同じことを行います。
いずれも<code class="language-plaintext highlighter-rouge">Dockerfile</code>を用いるのではなく、<code class="language-plaintext highlighter-rouge">debug</code>というファイルの内容を利用しています。
そしてビルドコンテキストのルートを<code class="language-plaintext highlighter-rouge">/home/me/myapp</code>としています。
ですから<code class="language-plaintext highlighter-rouge">debug</code>というファイルは、コマンドライン上でどのように参照していようが、結局はビルドコンテキストのディレクトリ構造内のものとなります。</p>

<blockquote>
  <p><strong>メモ</strong></p>

  <p>ビルドコンテキストがアップロードされたときに、ファイルやディレクトリが存在していないと、<code class="language-plaintext highlighter-rouge">docker build</code>コマンドは<code class="language-plaintext highlighter-rouge">no such file or directory</code>のエラーを出力します。
よくあるのがコンテキストが存在していない場合や、ホストシステムのまったく別の場所に置かれているファイルを指定したような場合です。
セキュリティ上の理由から、コンテキストはカレントディレクトリ（およびそのサブディレクトリ）に限定されます。
またリモートの Docker ホスト上において何度でも確実にビルドできるものでなければなりません。
<code class="language-plaintext highlighter-rouge">ADD ../file</code>が動作しないのも、この理由によります。</p>
</blockquote>

<h3 id="use-a-custom-parent-cgroup---cgroup-parent">独自の親 cgroup の利用 (--cgroup-parent)</h3>

<p><code class="language-plaintext highlighter-rouge">docker build</code>において<code class="language-plaintext highlighter-rouge">--cgroup-parent</code>オプションをつけて実行すると、ビルドに用いられたコンテナーが、<a href="/engine/reference/run#specify-custom-cgroups">対応する<code class="language-plaintext highlighter-rouge">docker run</code>フラグ</a> を用いて実行されることになります。</p>

<h3 id="set-ulimits-in-container---ulimit">コンテナーの ulimit 設定 (--ulimit)</h3>

<p><code class="language-plaintext highlighter-rouge">docker build</code>に<code class="language-plaintext highlighter-rouge">--ulimit</code>オプションを指定すると、各ビルドステップのコンテナーが、この<a href="/engine/reference/commandline/run/#set-ulimits-in-container---ulimit"><code class="language-plaintext highlighter-rouge">--ulimit</code>フラグ値</a> を用いて開始されます。</p>

<h3 id="set-build-time-variables---build-arg">ビルド時変数の設定 (--build-arg)</h3>

<p>Dockerfile ファイル内に<code class="language-plaintext highlighter-rouge">ENV</code>命令を用いれば、変数を定義することができます。
その値はビルドされるイメージに保持されます。
しかし場合によっては、イメージ内に保持したくないこともあります。
イメージをビルドするホストがさまざまであって、変数はそれに応じて設定したくなることがあるからです。</p>

<p>これをうまく利用した例として<code class="language-plaintext highlighter-rouge">http_proxy</code>と、中間ファイルをプルするそのソースバージョンがあります。
<code class="language-plaintext highlighter-rouge">ARG</code>命令には Dockerfile 作者が定義する値が設定されますが、それをビルド時に<code class="language-plaintext highlighter-rouge">--build-arg</code>フラグを用いて再設定することができます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">--build-arg</span> <span class="nv">HTTP_PROXY</span><span class="o">=</span>http://10.20.30.2:1234 <span class="nt">--build-arg</span> <span class="nv">FTP_PROXY</span><span class="o">=</span>http://40.50.60.5:4567 <span class="nb">.</span>
</code></pre></div></div>

<p>このフラグにはビルド時の変数を設定できます。
ちょうど Dockerfile の<code class="language-plaintext highlighter-rouge">RUN</code>命令において、通常の環境変数にアクセスできることと同じです。
また<code class="language-plaintext highlighter-rouge">ENV</code>における値とは違って、これらの値は中間イメージや最終イメージには残りません。
ビルド時の値は、実行のたびに<code class="language-plaintext highlighter-rouge">--build-arg</code>に与えなければなりません。</p>

<p>Dockerfile によるビルド処理時に Dockerfile 内の<code class="language-plaintext highlighter-rouge">ARG</code>命令が出力する表示は、このフラグを使っていても変わることはありません。</p>

<p><code class="language-plaintext highlighter-rouge">ARG</code>命令と<code class="language-plaintext highlighter-rouge">ENV</code>命令に関する詳細は <a href="/engine/reference/builder/">Dockerfile リファレンス</a> を参照してください。</p>

<p><code class="language-plaintext highlighter-rouge">--build-arg</code>フラグには値を設定しないこともあります。
その場合は、ビルドされるコンテナーに対して、ローカルの環境変数の値が与えられます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">export </span><span class="nv">HTTP_PROXY</span><span class="o">=</span>http://10.20.30.2:1234
<span class="nv">$ </span>docker build <span class="nt">--build-arg</span> HTTP_PROXY <span class="nb">.</span>
</code></pre></div></div>

<p>これは<code class="language-plaintext highlighter-rouge">docker run -e</code>の動作に似ています。
詳しくは<a href="http://lfstranslation/docker/engine/reference/commandline/run/#set-environment-variables--e---env---env-file"><code class="language-plaintext highlighter-rouge">docker run</code> ドキュメント</a> を参照してください。</p>

<h3 id="optional-security-options---security-opt">任意指定のセキュリティオプション (--security-opt)</h3>

<p>このフラグは Windows 上に起動するデーモンに対してのみサポートされています。
そしてサポートされるのは<code class="language-plaintext highlighter-rouge">credentialspec</code>オプションのみです。
<code class="language-plaintext highlighter-rouge">credentialspec</code>の記述書式は<code class="language-plaintext highlighter-rouge">file://spec.txt</code>または<code class="language-plaintext highlighter-rouge">registry://keyname</code>というものでなければなりません。</p>

<h3 id="specify-isolation-technology-for-container---isolation">コンテナーに対する分離技術方式の指定 (--isolation)</h3>

<p>このオプションは Docker コンテナーを Windows 上で実行する場合に有用なものです。
<code class="language-plaintext highlighter-rouge">--isolation=&lt;設定値&gt;</code>は、コンテナーの分離技術（isolation technology）方式を指定します。
Linux 上においては、Linux 名前空間を利用する<code class="language-plaintext highlighter-rouge">default</code>指定のみがサポートされます。
Microsoft Windows の場合、以下の値を設定することができます。</p>

<table>
  <thead>
    <tr>
      <th>設定値</th>
      <th>内容説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">default</code></td>
      <td>Docker デーモンの<code class="language-plaintext highlighter-rouge">--exec-opt</code>の指定に従います。<code class="language-plaintext highlighter-rouge">daemon</code>に分離技術が指定されていない場合、Microsoft Windows はデフォルトとして<code class="language-plaintext highlighter-rouge">process</code>を採用します。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">process</code></td>
      <td>名前空間による分離のみを行います。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hyperv</code></td>
      <td>ハイパーバイザー Hyper-V によるパーティションベースの分離を行います。</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">--isolation</code>フラグに値を設定しなかった場合、<code class="language-plaintext highlighter-rouge">--isolation="default"</code>と指定したことになります。</p>

<h3 id="add-entries-to-container-hosts-file---add-host">コンテナーの hosts ファイルへの項目追加 (--add-host)</h3>

<p>コンテナーの<code class="language-plaintext highlighter-rouge">/etc/hosts</code>ファイルに、別のホストの情報を追加することができます。
これには<code class="language-plaintext highlighter-rouge">--add-host</code>フラグを使います。
その指定は必要な分だけ行うことができます。
以下の例では、<code class="language-plaintext highlighter-rouge">docker</code>という名前のホストに対するスタティックアドレスを加えるものです。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker build --add-host=docker:10.180.0.1 .
</code></pre></div></div>

<h3 id="specifying-target-build-stage---target">ターゲットとするビルドステージの指定 (--target)</h3>

<p>Dockerfile のビルドにおいてマルチステージビルドを採用している場合、中間にあるビルドステージ名を指定して、これを結果イメージに対する最終ステージとすることができます。
指定されたステージ以降にある命令は処理されません。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> debian AS build-env</span>
...

<span class="k">FROM</span><span class="s"> alpine AS production-env</span>
...
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> mybuildimage <span class="nt">--target</span> build-env <span class="nb">.</span>
</code></pre></div></div>

<h3 id="custom-build-outputs">独自のビルド出力</h3>

<p>ローカルのコンテナーイメージというものは、デフォルトではビルド結果として生成されるものです。
<code class="language-plaintext highlighter-rouge">--output</code>（<code class="language-plaintext highlighter-rouge">-o</code>）フラグを用いると、この動作をオーバーライドすることができます。
これには独自のエクスポーターを指定します。
たとえば独自のエクスポーターによって、ビルド生成結果を Docker イメージとするのではなく、ローカルファイルシステム上のファイルとして出力できるようになります。
こういうものがあれば、ローカルの実行モジュール生成やコードジェネレーターに活用できます。</p>

<p><code class="language-plaintext highlighter-rouge">--output</code>に指定するのはカンマ区切りの文字列であり、これによってエクスポーターのタイプとオプションを指定します。
今のところサポートされるエクスポーターは<code class="language-plaintext highlighter-rouge">local</code>と<code class="language-plaintext highlighter-rouge">tar</code>だけです。
<code class="language-plaintext highlighter-rouge">local</code>エクスポーターは、生成されるビルドファイルを、クライアント側のディレクトリに書き込みます。
<code class="language-plaintext highlighter-rouge">tar</code>エクスポーターはそれと同様ですが、ファイルの書き込みは 1 つの tarball（<code class="language-plaintext highlighter-rouge">.tar</code>）とします。</p>

<p>タイプが指定されていない場合、デフォルトは local エクスポーターの出力ディレクトリになります。
ハイフン（<code class="language-plaintext highlighter-rouge">-</code>）を指定すると、出力する tarball を標準出力（<code class="language-plaintext highlighter-rouge">STDOUT</code>）に出力します。</p>

<p>以下の例では、ビルドコンテキストをカレントディレクトリ（<code class="language-plaintext highlighter-rouge">.</code>）としてイメージをビルドします。
そして出力ファイルを、カレントディレクトリにある<code class="language-plaintext highlighter-rouge">out</code>というディレクトリにエクスポートします。
そのディレクトリが存在しない場合、Docker はそのディレクトリを自動生成します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-o</span> out <span class="nb">.</span>
</code></pre></div></div>

<p>上の例では短いオプション指定を用いており<code class="language-plaintext highlighter-rouge">type</code>オプションは省略していました。
したがってデフォルトの（<code class="language-plaintext highlighter-rouge">local</code>）エクスポーターが用いられます。
以下の例では同等の指定を長いオプション指定で行い、CSV によって<code class="language-plaintext highlighter-rouge">type</code>と<code class="language-plaintext highlighter-rouge">dest</code>（出力パス）を指定しています。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">--output</span> <span class="nb">type</span><span class="o">=</span><span class="nb">local</span>,dest<span class="o">=</span>out <span class="nb">.</span>
</code></pre></div></div>

<p>タイプとして<code class="language-plaintext highlighter-rouge">tar</code>を指定すると、ファイルを<code class="language-plaintext highlighter-rouge">.tar</code>アーカイブとしてエクスポートします。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">--output</span> <span class="nb">type</span><span class="o">=</span><span class="nb">tar</span>,dest<span class="o">=</span>out.tar <span class="nb">.</span>
</code></pre></div></div>

<p>以下の例では同時ことを短いオプション指定により行います。
この場合、出力先として<code class="language-plaintext highlighter-rouge">-</code>を指定しているので、タイプとして<code class="language-plaintext highlighter-rouge">tar</code>が自動的に選択され、tarball を標準出力します。
そしてこれを<code class="language-plaintext highlighter-rouge">out.tar</code>ファイルにリダイレクトします。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-o</span> - <span class="nb">.</span> <span class="o">&gt;</span> out.tar
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">--output</code>オプションでは、ターゲット指定されたステージから全ファイルをエクスポートします。
特定ステージのファイルのみをエクスポートするこの方法は、マルチステージビルドによって生成されたファイルを、次の新たなステージのベースとして<a href="/engine/reference/builder/#copy"><code class="language-plaintext highlighter-rouge">COPY --from</code></a> を使ってコピーする形でよく利用されます。</p>

<p>以下の<code class="language-plaintext highlighter-rouge">Dockerfile</code>例ではビルドステージを分けて、エクスポートしたビルド結果を集約しています。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> golang AS build-stage</span>
<span class="k">RUN </span>go get <span class="nt">-u</span> github.com/LK4D4/vndr

<span class="k">FROM</span><span class="s"> scratch AS export-stage</span>
<span class="k">COPY</span><span class="s"> --from=build-stage /go/bin/vndr /</span>
</code></pre></div></div>

<p>Dockerfile によるビルドにおいて<code class="language-plaintext highlighter-rouge">-o</code>オプションを利用すると、最終ステージにおけるファイルのみが<code class="language-plaintext highlighter-rouge">out</code>ディレクトリにエクスポートされます。
それはこの例では<code class="language-plaintext highlighter-rouge">vndr</code>バイナリモジュールとなります。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-o</span> out <span class="nb">.</span>

<span class="o">[</span>+] Building 2.3s <span class="o">(</span>7/7<span class="o">)</span> FINISHED
 <span class="o">=&gt;</span> <span class="o">[</span>internal] load build definition from Dockerfile                                                                          0.1s
 <span class="o">=&gt;</span> <span class="o">=&gt;</span> transferring dockerfile: 176B                                                                                          0.0s
 <span class="o">=&gt;</span> <span class="o">[</span>internal] load .dockerignore                                                                                             0.0s
 <span class="o">=&gt;</span> <span class="o">=&gt;</span> transferring context: 2B                                                                                               0.0s
 <span class="o">=&gt;</span> <span class="o">[</span>internal] load metadata <span class="k">for </span>docker.io/library/golang:latest                                                              1.6s
 <span class="o">=&gt;</span> <span class="o">[</span>build-stage 1/2] FROM docker.io/library/golang@sha256:2df96417dca0561bf1027742dcc5b446a18957cd28eba6aa79269f23f1846d3f   0.0s
 <span class="o">=&gt;</span> <span class="o">=&gt;</span> resolve docker.io/library/golang@sha256:2df96417dca0561bf1027742dcc5b446a18957cd28eba6aa79269f23f1846d3f               0.0s
 <span class="o">=&gt;</span> CACHED <span class="o">[</span>build-stage 2/2] RUN go get <span class="nt">-u</span> github.com/LK4D4/vndr                                                              0.0s
 <span class="o">=&gt;</span> <span class="o">[</span>export-stage 1/1] COPY <span class="nt">--from</span><span class="o">=</span>build-stage /go/bin/vndr /                                                                 0.2s
 <span class="o">=&gt;</span> exporting to client                                                                                                       0.4s
 <span class="o">=&gt;</span> <span class="o">=&gt;</span> copying files 10.30MB                                                                                                  0.3s

<span class="nv">$ </span><span class="nb">ls</span> ./out
vndr
</code></pre></div></div>

<blockquote>
  <p><strong>メモ</strong></p>

  <p>この機能を利用するためには BuildKit バックエンドが必要です。
<a href="/engine/reference/builder/#buildkit">BuildKit の有効化</a> を行ってください。
あるいは <a href="https://github.com/docker/buildx">buildx</a> プラグインを利用すれば、別の出力タイプオプションも提供されます。</p>
</blockquote>

<h3 id="specifying-external-cache-sources">外部キャッシュソースの指定</h3>

<p>ローカルのビルドキャッシュだけでなく、ビルド処理では以前のビルドにおいて生成されたキャッシュを再利用できます。
これを行うには<code class="language-plaintext highlighter-rouge">--cache-from</code>フラグを用います。
そしてこれがレジストリ内のイメージを指し示すようにします。</p>

<p>キャッシュソースとしてイメージを指定するためには、そのイメージの生成時にキャッシュメタデータをイメージ内に書き込んでおく必要があります。
これはイメージのビルド時に<code class="language-plaintext highlighter-rouge">--build-arg BUILDKIT_INLINE_CACHE=1</code>を指定します。
こうしておくと後々のビルドに対して、キャッシュソースとしてこのイメージが利用できます。</p>

<p>キャッシュをインポートする際に、ビルド処理ではレジストリから JSON メタデータのみをプルします。
そしてその情報に基づいて、キャッシュがヒットするかどうかを判断します。
キャッシュがヒットすれば、該当するレイヤーがローカル環境にプルされます。</p>

<p>キャッシュがプルするのはイメージだけではありません。
<a href="https://github.com/docker/buildx"><code class="language-plaintext highlighter-rouge">buildx</code></a> や BuildKit CLI（<code class="language-plaintext highlighter-rouge">buildctl</code>）によって生成される特殊なキャッシュマニフェストもプルすることができます。
このようなマニフェストは（ビルド時に<code class="language-plaintext highlighter-rouge">type=registry</code>と<code class="language-plaintext highlighter-rouge">mode=max</code>を指定するものであり）、マルチステージビルドにおける中間ステージから、レイヤーデータがプルできるようになります。</p>

<p>以下の例では、インラインキャッシュメタデータを使ってイメージのビルドを行い、レジストリへプッシュします。
これにより別マシンにおいて、このイメージをキャッシュソースとして利用できるようにします。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> myname/myapp <span class="nt">--build-arg</span> <span class="nv">BUILDKIT_INLINE_CACHE</span><span class="o">=</span>1 <span class="nb">.</span>
<span class="nv">$ </span>docker push myname/myapp
</code></pre></div></div>

<p>イメージをプッシュした後、別マシンからキャッシュソースとしてこのイメージを利用します。
BuildKit が必要に応じてレジストリからイメージを自動的にプルします。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 別マシン上</span>
<span class="nv">$ </span>docker build <span class="nt">--cache-from</span> myname/myapp <span class="nb">.</span>
</code></pre></div></div>

<blockquote>
  <p><strong>メモ</strong></p>

  <p>この機能を利用するためには BuildKit バックエンドが必要です。
<a href="/engine/reference/builder/#buildkit">BuildKit の有効化</a> を行ってください。
あるいは <a href="https://github.com/docker/buildx">buildx</a> プラグインを利用することもできます。
BuildKit には、プルしたイメージをキャッシュとして再利用する機能には制限があります。</p>
</blockquote>

<h3 id="squash-an-images-layers---squash-experimental">イメージへのレイヤーの押し込み (--squash) （試験的機能）</h3>

<h4 id="overview">概要</h4>

<p>このオプションは 1 度ビルドしたイメージに対して、その新しいレイヤー群を 1 つのイメージ内に単一のレイヤーとして押し込みます（squash します）。
この押し込み処理を行っても、既存のイメージは壊されることはありません。
そうはならずに、新たなイメージが 1 つ生成され、そこに押し込められたレイヤー内容が入ります。
まるで<code class="language-plaintext highlighter-rouge">Dockerfile</code>のコマンドがすべて、単一のレイヤーとして生成されるようなものです。
この場合もビルドキャッシュは保持されます。</p>

<p><code class="language-plaintext highlighter-rouge">--squash</code>オプションは試験的機能であるため、安定したものとしては捉えないでください。</p>

<p>レイヤーを押し込めらるこの機能は、同一対象のファイルを修正したレイヤーが複数生成されている場合に、便利なものとなります。
たとえば 1 つの処理ステップにおいてファイルが生成され、別ステップにおいて削除された場合です。
ただ利用の仕方によっては、イメージの押し込みが、性能面の低下が起きることがあります。
たとえば複数レイヤーからなるイメージをプルする際には、各レイヤーが同時並行的にプルされますが、複数イメージ間でレイヤーを共有している場合です（保存が節約されます）。</p>

<p>たいていの場合、マルチステージビルドを選んで間違いはありません。
これによって、ビルド処理をきめ細かく制御でき、ビルド処理において将来最適化が行われた際にも活用することができます。
詳しくは、ユーザーガイドにある <a href="http://lfstranslation/docker/develop/develop-images/multistage-build/">マルチステージビルドの利用</a> の節を参照してください。</p>

<h4 id="known-limitations">既知の制約</h4>

<p><code class="language-plaintext highlighter-rouge">--squash</code> オプションには多くの制約があることがわかっています。</p>

<ul>
  <li>レイヤーの押し込みを行う際には、結果として生成されるイメージは、他のイメージとの間でレイヤーを共有することができません。
そして容量が極端に増えることがあります。
なおベースイメージの共有には対応しています。</li>
  <li>このオプションを利用すると、確実に保存容量が増えます。
これはイメージの 2 つ分のコピーを保存するためです。
1 つは、キャッシュレイヤーすべてを損なうことなく完全な形で保持するビルドキャッシュ用、そしてもう 1 つは押し込みを行うバージョン用です。</li>
  <li>レイヤーを押し込むことで、より小さなイメージが生成されますが、性能劣化を引き起こすことがあります。
単一のレイヤーであるために伸張（解凍）には処理時間が余計にかかります。
また単一のレイヤーは、同時並行によるダウンロード処理ができません。</li>
  <li>イメージの押し込み処理を行うにあたって、そのイメージがファイルシステムへの変更を行っていない場合（たとえば Dockerfile に<code class="language-plaintext highlighter-rouge">ENV</code>命令しかない場合）、押し込み処理は失敗します。
（<a href="https://github.com/moby/moby/issues/33823">issue #33823</a> を参照してください。）</li>
</ul>

<h4 id="prerequisites">前提条件</h4>

<p>本ページに示す利用例においては、Docker 19.03 の試験的（experimental）モードを利用しています。</p>

<p>試験的モードは、Docker デーモンの起動時に<code class="language-plaintext highlighter-rouge">--experimental</code>フラグをつけることで有効になります。
あるいは設定ファイル<code class="language-plaintext highlighter-rouge">daemon.json</code>において<code class="language-plaintext highlighter-rouge">experimental: true</code>を設定します。</p>

<p>デフォルトで試験的モードは無効になっています。
Docker デーモンの現在の設定を確認するには<code class="language-plaintext highlighter-rouge">docker version</code>コマンドを実行して<code class="language-plaintext highlighter-rouge">Engine</code>セクションの<code class="language-plaintext highlighter-rouge">Experimental</code>の行に示されています。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Client: Docker Engine - Community
 Version:           19.03.8
 API version:       1.40
 Go version:        go1.12.17
 Git commit:        afacb8b
 Built:             Wed Mar 11 01:21:11 2020
 OS/Arch:           darwin/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          19.03.8
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.12.17
  Git commit:       afacb8b
  Built:            Wed Mar 11 01:29:16 2020
  OS/Arch:          linux/amd64
  Experimental:     true
 [...]
</span></code></pre></div></div>

<p>試験的モードを有効にするには、experimental フラグを有効にした上で Docker デーモンを再起動する必要があります。</p>

<h4 id="enable-docker-experimental">試験的モードの有効化</h4>

<p>試験的機能は、標準的な Docker バイナリのバージョン 1.13.0 以降に含まれるようになりました。
試験的機能を有効にするには、Docker デーモンに<code class="language-plaintext highlighter-rouge">--experimental</code>フラグをつけて実行することが必要です。
あるいは<code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code>において、以下のようにしてデーモンフラグを有効にすることもできます。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"experimental"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>試験的フラグが有効になっていることを確認します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker version <span class="nt">-f</span> <span class="s1">'{{.Server.Experimental}}'</span>
<span class="nb">true</span>
</code></pre></div></div>

<h4 id="build-an-image-with---squash-argument"><code class="language-plaintext highlighter-rouge">--squash</code>引数をつけたイメージのビルド</h4>

<p>以下では、<code class="language-plaintext highlighter-rouge">--squash</code>引数をつけて docker build を実行する例を示します。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> busybox</span>
<span class="k">RUN </span><span class="nb">echo </span>hello <span class="o">&gt;</span> /hello
<span class="k">RUN </span><span class="nb">echo </span>world <span class="o">&gt;&gt;</span> /hello
<span class="k">RUN </span><span class="nb">touch </span>remove_me /remove_me
<span class="k">ENV</span><span class="s"> HELLO=world</span>
<span class="k">RUN </span><span class="nb">rm</span> /remove_me
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">test</code>という名前のイメージが<code class="language-plaintext highlighter-rouge">--squash</code>引数をつけてビルドされます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">--squash</span> <span class="nt">-t</span> <span class="nb">test</span> <span class="nb">.</span>

<span class="o">[</span>...]
</code></pre></div></div>

<p>正常に処理されれば、履歴が以下のように表示されます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">history test

</span>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
4e10cb5b4cac        3 seconds ago                                                       12 B                merge sha256:88a7b0112a41826885df0e7072698006ee8f621c6ab99fca7fe9151d7b599702 to sha256:47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb
&lt;missing&gt;           5 minutes ago       /bin/sh <span class="nt">-c</span> <span class="nb">rm</span> /remove_me                        0 B
&lt;missing&gt;           5 minutes ago       /bin/sh <span class="nt">-c</span> <span class="c">#(nop) ENV HELLO=world               0 B</span>
&lt;missing&gt;           5 minutes ago       /bin/sh <span class="nt">-c</span> <span class="nb">touch </span>remove_me /remove_me           0 B
&lt;missing&gt;           5 minutes ago       /bin/sh <span class="nt">-c</span> <span class="nb">echo </span>world <span class="o">&gt;&gt;</span> /hello                 0 B
&lt;missing&gt;           6 minutes ago       /bin/sh <span class="nt">-c</span> <span class="nb">echo </span>hello <span class="o">&gt;</span> /hello                  0 B
&lt;missing&gt;           7 weeks ago         /bin/sh <span class="nt">-c</span> <span class="c">#(nop) CMD ["sh"]                    0 B</span>
&lt;missing&gt;           7 weeks ago         /bin/sh <span class="nt">-c</span> <span class="c">#(nop) ADD file:47ca6e777c36a4cfff   1.113 MB</span>
</code></pre></div></div>

<p>見てみればわかるように、レイヤーの名前が<code class="language-plaintext highlighter-rouge">&lt;missing&gt;</code>となっています。
そして新しいレイヤーがあって、そのコメントに<code class="language-plaintext highlighter-rouge">merge</code>と書かれています。</p>

<p>イメージを確認してください。
<code class="language-plaintext highlighter-rouge">/remove_me</code>は削除されていて、<code class="language-plaintext highlighter-rouge">/hello</code>の中身は<code class="language-plaintext highlighter-rouge">hello\nworld</code>、環境変数<code class="language-plaintext highlighter-rouge">HELLO</code>の値は<code class="language-plaintext highlighter-rouge">world</code>となっていることをそれぞれ確認してください。</p>

<h2 id="parent-command">上位コマンド</h2>

<table>
  <thead>
    <tr>
      <th>コマンド</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="/docs.docker.jp.onthefly/engine/reference/commandline/docker/">docker</a></td>
      <td>Docker CLI の基本コマンド</td>
    </tr>
  </tbody>
</table>

<div class="ratings-div"><div id="pd_rating_holder_8453675"></div></div></section>
                    </main>
                    <nav class="col-nav">
                        <div id="sidebar-nav" class="sidebar hidden-sm hidden-xs">
                            <div id="navbar" class="nav-sidebar">
                                <ul class="nav jsTOCHorizontal hidden-md hidden-lg"></ul>
                                <ul class="nav" id="jsTOCLeftNav"></ul>
                            </div>
                        </div>
                    </nav>
                    <div class="col-toc">
                        <div class="sidebar hidden-xs hidden-sm">
                            <div class="toc-nav">
                                <div class="feedback-links">
                                    <ul><li><a href="https://github.com/matsuand/docs.docker.jp.onthefly/edit/master/src/engine/reference/commandline/build.ch"><i class="fa fa-pencil-square-o" aria-hidden="true"></i> 本ページの編集</a></li><li><a href="https://github.com/matsuand/docs.docker.jp.onthefly/issues/new?body=File: [engine/reference/commandline/build.ch](https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/commandline/build/)" class="nomunge"><i class="fa fa-check" aria-hidden="true"></i> 変更リクエスト</a></li>
                                        <li><div class="toggle-mode">
  <div class="icon">
      <i class="fa fa-sun-o" aria-hidden="true"></i>
  </div>
  <div class="toggle-switch">
      <label class="switch">
          <input type="checkbox" id="switch-style">
          <span class="slider round"></span>
      </label>
  </div>
  <div class="icon">
      <i class="fa fa-moon-o" aria-hidden="true"></i>
  </div>
</div>
</li>
                                    </ul>
                                </div><div id="side-toc-title">本ページ内:</div>
<ul id="my_toc" class="inline_toc">
  <li><a href="#description" class="nomunge">説明</a></li>
  <li><a href="#usage" class="nomunge">利用方法</a></li>
  <li><a href="#extended-description" class="nomunge">追加説明</a>
    <ul>
      <li><a href="#git-repositories" class="nomunge">Git リポジトリ</a></li>
      <li><a href="#tarball-contexts" class="nomunge">Tarball コンテキスト</a></li>
      <li><a href="#text-files" class="nomunge">テキストファイル</a></li>
    </ul>
  </li>
  <li><a href="#options" class="nomunge">オプション</a></li>
  <li><a href="#examples" class="nomunge">利用例</a>
    <ul>
      <li><a href="#build-with-path" class="nomunge">PATH を使ったビルド</a></li>
      <li><a href="#build-with-url" class="nomunge">URL を使ったビルド</a></li>
      <li><a href="#build-with--" class="nomunge">- を使ったビルド</a></li>
      <li><a href="#use-a-dockerignore-file" class="nomunge">.dockerignore ファイルの利用</a></li>
      <li><a href="#tag-an-image--t" class="nomunge">イメージへのタグづけ (-t)</a></li>
      <li><a href="#specify-a-dockerfile--f" class="nomunge">Dockerfile の指定 (-f)</a></li>
      <li><a href="#use-a-custom-parent-cgroup---cgroup-parent" class="nomunge">独自の親 cgroup の利用 (--cgroup-parent)</a></li>
      <li><a href="#set-ulimits-in-container---ulimit" class="nomunge">コンテナーの ulimit 設定 (--ulimit)</a></li>
      <li><a href="#set-build-time-variables---build-arg" class="nomunge">ビルド時変数の設定 (--build-arg)</a></li>
      <li><a href="#optional-security-options---security-opt" class="nomunge">任意指定のセキュリティオプション (--security-opt)</a></li>
      <li><a href="#specify-isolation-technology-for-container---isolation" class="nomunge">コンテナーに対する分離技術方式の指定 (--isolation)</a></li>
      <li><a href="#add-entries-to-container-hosts-file---add-host" class="nomunge">コンテナーの hosts ファイルへの項目追加 (--add-host)</a></li>
      <li><a href="#specifying-target-build-stage---target" class="nomunge">ターゲットとするビルドステージの指定 (--target)</a></li>
      <li><a href="#custom-build-outputs" class="nomunge">独自のビルド出力</a></li>
      <li><a href="#specifying-external-cache-sources" class="nomunge">外部キャッシュソースの指定</a></li>
      <li><a href="#squash-an-images-layers---squash-experimental" class="nomunge">イメージへのレイヤーの押し込み (--squash) （試験的機能）</a></li>
    </ul>
  </li>
  <li><a href="#parent-command" class="nomunge">上位コマンド</a></li>
</ul>

</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer class="footer">
          
    <div class="container">
        <div class="top_footer">
            <div class="row">
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/why-docker">なぜ Docker なのか？</a></b></li>
                        <li><a href="https://www.docker.com/what-container">コンテナーって何？</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/overview">製品</a></b></li>
                        <li><a href="https://www.docker.com/products/docker-desktop">Docker Desktop</a></li>
                        <li><a href="https://www.docker.com/products/docker-hub">Docker Hub</a></li>
                        <li><b><a href="https://www.docker.com/products/docker-desktop">機能</a></b></li>
                        <li><a href="https://www.docker.com/products/container-runtime">コンテナーランタイム</a></li>
                        <li><a href="https://www.docker.com/products/developer-tools">開発ツール</a></li>
                        <li><a href="https://www.docker.com/products/kubernetes">Kubernetes</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop">開発者</a></b></li>
                        <li><a href="https://www.docker.com/use-cases">利用例</a></li>
                        <li><a href="https://www.docker.com/play-with-docker">Docker で遊ぶ</a></li>
                        <li><a href="https://www.docker.com/docker-community">コミュニティ</a></li>
                        <li><a href="https://www.docker.com/open-source">オープンソース</a></li>
                        <li><a href="https://www.docker.com/community/docker-captains">Docker キャプテン</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/company" target="_blank" rel="noopener">会社</a></b></li>
                        <li><a href="https://www.docker.com/company">概要</a></li>
                        <li><a href="https://www.docker.com/blog/" target="_blank" rel="noopener">ブログ</a></li>
                        <li><a href="https://www.docker.com/customers">顧客</a></li>
                        <li><a href="https://www.docker.com/partners">パートナー</a></li>
                        <li><a href="https://www.docker.com/company/newsroom">ニュースルーム</a></li>
                        <li><a href="https://www.docker.com/careers">採用情報</a></li>
                        <li><a href="https://www.docker.com/company/contact">連絡先</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-nav">
                <nav class="footer_sub_nav">
                    <ul class="menu">
                        <li><a href="http://status.docker.com/">ステータス</a></li>
                        <li><a href="https://www.docker.com/docker-security">セキュリティ</a></li>
                        <li><a href="https://www.docker.com/legal">法的情報</a></li>
                        <li><a href="https://www.docker.com/company/contact">連絡</a></li>
                    </ul>
                </nav>
            </div>
        </div>
        <div class="bottom_footer">
            <div class="footer-copyright col-xs-12 col-md-8">
                <p class="copyright">
                    Copyright &copy; 2013-2020 Docker Inc. All rights reserved. </p>
            </div>
            <div class="footer_social_nav">
                <ul class="nav-social">
                    <li class="fa fa-twitter"><a href="http://twitter.com/docker">Twitter</a></li>
                    <li class="fa fa-youtube"><a href="http://www.youtube.com/user/dockerrun">Youtube</a></li>
                    <li class="fa fa-github"><a href="https://github.com/docker">GitHub</a></li>
                    <li class="fa fa-linkedin"><a href="https://www.linkedin.com/company/docker">Linkedin</a></li>
                    <li class="fa fa-facebook"><a href="https://www.facebook.com/docker.run">Facebook</a></li>
                    <li class="fa fa-slideshare"><a href="https://www.slideshare.net/docker">Slideshare</a></li>
                    <li class="fa fa-reddit"><a href="https://www.reddit.com/r/docker">Reddit</a></li>
                </ul>
            </div>
        </div>
    </div>

    </footer>
    <script>const pageURL = "/engine/reference/commandline/build/";</script></body>
</html>
