<!DOCTYPE html>
<!-- Page generated 2022-04-29 17:35:28 +0900-->
<html lang="ja"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Use IPvlan networks | Docker ドキュメント</title>
  <meta name="description" content="All about using IPvlan to make your containers appear like physical machines on the network" />
  <meta name="keywords" content="network, ipvlan, l2, l3, standalone">
  <link rel="canonical" href="https://localhost:4000{{ site.baseurl }}/network/ipvlan/" />

  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
  <link rel="apple-touch-icon" type="image/x-icon" href="/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
  <meta name="msapplication-TileImage" content="/docs.docker.jp.onthefly/favicons/docs@2x.ico">
  <meta property="og:image" content="/docs.docker.jp.onthefly/favicons/docs@2x.ico"/>
  <meta name="theme-color" content="#2496ed" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- hide elements that are only shown without JavaScript enabled -->
  <script>document.documentElement.classList.add('js')</script>
  <style>html.js .no-js { display: none !important; }</style><script defer src="/docs.docker.jp.onthefly/js/theme-switcher.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/anchorlinks.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/jquery.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/bootstrap.min.js"></script>
  <script defer src="/docs.docker.jp.onthefly/js/docs.js"></script><script defer src="/docs.docker.jp.onthefly/js/search.js"></script><link rel="preload" as="font" href="https://fonts.gstatic.com/s/opensans/v18/mem8YaGs126MiZpBA-UFVZ0bf8pkAg.woff2" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/geomanist/hinted-Geomanist-Book.woff2"    type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/geomanist/hinted-Geomanist-Regular.woff2" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/glyphicons-halflings-regular.woff2"       type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/docs.docker.jp.onthefly/fonts/fontawesome-webfont.woff2?v=4.7.0"        type="font/woff2" crossorigin="anonymous">

  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/font-awesome.min.css">
  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/bootstrap.min.css">
  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/style.css" id="pagestyle">

  <!-- SEO stuff -->
  <meta name="twitter:title" itemprop="title name" content="Use IPvlan networks"/>
  <meta name="twitter:description" property="og:description" itemprop="description" content="" />
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:domain" content="matsuand.github.io"/>
  <meta name="twitter:site" content="@docker_docs"/>
  <meta name="twitter:url" content="https://twitter.com/docker_docs"/>
  <meta name="twitter:image:src" content="/docs.docker.jp.onthefly/images/docs@2x.png"/>
  <meta name="twitter:image:alt" content="Docker ドキュメント"/>
  <meta property="og:title" content="Use IPvlan networks" />
  <meta property="og:description" content="All about using IPvlan to make your containers appear like physical machines on the network" />
  <meta property="og:type" content="website"/>
  <meta property="og:updated_time" itemprop="dateUpdated" content="2022-04-29T17:35:28+09:00"/>
  <meta property="og:image" itemprop="image primaryImageOfPage" content="/docs.docker.jp.onthefly/images/docs@2x.png"/>
  <meta property="og:locale" content="ja_JP" />
  <meta property="og:url" content="https://matsuand.github.io/docs.docker.jp.onthefly/network/ipvlan/" />
  <meta property="og:site_name" content="Docker ドキュメント" />
  <meta property="article:published_time" itemprop="datePublished" content="2022-04-29T17:35:28+09:00"/>
  <script type="application/ld+json">{"@context":"https://schema.org","@type":"WebPage","headline":"Use IPvlan networks","description":"All about using IPvlan to make your containers appear like physical machines on the network","url":"https://docs.docker.com/network/ipvlan/"}</script>
  <!-- END SEO STUFF -->
</head>
<body class="colums">
    <header>
        <nav class="nav-secondary navbar navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header">
            <a href="/docs.docker.jp.onthefly/">
                <img class="logo" src="/docs.docker.jp.onthefly/images/docker-docs-logo.svg" alt="Docker Docs" title="Docker Docs" width="160" height="28" />
            </a>
        </div>
        <div class="navbar-collapse" aria-expanded="false" style="height: 1px;">
            <div class="logo-mobile">
    <a href="/docs.docker.jp.onthefly/">
        <img src="/docs.docker.jp.onthefly/images/docker-icon.svg" alt="Docker Docs" title="Docker Docs" width="30" height="30" />
    </a>
</div>
<div class="search-form" id="search-div">
    <form class="search-form form-inline" id="searchForm" action="/docs.docker.jp.onthefly/search/" method="get">
        <label for="st-search-input" class="sr-only">検索</label>
        <input class="search-field form-control ds-input" id="st-search-input" name="q" placeholder="文書内検索" type="search" autocomplete="off" spellcheck="false" dir="auto" style="position: relative; vertical-align: top;">
        <div id="autocompleteResults"></div>
        <!-- <button type="submit" class="search-submit btn btn-default">検索</button> -->
    </form>
</div>
<div class="sidebar-toggle">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
    </button>
</div>
<div class="nav-container hidden-sm hidden-xs">
    <div>
        <ul class="nav navbar-nav"><li><a href="/docs.docker.jp.onthefly/" id="home">ホーム</a></li><li><a href="/docs.docker.jp.onthefly/get-started/overview/" id="guides">ガイド</a></li><li><a href="/docs.docker.jp.onthefly/desktop/" id="manuals">マニュアル</a></li><li><a href="/docs.docker.jp.onthefly/reference/" id="reference">リファレンス</a></li><li><a href="/docs.docker.jp.onthefly/samples/" id="samples">サンプル</a></li></ul>
    </div>
    <div class="ctrl-right">
        <a href="javascript:void(0)" id="menu-toggle" aria-label="現在ページのメニュートグル"><i class="fa fa-indent" aria-hidden="true"></i></a>
    </div>
</div>
<div class="row hidden-sm hidden-xs">
    <nav aria-label="breadcrumb">
        <ol class="breadcrumb">
            <li><a href="/docs.docker.jp.onthefly/" title="Docker docs ホームページ"><i class="fa fa-home"></i></a></li>
            <li><a href="/docs.docker.jp.onthefly/get-started/overview/">ガイド</a></li><li><a>本番環境でのアプリ運用</a></li><li><a href="/docs.docker.jp.onthefly/network/">ネットワーク設定</a></li><li><a href="/docs.docker.jp.onthefly/network/ipvlan/">IPvlan ネットワークの利用</a></li></ol>
    </nav>
</div></div>
    </div>
</nav>

    </header>
    <div class="wrapper right-open">
        <div class="container-fluid">
            <div class="row">
                <div class="col-body">
                    <main class="col-content content">
                        <section class="section"><h1>Use IPvlan networks</h1><p><em class="reading-time">読む時間の目安: 26 分</em></p><p>The IPvlan driver gives users total control over both IPv4 and IPv6 addressing.
The VLAN driver builds on top of that in giving operators complete control of
layer 2 VLAN tagging and even IPvlan L3 routing for users interested in underlay
network integration. For overlay deployments that abstract away physical constraints
see the <a href="/docs.docker.jp.onthefly/network/network-tutorial-overlay/">multi-host overlay</a> driver.</p>

<p>IPvlan is a new twist on the tried and true network virtualization technique.
The Linux implementations are extremely lightweight because rather than using
the traditional Linux bridge for isolation, they are associated to a Linux
Ethernet interface or sub-interface to enforce separation between networks and
connectivity to the physical network.</p>

<p>IPvlan offers a number of unique features and plenty of room for further
innovations with the various modes. Two high level advantages of these approaches
are, the positive performance implications of bypassing the Linux bridge and the
simplicity of having fewer moving parts. Removing the bridge that traditionally
resides in between the Docker host NIC and container interface leaves a simple
setup consisting of container interfaces, attached directly to the Docker host
interface. This result is easy to access for external facing services as there
is no need for port mappings in these scenarios.</p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
  <li>The examples on this page are all single host.</li>
  <li>All examples can be performed on a single host running Docker. Any
example using a sub-interface like <code class="highlighter-rouge">eth0.10</code> can be replaced with <code class="highlighter-rouge">eth0</code> or
any other valid parent interface on the Docker host. Sub-interfaces with a <code class="highlighter-rouge">.</code>
are created on the fly. <code class="highlighter-rouge">-o parent</code> interfaces can also be left out of the
<code class="highlighter-rouge">docker network create</code> all together and the driver will create a <code class="highlighter-rouge">dummy</code>
interface that will enable local host connectivity to perform the examples.</li>
  <li>Kernel requirements:
    <ul>
      <li>To check your current kernel version, use <code class="highlighter-rouge">uname -r</code></li>
      <li>IPvlan Linux kernel v4.2+ (support for earlier kernels exists but is buggy)</li>
    </ul>
  </li>
</ul>

<h2 id="ipvlan-l2-mode-example-usage">IPvlan L2 mode example usage</h2>

<p>An example of the IPvlan <code class="highlighter-rouge">L2</code> mode topology is shown in the following image.
The driver is specified with <code class="highlighter-rouge">-d driver_name</code> option. In this case <code class="highlighter-rouge">-d ipvlan</code>.</p>

<p><img src="/docs.docker.jp.onthefly/network/images/ipvlan_l2_simple.png" alt="Simple IPvlan L2 Mode Example" /></p>

<p>The parent interface in the next example <code class="highlighter-rouge">-o parent=eth0</code> is configured as follows:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> ip addr show eth0
<span class="gp">3: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
<span class="go">    inet 192.168.1.250/24 brd 192.168.1.255 scope global eth0
</span></code></pre></div></div>

<p>Use the network from the host’s interface as the <code class="highlighter-rouge">--subnet</code> in the
<code class="highlighter-rouge">docker network create</code>. The container will be attached to the same network as
the host interface as set via the <code class="highlighter-rouge">-o parent=</code> option.</p>

<p>Create the IPvlan network and run a container attaching to it:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> IPvlan  <span class="o">(</span><span class="nt">-o</span> <span class="nv">ipvlan_mode</span><span class="o">=</span> Defaults to L2 mode <span class="k">if </span>not specified<span class="o">)</span>
<span class="gp">$</span> docker network  create <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.1.0/24 <span class="se">\</span>
    <span class="nt">--gateway</span><span class="o">=</span>192.168.1.1 <span class="se">\</span>
    <span class="nt">-o</span> <span class="nv">ipvlan_mode</span><span class="o">=</span>l2 <span class="se">\</span>
    <span class="nt">-o</span> <span class="nv">parent</span><span class="o">=</span>eth0 db_net
<span class="go">
</span><span class="gp">#</span> Start a container on the db_net network
<span class="gp">$</span> docker  run <span class="nt">--net</span><span class="o">=</span>db_net <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="go">
</span><span class="gp">#</span> NOTE: the containers can NOT ping the underlying host interfaces as
<span class="gp">#</span> they are intentionally filtered by Linux <span class="k">for </span>additional isolation.
</code></pre></div></div>

<p>The default mode for IPvlan is <code class="highlighter-rouge">l2</code>. If <code class="highlighter-rouge">-o ipvlan_mode=</code> are left unspecified,
the default mode will be used. Similarly, if the <code class="highlighter-rouge">--gateway</code> is left empty, the
first usable address on the network will be set as the gateway. For example, if
the subnet provided in the network create is <code class="highlighter-rouge">--subnet=192.168.1.0/24</code> then the
gateway the container receives is <code class="highlighter-rouge">192.168.1.1</code>.</p>

<p>To help understand how this mode interacts with other hosts, the following
figure shows the same layer 2 segment between two Docker hosts that applies to
and IPvlan L2 mode.</p>

<p><img src="/docs.docker.jp.onthefly/network/images/macvlan-bridge-ipvlan-l2.png" alt="Multiple IPvlan Hosts" /></p>

<p>The following will create the exact same network as the network <code class="highlighter-rouge">db_net</code> created
earlier, with the driver defaults for <code class="highlighter-rouge">--gateway=192.168.1.1</code> and <code class="highlighter-rouge">-o ipvlan_mode=l2</code>.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> IPvlan  <span class="o">(</span><span class="nt">-o</span> <span class="nv">ipvlan_mode</span><span class="o">=</span> Defaults to L2 mode <span class="k">if </span>not specified<span class="o">)</span>
<span class="gp">$</span> docker network  create <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.1.0/24 <span class="se">\</span>
    <span class="nt">-o</span> <span class="nv">parent</span><span class="o">=</span>eth0 db_net_ipv
<span class="go">
</span><span class="gp">#</span> Start a container with an explicit name <span class="k">in </span>daemon mode
<span class="gp">$</span> docker  run <span class="nt">--net</span><span class="o">=</span>db_net_ipv <span class="nt">--name</span><span class="o">=</span>ipv1 <span class="nt">-itd</span> alpine /bin/sh
<span class="go">
</span><span class="gp">#</span> Start a second container and ping using the container name
<span class="gp">#</span> to see the docker included name resolution functionality
<span class="gp">$</span> docker  run <span class="nt">--net</span><span class="o">=</span>db_net_ipv <span class="nt">--name</span><span class="o">=</span>ipv2 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">$</span> ping <span class="nt">-c</span> 4 ipv1
<span class="go">
</span><span class="gp">#</span> NOTE: the containers can NOT ping the underlying host interfaces as
<span class="gp">#</span> they are intentionally filtered by Linux <span class="k">for </span>additional isolation.
</code></pre></div></div>

<p>The drivers also support the <code class="highlighter-rouge">--internal</code> flag that will completely isolate
containers on a network from any communications external to that network. Since
network isolation is tightly coupled to the network’s parent interface the result
of leaving the <code class="highlighter-rouge">-o parent=</code> option off of a <code class="highlighter-rouge">docker network create</code> is the exact
same as the <code class="highlighter-rouge">--internal</code> option. If the parent interface is not specified or the
<code class="highlighter-rouge">--internal</code> flag is used, a netlink type <code class="highlighter-rouge">dummy</code> parent interface is created
for the user and used as the parent interface effectively isolating the network
completely.</p>

<p>The following two <code class="highlighter-rouge">docker network create</code> examples result in identical networks
that you can attach container to:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> Empty <span class="s1">'-o parent='</span> creates an isolated network
<span class="gp">$</span> docker network  create <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.10.0/24 isolated1
<span class="go">
</span><span class="gp">#</span> Explicit <span class="s1">'--internal'</span> flag is the same:
<span class="gp">$</span> docker network  create <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.11.0/24 <span class="nt">--internal</span> isolated2
<span class="go">
</span><span class="gp">#</span> Even the <span class="s1">'--subnet='</span> can be left empty and the default
<span class="gp">#</span> IPAM subnet of 172.18.0.0/16 will be assigned
<span class="gp">$</span> docker network  create <span class="nt">-d</span> ipvlan isolated3
<span class="go">
</span><span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>isolated1 <span class="nt">--name</span><span class="o">=</span>cid1 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>isolated2 <span class="nt">--name</span><span class="o">=</span>cid2 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>isolated3 <span class="nt">--name</span><span class="o">=</span>cid3 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="go">
</span><span class="gp">#</span> To attach to any use <span class="sb">`</span>docker <span class="nb">exec</span><span class="sb">`</span> and start a shell
<span class="gp">$</span> docker <span class="nb">exec</span> <span class="nt">-it</span> cid1 /bin/sh
<span class="gp">$</span> docker <span class="nb">exec</span> <span class="nt">-it</span> cid2 /bin/sh
<span class="gp">$</span> docker <span class="nb">exec</span> <span class="nt">-it</span> cid3 /bin/sh
</code></pre></div></div>

<h2 id="ipvlan-8021q-trunk-l2-mode-example-usage">IPvlan 802.1q trunk L2 mode example usage</h2>

<p>Architecturally, IPvlan L2 mode trunking is the same as Macvlan with regard to
gateways and L2 path isolation. There are nuances that can be advantageous for
CAM table pressure in ToR switches, one MAC per port and MAC exhaustion on a
host’s parent NIC to name a few. The 802.1q trunk scenario looks the same. Both
modes adhere to tagging standards and have seamless integration with the physical
network for underlay integration and hardware vendor plugin integrations.</p>

<p>Hosts on the same VLAN are typically on the same subnet and almost always are
grouped together based on their security policy. In most scenarios, a multi-tier
application is tiered into different subnets because the security profile of each
process requires some form of isolation. For example, hosting your credit card
processing on the same virtual network as the frontend webserver would be a
regulatory compliance issue, along with circumventing the long standing best
practice of layered defense in depth architectures. VLANs or the equivocal VNI
(Virtual Network Identifier) when using the Overlay driver, are the first step
in isolating tenant traffic.</p>

<p><img src="/docs.docker.jp.onthefly/network/images/vlans-deeper-look.png" alt="Docker VLANs in Depth" /></p>

<p>The Linux sub-interface tagged with a VLAN can either already exist or will be
created when you call a <code class="highlighter-rouge">docker network create</code>. <code class="highlighter-rouge">docker network rm</code> will delete
the sub-interface. Parent interfaces such as <code class="highlighter-rouge">eth0</code> are not deleted, only
sub-interfaces with a netlink parent index &gt; 0.</p>

<p>For the driver to add/delete the VLAN sub-interfaces the format needs to be
<code class="highlighter-rouge">interface_name.vlan_tag</code>. Other sub-interface naming can be used as the
specified parent, but the link will not be deleted automatically when
<code class="highlighter-rouge">docker network rm</code> is invoked.</p>

<p>The option to use either existing parent VLAN sub-interfaces or let Docker manage
them enables the user to either completely manage the Linux interfaces and
networking or let Docker create and delete the VLAN parent sub-interfaces
(netlink <code class="highlighter-rouge">ip link</code>) with no effort from the user.</p>

<p>For example: use <code class="highlighter-rouge">eth0.10</code> to denote a sub-interface of <code class="highlighter-rouge">eth0</code> tagged with the
VLAN id of <code class="highlighter-rouge">10</code>. The equivalent <code class="highlighter-rouge">ip link</code> command would be
<code class="highlighter-rouge">ip link add link eth0 name eth0.10 type vlan id 10</code>.</p>

<p>The example creates the VLAN tagged networks and then starts two containers to
test connectivity between containers. Different VLANs cannot ping one another
without a router routing between the two networks. The default namespace is not
reachable per IPvlan design in order to isolate container namespaces from the
underlying host.</p>

<h3 id="vlan-id-20">VLAN ID 20</h3>

<p>In the first network tagged and isolated by the Docker host, <code class="highlighter-rouge">eth0.20</code> is the
parent interface tagged with VLAN id <code class="highlighter-rouge">20</code> specified with <code class="highlighter-rouge">-o parent=eth0.20</code>.
Other naming formats can be used, but the links need to be added and deleted
manually using <code class="highlighter-rouge">ip link</code> or Linux configuration files. As long as the <code class="highlighter-rouge">-o parent</code>
exists, anything can be used if it is compliant with Linux netlink.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> now add networks and hosts as you would normally by attaching to the master <span class="o">(</span>sub<span class="o">)</span>interface that is tagged
<span class="gp">$</span> docker network  create  <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.20.0/24 <span class="se">\</span>
    <span class="nt">--gateway</span><span class="o">=</span>192.168.20.1 <span class="se">\</span>
    <span class="nt">-o</span> <span class="nv">parent</span><span class="o">=</span>eth0.20 ipvlan20
<span class="go">
</span><span class="gp">#</span> <span class="k">in </span>two separate terminals, start a Docker container and the containers can now ping one another.
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan20 <span class="nt">-it</span> <span class="nt">--name</span> ivlan_test1 <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan20 <span class="nt">-it</span> <span class="nt">--name</span> ivlan_test2 <span class="nt">--rm</span> alpine /bin/sh
</code></pre></div></div>

<h3 id="vlan-id-30">VLAN ID 30</h3>

<p>In the second network, tagged and isolated by the Docker host, <code class="highlighter-rouge">eth0.30</code> is the
parent interface tagged with VLAN id <code class="highlighter-rouge">30</code> specified with <code class="highlighter-rouge">-o parent=eth0.30</code>. The
<code class="highlighter-rouge">ipvlan_mode=</code> defaults to l2 mode <code class="highlighter-rouge">ipvlan_mode=l2</code>. It can also be explicitly
set with the same result as shown in the next example.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> now add networks and hosts as you would normally by attaching to the master <span class="o">(</span>sub<span class="o">)</span>interface that is tagged.
<span class="gp">$</span> docker network  create  <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.30.0/24 <span class="se">\</span>
    <span class="nt">--gateway</span><span class="o">=</span>192.168.30.1 <span class="se">\</span>
    <span class="nt">-o</span> <span class="nv">parent</span><span class="o">=</span>eth0.30 <span class="se">\</span>
    <span class="nt">-o</span> <span class="nv">ipvlan_mode</span><span class="o">=</span>l2 ipvlan30
<span class="go">
</span><span class="gp">#</span> <span class="k">in </span>two separate terminals, start a Docker container and the containers can now ping one another.
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan30 <span class="nt">-it</span> <span class="nt">--name</span> ivlan_test3 <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan30 <span class="nt">-it</span> <span class="nt">--name</span> ivlan_test4 <span class="nt">--rm</span> alpine /bin/sh
</code></pre></div></div>

<p>The gateway is set inside of the container as the default gateway. That gateway
would typically be an external router on the network.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="nv">$ </span>ip route
<span class="go">  default via 192.168.30.1 dev eth0
  192.168.30.0/24 dev eth0  src 192.168.30.2
</span></code></pre></div></div>

<p>Example: Multi-Subnet IPvlan L2 Mode starting two containers on the same subnet
and pinging one another. In order for the <code class="highlighter-rouge">192.168.114.0/24</code> to reach
<code class="highlighter-rouge">192.168.116.0/24</code> it requires an external router in L2 mode. L3 mode can route
between subnets that share a common <code class="highlighter-rouge">-o parent=</code>.</p>

<p>Secondary addresses on network routers are common as an address space becomes
exhausted to add another secondary to an L3 VLAN interface or commonly referred
to as a “switched virtual interface” (SVI).</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker network  create  <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.114.0/24 <span class="nt">--subnet</span><span class="o">=</span>192.168.116.0/24 <span class="se">\</span>
    <span class="nt">--gateway</span><span class="o">=</span>192.168.114.254  <span class="nt">--gateway</span><span class="o">=</span>192.168.116.254 <span class="se">\</span>
     <span class="nt">-o</span> <span class="nv">parent</span><span class="o">=</span>eth0.114 <span class="se">\</span>
     <span class="nt">-o</span> <span class="nv">ipvlan_mode</span><span class="o">=</span>l2 ipvlan114
<span class="go">
</span><span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan114 <span class="nt">--ip</span><span class="o">=</span>192.168.114.10 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan114 <span class="nt">--ip</span><span class="o">=</span>192.168.114.11 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
</code></pre></div></div>

<p>A key takeaway is, operators have the ability to map their physical network into
their virtual network for integrating containers into their environment with no
operational overhauls required. NetOps drops an 802.1q trunk into the
Docker host. That virtual link would be the <code class="highlighter-rouge">-o parent=</code> passed in the network
creation. For untagged (non-VLAN) links, it is as simple as <code class="highlighter-rouge">-o parent=eth0</code> or
for 802.1q trunks with VLAN IDs each network gets mapped to the corresponding
VLAN/Subnet from the network.</p>

<p>An example being, NetOps provides VLAN ID and the associated subnets for VLANs
being passed on the Ethernet link to the Docker host server. Those values are
plugged into the <code class="highlighter-rouge">docker network create</code> commands when provisioning the
Docker networks. These are persistent configurations that are applied every time
the Docker engine starts which alleviates having to manage often complex
configuration files. The network interfaces can also be managed manually by
being pre-created and Docker networking will never modify them, and use them
as parent interfaces. Example mappings from NetOps to Docker network commands
are as follows:</p>

<ul>
  <li>VLAN: 10, Subnet: 172.16.80.0/24, Gateway: 172.16.80.1
    <ul>
      <li><code class="highlighter-rouge">--subnet=172.16.80.0/24 --gateway=172.16.80.1 -o parent=eth0.10</code></li>
    </ul>
  </li>
  <li>VLAN: 20, IP subnet: 172.16.50.0/22, Gateway: 172.16.50.1
    <ul>
      <li><code class="highlighter-rouge">--subnet=172.16.50.0/22 --gateway=172.16.50.1 -o parent=eth0.20 </code></li>
    </ul>
  </li>
  <li>VLAN: 30, Subnet: 10.1.100.0/16, Gateway: 10.1.100.1
    <ul>
      <li><code class="highlighter-rouge">--subnet=10.1.100.0/16 --gateway=10.1.100.1 -o parent=eth0.30</code></li>
    </ul>
  </li>
</ul>

<h2 id="ipvlan-l3-mode-example">IPvlan L3 mode example</h2>

<p>IPvlan will require routes to be distributed to each endpoint. The driver only
builds the IPvlan L3 mode port and attaches the container to the interface. Route
distribution throughout a cluster is beyond the initial implementation of this
single host scoped driver. In L3 mode, the Docker host is very similar to a
router starting new networks in the container. They are on networks that the
upstream network will not know about without route distribution. For those
curious how IPvlan L3 will fit into container networking, see the following
examples.</p>

<p><img src="/docs.docker.jp.onthefly/network/images/ipvlan-l3.png" alt="Docker IPvlan L2 Mode" /></p>

<p>IPvlan L3 mode drops all broadcast and multicast traffic. This reason alone
makes IPvlan L3 mode a prime candidate for those looking for massive scale and
predictable network integrations. It is predictable and in turn will lead to
greater uptimes because there is no bridging involved. Bridging loops have been
responsible for high profile outages that can be hard to pinpoint depending on
the size of the failure domain. This is due to the cascading nature of BPDUs
(Bridge Port Data Units) that are flooded throughout a broadcast domain (VLAN)
to find and block topology loops. Eliminating bridging domains, or at the least,
keeping them isolated to a pair of ToRs (top of rack switches) will reduce hard
to troubleshoot bridging instabilities. IPvlan L2 modes is well suited for
isolated VLANs only trunked into a pair of ToRs that can provide a loop-free
non-blocking fabric. The next step further is to route at the edge via IPvlan L3
mode that reduces a failure domain to a local host only.</p>

<ul>
  <li>L3 mode needs to be on a separate subnet as the default namespace since it
requires a netlink route in the default namespace pointing to the IPvlan parent
interface.</li>
  <li>The parent interface used in this example is <code class="highlighter-rouge">eth0</code> and it is on the subnet
 <code class="highlighter-rouge">192.168.1.0/24</code>. Notice the <code class="highlighter-rouge">docker network</code> is <strong>not</strong> on the same subnet
as <code class="highlighter-rouge">eth0</code>.</li>
  <li>Unlike IPvlan l2 modes, different subnets/networks can ping one another as
long as they share the same parent interface <code class="highlighter-rouge">-o parent=</code>.</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="nv">$ </span>ip a show eth0
<span class="gp">3: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
<span class="go">    link/ether 00:50:56:39:45:2e brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.250/24 brd 192.168.1.255 scope global eth0
</span></code></pre></div></div>

<ul>
  <li>A traditional gateway doesn’t mean much to an L3 mode IPvlan interface since
there is no broadcast traffic allowed. Because of that, the container default
gateway points to the containers <code class="highlighter-rouge">eth0</code> device. See below for CLI output
of <code class="highlighter-rouge">ip route</code> or <code class="highlighter-rouge">ip -6 route</code> from inside an L3 container for details.</li>
</ul>

<p>The mode ` -o ipvlan_mode=l3<code class="highlighter-rouge"> must be explicitly specified since the default
IPvlan mode is </code>l2`.</p>

<p>The following example does not specify a parent interface. The network drivers
will create a dummy type link for the user rather than rejecting the network
creation and isolating containers from only communicating with one another.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> Create the IPvlan L3 network
<span class="gp">$</span> docker network  create  <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.214.0/24 <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>10.1.214.0/24 <span class="se">\</span>
     <span class="nt">-o</span> <span class="nv">ipvlan_mode</span><span class="o">=</span>l3 ipnet210
<span class="go">
</span><span class="gp">#</span> Test 192.168.214.0/24 connectivity
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipnet210 <span class="nt">--ip</span><span class="o">=</span>192.168.214.10 <span class="nt">-itd</span> alpine /bin/sh
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipnet210 <span class="nt">--ip</span><span class="o">=</span>10.1.214.10 <span class="nt">-itd</span> alpine /bin/sh
<span class="go">
</span><span class="gp">#</span> Test L3 connectivity from 10.1.214.0/24 to 192.168.212.0/24
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipnet210 <span class="nt">--ip</span><span class="o">=</span>192.168.214.9 <span class="nt">-it</span> <span class="nt">--rm</span> alpine ping <span class="nt">-c</span> 2 10.1.214.10
<span class="go">
</span><span class="gp">#</span> Test L3 connectivity from 192.168.212.0/24 to 10.1.214.0/24
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipnet210 <span class="nt">--ip</span><span class="o">=</span>10.1.214.9 <span class="nt">-it</span> <span class="nt">--rm</span> alpine ping <span class="nt">-c</span> 2 192.168.214.10
<span class="go">
</span></code></pre></div></div>

<blockquote>
  <p><strong>Note</strong></p>

  <p>Notice that there is no <code class="highlighter-rouge">--gateway=</code> option in the network create. The field
is ignored if one is specified <code class="highlighter-rouge">l3</code> mode. Take a look at the container routing
table from inside of the container:</p>

  <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> Inside an L3 mode container
<span class="gp">$</span><span class="nv">$ </span>ip route
<span class="go"> default dev eth0
  192.168.214.0/24 dev eth0  src 192.168.214.10
</span></code></pre></div>  </div>
</blockquote>

<p>In order to ping the containers from a remote Docker host or the container be
able to ping a remote host, the remote host or the physical network in between
need to have a route pointing to the host IP address of the container’s Docker
host eth interface.</p>

<h2 id="dual-stack-ipv4-ipv6-ipvlan-l2-mode">Dual stack IPv4 IPv6 IPvlan L2 mode</h2>

<ul>
  <li>
    <p>Not only does Libnetwork give you complete control over IPv4 addressing, but
it also gives you total control over IPv6 addressing as well as feature parity
between the two address families.</p>
  </li>
  <li>
    <p>The next example will start with IPv6 only. Start two containers on the same
VLAN <code class="highlighter-rouge">139</code> and ping one another. Since the IPv4 subnet is not specified, the
default IPAM will provision a default IPv4 subnet. That subnet is isolated
unless the upstream network is explicitly routing it on VLAN <code class="highlighter-rouge">139</code>.</p>
  </li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> Create a v6 network
<span class="gp">$</span> docker network create <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--ipv6</span> <span class="nt">--subnet</span><span class="o">=</span>2001:db8:abc2::/64 <span class="nt">--gateway</span><span class="o">=</span>2001:db8:abc2::22 <span class="se">\</span>
    <span class="nt">-o</span> <span class="nv">parent</span><span class="o">=</span>eth0.139 v6ipvlan139
<span class="go">
</span><span class="gp">#</span> Start a container on the network
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>v6ipvlan139 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
</code></pre></div></div>

<p>View the container eth0 interface and v6 routing table:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> Inside the IPv6 container
<span class="gp">$</span><span class="nv">$ </span>ip a show eth0
<span class="gp">75: eth0@if55: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu 1500 qdisc noqueue state UNKNOWN group default
<span class="go">    link/ether 00:50:56:2b:29:40 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 2001:db8:abc4::250:56ff:fe2b:2940/64 scope link
       valid_lft forever preferred_lft forever
    inet6 2001:db8:abc2::1/64 scope link nodad
       valid_lft forever preferred_lft forever

</span><span class="gp">$</span><span class="nv">$ </span>ip <span class="nt">-6</span> route
<span class="go">2001:db8:abc4::/64 dev eth0  proto kernel  metric 256
2001:db8:abc2::/64 dev eth0  proto kernel  metric 256
default via 2001:db8:abc2::22 dev eth0  metric 1024
</span></code></pre></div></div>

<p>Start a second container and ping the first container’s v6 address.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> Test L2 connectivity over IPv6
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>v6ipvlan139 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="go">
</span><span class="gp">#</span> Inside the second IPv6 container
<span class="gp">$</span><span class="nv">$ </span>ip a show eth0
<span class="gp">75: eth0@if55: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu 1500 qdisc noqueue state UNKNOWN group default
<span class="go">    link/ether 00:50:56:2b:29:40 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.3/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 2001:db8:abc4::250:56ff:fe2b:2940/64 scope link tentative dadfailed
       valid_lft forever preferred_lft forever
    inet6 2001:db8:abc2::2/64 scope link nodad
       valid_lft forever preferred_lft forever

</span><span class="gp">$</span><span class="nv">$ </span>ping6 2001:db8:abc2::1
<span class="go">PING 2001:db8:abc2::1 (2001:db8:abc2::1): 56 data bytes
64 bytes from 2001:db8:abc2::1%eth0: icmp_seq=0 ttl=64 time=0.044 ms
64 bytes from 2001:db8:abc2::1%eth0: icmp_seq=1 ttl=64 time=0.058 ms

2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.044/0.051/0.058/0.000 ms
</span></code></pre></div></div>

<p>The next example with setup a dual stack IPv4/IPv6 network with an example
VLAN ID of <code class="highlighter-rouge">140</code>.</p>

<p>Next create a network with two IPv4 subnets and one IPv6 subnets, all of which
have explicit gateways:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker network  create  <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.140.0/24 <span class="nt">--subnet</span><span class="o">=</span>192.168.142.0/24 <span class="se">\</span>
    <span class="nt">--gateway</span><span class="o">=</span>192.168.140.1  <span class="nt">--gateway</span><span class="o">=</span>192.168.142.1 <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>2001:db8:abc9::/64 <span class="nt">--gateway</span><span class="o">=</span>2001:db8:abc9::22 <span class="se">\</span>
     <span class="nt">-o</span> <span class="nv">parent</span><span class="o">=</span>eth0.140 <span class="se">\</span>
     <span class="nt">-o</span> <span class="nv">ipvlan_mode</span><span class="o">=</span>l2 ipvlan140
</code></pre></div></div>

<p>Start a container and view eth0 and both v4 &amp; v6 routing tables:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan140 <span class="nt">--ip6</span><span class="o">=</span>2001:db8:abc2::51 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="go">
</span><span class="gp">$</span> ip a show eth0
<span class="gp">78: eth0@if77: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu 1500 qdisc noqueue state UNKNOWN group default
<span class="go">    link/ether 00:50:56:2b:29:40 brd ff:ff:ff:ff:ff:ff
    inet 192.168.140.2/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 2001:db8:abc4::250:56ff:fe2b:2940/64 scope link
       valid_lft forever preferred_lft forever
    inet6 2001:db8:abc9::1/64 scope link nodad
       valid_lft forever preferred_lft forever

</span><span class="gp">$</span><span class="nv">$ </span>ip route
<span class="go">default via 192.168.140.1 dev eth0
192.168.140.0/24 dev eth0  proto kernel  scope link  src 192.168.140.2

</span><span class="gp">$</span><span class="nv">$ </span>ip <span class="nt">-6</span> route
<span class="go">2001:db8:abc4::/64 dev eth0  proto kernel  metric 256
2001:db8:abc9::/64 dev eth0  proto kernel  metric 256
default via 2001:db8:abc9::22 dev eth0  metric 1024
</span></code></pre></div></div>

<p>Start a second container with a specific <code class="highlighter-rouge">--ip4</code> address and ping the first host
using IPv4 packets:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan140 <span class="nt">--ip</span><span class="o">=</span>192.168.140.10 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
</code></pre></div></div>

<blockquote>
  <p><strong>Note</strong></p>

  <p>Different subnets on the same parent interface in IPvlan <code class="highlighter-rouge">L2</code> mode cannot ping
one another. That requires a router to proxy-arp the requests with a secondary
subnet. However, IPvlan <code class="highlighter-rouge">L3</code> will route the unicast traffic between disparate
subnets as long as they share the same <code class="highlighter-rouge">-o parent</code> parent link.</p>
</blockquote>

<h2 id="dual-stack-ipv4-ipv6-ipvlan-l3-mode">Dual stack IPv4 IPv6 IPvlan L3 mode</h2>

<p><strong>Example:</strong> IPvlan L3 Mode Dual Stack IPv4/IPv6, Multi-Subnet w/ 802.1q VLAN Tag:118</p>

<p>As in all of the examples, a tagged VLAN interface does not have to be used. The
sub-interfaces can be swapped with <code class="highlighter-rouge">eth0</code>, <code class="highlighter-rouge">eth1</code>, <code class="highlighter-rouge">bond0</code> or any other valid
interface on the host other then the <code class="highlighter-rouge">lo</code> loopback.</p>

<p>The primary difference you will see is that L3 mode does not create a default
route with a next-hop but rather sets a default route pointing to <code class="highlighter-rouge">dev eth</code> only
since ARP/Broadcasts/Multicast are all filtered by Linux as per the design. Since
the parent interface is essentially acting as a router, the parent interface IP
and subnet needs to be different from the container networks. That is the opposite
of bridge and L2 modes, which need to be on the same subnet (broadcast domain)
in order to forward broadcast and multicast packets.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> Create an IPv6+IPv4 Dual Stack IPvlan L3 network
<span class="gp">#</span> Gateways <span class="k">for </span>both v4 and v6 are <span class="nb">set </span>to a dev e.g. <span class="s1">'default dev eth0'</span>
<span class="gp">$</span> docker network  create  <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.110.0/24 <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.112.0/24 <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>2001:db8:abc6::/64 <span class="se">\</span>
     <span class="nt">-o</span> <span class="nv">parent</span><span class="o">=</span>eth0 <span class="se">\</span>
     <span class="nt">-o</span> <span class="nv">ipvlan_mode</span><span class="o">=</span>l3 ipnet110
<span class="go">

</span><span class="gp">#</span> Start a few of containers on the network <span class="o">(</span>ipnet110<span class="o">)</span>
<span class="gp">#</span> <span class="k">in </span>separate terminals and check connectivity
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipnet110 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">#</span> Start a second container specifying the v6 address
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipnet110 <span class="nt">--ip6</span><span class="o">=</span>2001:db8:abc6::10 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">#</span> Start a third specifying the IPv4 address
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipnet110 <span class="nt">--ip</span><span class="o">=</span>192.168.112.30 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">#</span> Start a 4th specifying both the IPv4 and IPv6 addresses
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipnet110 <span class="nt">--ip6</span><span class="o">=</span>2001:db8:abc6::50 <span class="nt">--ip</span><span class="o">=</span>192.168.112.50 <span class="nt">-it</span> <span class="nt">--rm</span> alpine /bin/sh
</code></pre></div></div>

<p>Interface and routing table outputs are as follows:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="nv">$ </span>ip a show eth0
<span class="gp">63: eth0@if59: &lt;BROADCAST,MULTICAST,NOARP,UP,LOWER_UP&gt;</span> mtu 1500 qdisc noqueue state UNKNOWN group default
<span class="go">    link/ether 00:50:56:2b:29:40 brd ff:ff:ff:ff:ff:ff
    inet 192.168.112.2/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 2001:db8:abc4::250:56ff:fe2b:2940/64 scope link
       valid_lft forever preferred_lft forever
    inet6 2001:db8:abc6::10/64 scope link nodad
       valid_lft forever preferred_lft forever

</span><span class="gp">#</span> Note the default route is the eth device because ARPs are filtered.
<span class="gp">$</span><span class="nv">$ </span>ip route
<span class="go">  default dev eth0  scope link
  192.168.112.0/24 dev eth0  proto kernel  scope link  src 192.168.112.2

</span><span class="gp">$</span><span class="nv">$ </span>ip <span class="nt">-6</span> route
<span class="go">2001:db8:abc4::/64 dev eth0  proto kernel  metric 256
2001:db8:abc6::/64 dev eth0  proto kernel  metric 256
default dev eth0  metric 1024
</span></code></pre></div></div>

<blockquote>
  <p><em>Note</em></p>

  <p>There may be a bug when specifying <code class="highlighter-rouge">--ip6=</code> addresses when you delete a
container with a specified v6 address and then start a new container with the
same v6 address it throws the following like the address isn’t properly being
released to the v6 pool. It will fail to unmount the container and be left dead.</p>
</blockquote>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker: Error response from daemon: Address already in use.
</span></code></pre></div></div>

<h2 id="manually-create-8021q-links">Manually create 802.1q links</h2>

<h3 id="vlan-id-40">VLAN ID 40</h3>

<p>If a user does not want the driver to create the VLAN sub-interface, it needs to
exist before running <code class="highlighter-rouge">docker network create</code>. If you have sub-interface
naming that is not <code class="highlighter-rouge">interface.vlan_id</code> it is honored in the <code class="highlighter-rouge">-o parent=</code> option
again as long as the interface exists and is up.</p>

<p>Links, when manually created, can be named anything as long as they exist when
the network is created. Manually created links do not get deleted regardless of
the name when the network is deleted with <code class="highlighter-rouge">docker network rm</code>.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> create a new sub-interface tied to dot1q vlan 40
<span class="gp">$</span> ip link add link eth0 name eth0.40 <span class="nb">type </span>vlan id 40
<span class="go">
</span><span class="gp">#</span> <span class="nb">enable </span>the new sub-interface
<span class="gp">$</span> ip link <span class="nb">set </span>eth0.40 up
<span class="go">
</span><span class="gp">#</span> now add networks and hosts as you would normally by attaching to the master <span class="o">(</span>sub<span class="o">)</span>interface that is tagged
<span class="gp">$</span> docker network  create  <span class="nt">-d</span> ipvlan <span class="se">\</span>
   <span class="nt">--subnet</span><span class="o">=</span>192.168.40.0/24 <span class="se">\</span>
   <span class="nt">--gateway</span><span class="o">=</span>192.168.40.1 <span class="se">\</span>
   <span class="nt">-o</span> <span class="nv">parent</span><span class="o">=</span>eth0.40 ipvlan40
<span class="go">
</span><span class="gp">#</span> <span class="k">in </span>two separate terminals, start a Docker container and the containers can now ping one another.
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan40 <span class="nt">-it</span> <span class="nt">--name</span> ivlan_test5 <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan40 <span class="nt">-it</span> <span class="nt">--name</span> ivlan_test6 <span class="nt">--rm</span> alpine /bin/sh
</code></pre></div></div>

<p><strong>Example:</strong> VLAN sub-interface manually created with any name:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> create a new sub interface tied to dot1q vlan 40
<span class="gp">$</span> ip link add link eth0 name foo <span class="nb">type </span>vlan id 40
<span class="go">
</span><span class="gp">#</span> <span class="nb">enable </span>the new sub-interface
<span class="gp">$</span> ip link <span class="nb">set </span>foo up
<span class="go">
</span><span class="gp">#</span> now add networks and hosts as you would normally by attaching to the master <span class="o">(</span>sub<span class="o">)</span>interface that is tagged
<span class="gp">$</span> docker network  create  <span class="nt">-d</span> ipvlan <span class="se">\</span>
    <span class="nt">--subnet</span><span class="o">=</span>192.168.40.0/24 <span class="nt">--gateway</span><span class="o">=</span>192.168.40.1 <span class="se">\</span>
    <span class="nt">-o</span> <span class="nv">parent</span><span class="o">=</span>foo ipvlan40
<span class="go">
</span><span class="gp">#</span> <span class="k">in </span>two separate terminals, start a Docker container and the containers can now ping one another.
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan40 <span class="nt">-it</span> <span class="nt">--name</span> ivlan_test5 <span class="nt">--rm</span> alpine /bin/sh
<span class="gp">$</span> docker run <span class="nt">--net</span><span class="o">=</span>ipvlan40 <span class="nt">-it</span> <span class="nt">--name</span> ivlan_test6 <span class="nt">--rm</span> alpine /bin/sh
</code></pre></div></div>

<p>Manually created links can be cleaned up with:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> ip link del foo
</code></pre></div></div>

<p>As with all of the Libnetwork drivers, they can be mixed and matched, even as
far as running 3rd party ecosystem drivers in parallel for maximum flexibility
to the Docker user.</p>
<span class="glyphicon glyphicon-tags" style="padding-right: 10px"></span><span style="vertical-align: 2px"><a href="/docs.docker.jp.onthefly/search/?q=network">network</a>, <a href="/docs.docker.jp.onthefly/search/?q=ipvlan">ipvlan</a>, <a href="/docs.docker.jp.onthefly/search/?q=l2">l2</a>, <a href="/docs.docker.jp.onthefly/search/?q=l3">l3</a>, <a href="/docs.docker.jp.onthefly/search/?q=standalone">standalone</a></span><div class="ratings-div"><div id="pd_rating_holder_8453675"></div></div></section>
                    </main>
                    <nav class="col-nav">
                        <div id="sidebar-nav" class="sidebar hidden-sm hidden-xs">
                            <div id="navbar" class="nav-sidebar">
                                <ul class="nav hidden-md hidden-lg"></ul>
                                <ul class="nav" id="jsTOCLeftNav"></ul>
                            </div>
                        </div>
                    </nav>
                    <div class="col-toc">
                        <div class="sidebar hidden-xs hidden-sm">
                            <div class="toc-nav">
                                <div class="feedback-links">
                                    <ul><li><a href="https://github.com/matsuand/docs.docker.jp.onthefly/edit/master/src/network/ipvlan.ch"><i class="fa fa-pencil-square-o" aria-hidden="true"></i> 本ページの編集</a></li><li><a href="https://github.com/matsuand/docs.docker.jp.onthefly/issues/new?body=File: [network/ipvlan.ch](https://matsuand.github.io/docs.docker.jp.onthefly/network/ipvlan/)" class="nomunge"><i class="fa fa-check" aria-hidden="true"></i> 変更リクエスト</a></li>
                                        <li><div class="toggle-mode">
  <div class="icon">
      <i class="fa fa-sun-o" aria-hidden="true"></i>
  </div>
  <div class="toggle-switch">
      <label class="switch">
          <input type="checkbox" id="switch-style">
          <span class="slider round"></span>
      </label>
  </div>
  <div class="icon">
      <i class="fa fa-moon-o" aria-hidden="true"></i>
  </div>
</div>
</li>
                                    </ul>
                                </div><div id="side-toc-title">本ページ内:</div>
<ul id="my_toc" class="inline_toc">
  <li><a href="#prerequisites" class="nomunge">Prerequisites</a></li>
  <li><a href="#ipvlan-l2-mode-example-usage" class="nomunge">IPvlan L2 mode example usage</a></li>
  <li><a href="#ipvlan-8021q-trunk-l2-mode-example-usage" class="nomunge">IPvlan 802.1q trunk L2 mode example usage</a>
    <ul>
      <li><a href="#vlan-id-20" class="nomunge">VLAN ID 20</a></li>
      <li><a href="#vlan-id-30" class="nomunge">VLAN ID 30</a></li>
    </ul>
  </li>
  <li><a href="#ipvlan-l3-mode-example" class="nomunge">IPvlan L3 mode example</a></li>
  <li><a href="#dual-stack-ipv4-ipv6-ipvlan-l2-mode" class="nomunge">Dual stack IPv4 IPv6 IPvlan L2 mode</a></li>
  <li><a href="#dual-stack-ipv4-ipv6-ipvlan-l3-mode" class="nomunge">Dual stack IPv4 IPv6 IPvlan L3 mode</a></li>
  <li><a href="#manually-create-8021q-links" class="nomunge">Manually create 802.1q links</a>
    <ul>
      <li><a href="#vlan-id-40" class="nomunge">VLAN ID 40</a></li>
    </ul>
  </li>
</ul>

</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer class="footer">
          
    <div class="container">
        <div class="top_footer">
            <div class="row">
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products" target="_blank" rel="noopener">製品ラインアップ</a></b></li>
                        <li><a href="https://www.docker.com/products/personal" target="_blank" rel="noopener">Docker Personal</a></li>
                        <li><a href="https://www.docker.com/products/pro" target="_blank" rel="noopener">Docker Pro</a></li>
                        <li><a href="https://www.docker.com/products/team" target="_blank" rel="noopener">Docker Team</a></li>
                        <li><a href="https://www.docker.com/products/business" target="_blank" rel="noopener">Docker Business</a></li>
                        <li><a href="https://www.docker.com/products" target="_blank" rel="noopener">サブスクリプション比較</a></li>
                        <li><b><a href="https://www.docker.com/" target="_blank" rel="noopener">機能</a></b></li>
                        <li><a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker Desktop</a></li>
                        <li><a href="https://www.docker.com/products/docker-hub" target="_blank" rel="noopener">Docker Hub</a></li>
                        <li><a href="https://www.docker.com/products/secure-software-supply-chain" target="_blank" rel="noopener">セキュアなソフトウェアサプライチェーン</a></li>
                        <li><a href="https://www.docker.com/products/container-runtime" target="_blank" rel="noopener">コンテナーランタイム</a></li>
                        <li><a href="https://www.docker.com/products/developer-tools" target="_blank" rel="noopener">開発ツール</a></li>
                        <li><a href="https://www.docker.com/partners" target="_blank" rel="noopener">信頼できるコンテント</a></li>
                        <li><a href="https://www.docker.com/roadmap" target="_blank" rel="noopener">Docker 製品ロードマップ</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">開発者</a></b></li>
                        <li><a href="https://www.docker.com/use-cases" target="_blank" rel="noopener">利用例</a></li>
                        <li><a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">はじめよう</a></li>
                        <li><a href="https://www.docker.com/blog/" target="_blank" rel="noopener">ブログ</a></li>
                        <li><a href="https://www.docker.com/docker-community" target="_blank" rel="noopener">コミュニティー</a></li>
                        <li><a href="https://www.docker.com/open-source" target="_blank" rel="noopener">オープンソース</a></li>
                        <li><a href="https://www.docker.com/community/get-involved/developer-preview" target="_blank" rel="noopener">プレビュープログラム</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">価格体系</a></b></li>
                        <li><a href="https://www.docker.com/pricing/faq" target="_blank" rel="noopener">FAQ</a></li>
                        <li><a href="https://www.docker.com/partners/programs" target="_blank" rel="noopener">Docker 認定公開者向けプログラム</a></li>
                        <li><a href="https://www.docker.com/partners" target="_blank" rel="noopener">パートナー</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/company" target="_blank" rel="noopener">会社概要</a></b></li>
                        <li><a href="https://www.docker.com/what-container" target="_blank" rel="noopener">コンテナーって何？</a></li>
                        <li><a href="https://www.docker.com/why-docker" target="_blank" rel="noopener">なぜ Docker？</a></li>
                        <li><a href="https://www.docker.com/events" target="_blank" rel="noopener">仮想イベント</a></li>
                        <li><a href="https://www.docker.com/swag" target="_blank" rel="noopener">Swag ストア
                        </a></li>
                        <li><a href="https://www.docker.com/company/newsroom" target="_blank" rel="noopener">ニュースルーム</a></li>
                        <li><a href="https://www.docker.com/careers" target="_blank" rel="noopener">採用情報</a></li>
                        <li><a href="https://www.docker.com/company/contact" target="_blank" rel="noopener">連絡先</a></li>
                        <li><a href="https://www.docker.com/customers" target="_blank" rel="noopener">顧客</a></li>
                        <li><a href="https://www.docker.com/newsletter-subscription" target="_blank" rel="noopener">ニュースレター</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-nav">
                <nav class="footer_sub_nav">
                    <ul class="menu">
                        <li><a href="https://www.docker.com/legal/docker-terms-service" target="_blank" rel="noopener">サービス契約</a></li>
                        <li><a href="https://status.docker.com/" target="_blank" rel="noopener">ステータス</a></li>
                        <li><a href="https://www.docker.com/legal" target="_blank" rel="noopener">法的情報</a></li>
                    </ul>
                </nav>
            </div>
        </div>
        <div class="bottom_footer">
            <div class="footer-copyright col-xs-12 col-md-8">
                <p class="copyright">
                    Copyright &copy; 2013-2021 Docker Inc. All rights reserved. </p>
            </div>
            <div class="footer_social_nav">
                <ul class="nav-social">
                    <li class="fa fa-twitter"><a href="https://twitter.com/docker">Twitter</a></li>
                    <li class="fa fa-youtube"><a href="https://www.youtube.com/user/dockerrun">Youtube</a></li>
                    <li class="fa fa-github"><a href="https://github.com/docker">GitHub</a></li>
                    <li class="fa fa-linkedin"><a href="https://www.linkedin.com/company/docker">Linkedin</a></li>
                    <li class="fa fa-facebook"><a href="https://www.facebook.com/docker.run">Facebook</a></li>
                    <li class="fa fa-slideshare"><a href="https://www.slideshare.net/docker">Slideshare</a></li>
                    <li class="fa fa-reddit"><a href="https://www.reddit.com/r/docker">Reddit</a></li>
                </ul>
            </div>
        </div>
    </div>

    </footer>
    <script>const pageURL = "/network/ipvlan/";</script></body>
</html>
